"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bitcoinjs-lib@6.1.7";
exports.ids = ["vendor-chunks/bitcoinjs-lib@6.1.7"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/address.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/address.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toOutputScript =\n  exports.fromOutputScript =\n  exports.toBech32 =\n  exports.toBase58Check =\n  exports.fromBech32 =\n  exports.fromBase58Check =\n    void 0;\nconst networks = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst payments = __webpack_require__(/*! ./payments */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js\");\nconst bscript = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst bech32_1 = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js\");\nconst bs58check = __webpack_require__(/*! bs58check */ \"(ssr)/./node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/index.js\");\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\n/**\n * decode address with base58 specification,  return address version and address hash if valid\n */\nfunction fromBase58Check(address) {\n  const payload = Buffer.from(bs58check.decode(address));\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\n/**\n * decode address with bech32 specification,  return address versionã€address prefix and address data if valid\n */\nfunction fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32_1.bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32_1.bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32_1.bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\n/**\n * encode address hash to base58 address with version\n */\nfunction toBase58Check(hash, version) {\n  (0, types_1.typeforce)(\n    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),\n    arguments,\n  );\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\n/**\n * encode address hash to bech32 address with version and prefix\n */\nfunction toBech32(data, version, prefix) {\n  const words = bech32_1.bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32_1.bech32.encode(prefix, words)\n    : bech32_1.bech32m.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\n/**\n * decode address from output script with network, return address if matched\n */\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\n/**\n * encodes address to output script with network, return output script if address matched\n */\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsRUFBRSx3QkFBd0I7QUFDMUIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxxQkFBcUI7QUFDdkIsRUFBRSxrQkFBa0I7QUFDcEIsRUFBRSx1QkFBdUI7QUFDekI7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw2R0FBWTtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyxtSEFBWTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyx5R0FBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1R0FBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBUTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyw2RkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDLElBQUk7QUFDSjtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUMsSUFBSTtBQUNKO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QyxJQUFJO0FBQ0o7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDLElBQUk7QUFDSjtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUMsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQ7QUFDQSw2QkFBNkIseUJBQXlCO0FBQ3RELElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRCxRQUFRO0FBQ1I7QUFDQSxpQ0FBaUMsMkJBQTJCO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9hZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvT3V0cHV0U2NyaXB0ID1cbiAgZXhwb3J0cy5mcm9tT3V0cHV0U2NyaXB0ID1cbiAgZXhwb3J0cy50b0JlY2gzMiA9XG4gIGV4cG9ydHMudG9CYXNlNThDaGVjayA9XG4gIGV4cG9ydHMuZnJvbUJlY2gzMiA9XG4gIGV4cG9ydHMuZnJvbUJhc2U1OENoZWNrID1cbiAgICB2b2lkIDA7XG5jb25zdCBuZXR3b3JrcyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbmNvbnN0IHBheW1lbnRzID0gcmVxdWlyZSgnLi9wYXltZW50cycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKCdiZWNoMzInKTtcbmNvbnN0IGJzNThjaGVjayA9IHJlcXVpcmUoJ2JzNThjaGVjaycpO1xuY29uc3QgRlVUVVJFX1NFR1dJVF9NQVhfU0laRSA9IDQwO1xuY29uc3QgRlVUVVJFX1NFR1dJVF9NSU5fU0laRSA9IDI7XG5jb25zdCBGVVRVUkVfU0VHV0lUX01BWF9WRVJTSU9OID0gMTY7XG5jb25zdCBGVVRVUkVfU0VHV0lUX01JTl9WRVJTSU9OID0gMjtcbmNvbnN0IEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9ESUZGID0gMHg1MDtcbmNvbnN0IEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9XQVJOSU5HID1cbiAgJ1dBUk5JTkc6IFNlbmRpbmcgdG8gYSBmdXR1cmUgc2Vnd2l0IHZlcnNpb24gYWRkcmVzcyBjYW4gbGVhZCB0byBsb3NzIG9mIGZ1bmRzLiAnICtcbiAgJ0VuZCB1c2VycyBNVVNUIGJlIHdhcm5lZCBjYXJlZnVsbHkgaW4gdGhlIEdVSSBhbmQgYXNrZWQgaWYgdGhleSB3aXNoIHRvIHByb2NlZWQgJyArXG4gICd3aXRoIGNhdXRpb24uIFdhbGxldHMgc2hvdWxkIHZlcmlmeSB0aGUgc2Vnd2l0IHZlcnNpb24gZnJvbSB0aGUgb3V0cHV0IG9mIGZyb21CZWNoMzIsICcgK1xuICAndGhlbiBkZWNpZGUgd2hlbiBpdCBpcyBzYWZlIHRvIHVzZSB3aGljaCB2ZXJzaW9uIG9mIHNlZ3dpdC4nO1xuZnVuY3Rpb24gX3RvRnV0dXJlU2Vnd2l0QWRkcmVzcyhvdXRwdXQsIG5ldHdvcmspIHtcbiAgY29uc3QgZGF0YSA9IG91dHB1dC5zbGljZSgyKTtcbiAgaWYgKFxuICAgIGRhdGEubGVuZ3RoIDwgRlVUVVJFX1NFR1dJVF9NSU5fU0laRSB8fFxuICAgIGRhdGEubGVuZ3RoID4gRlVUVVJFX1NFR1dJVF9NQVhfU0laRVxuICApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcm9ncmFtIGxlbmd0aCBmb3Igc2Vnd2l0IGFkZHJlc3MnKTtcbiAgY29uc3QgdmVyc2lvbiA9IG91dHB1dFswXSAtIEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9ESUZGO1xuICBpZiAoXG4gICAgdmVyc2lvbiA8IEZVVFVSRV9TRUdXSVRfTUlOX1ZFUlNJT04gfHxcbiAgICB2ZXJzaW9uID4gRlVUVVJFX1NFR1dJVF9NQVhfVkVSU0lPTlxuICApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIGZvciBzZWd3aXQgYWRkcmVzcycpO1xuICBpZiAob3V0cHV0WzFdICE9PSBkYXRhLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNjcmlwdCBmb3Igc2Vnd2l0IGFkZHJlc3MnKTtcbiAgY29uc29sZS53YXJuKEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9XQVJOSU5HKTtcbiAgcmV0dXJuIHRvQmVjaDMyKGRhdGEsIHZlcnNpb24sIG5ldHdvcmsuYmVjaDMyKTtcbn1cbi8qKlxuICogZGVjb2RlIGFkZHJlc3Mgd2l0aCBiYXNlNTggc3BlY2lmaWNhdGlvbiwgIHJldHVybiBhZGRyZXNzIHZlcnNpb24gYW5kIGFkZHJlc3MgaGFzaCBpZiB2YWxpZFxuICovXG5mdW5jdGlvbiBmcm9tQmFzZTU4Q2hlY2soYWRkcmVzcykge1xuICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oYnM1OGNoZWNrLmRlY29kZShhZGRyZXNzKSk7XG4gIC8vIFRPRE86IDQuMC4wLCBtb3ZlIHRvIFwidG9PdXRwdXRTY3JpcHRcIlxuICBpZiAocGF5bG9hZC5sZW5ndGggPCAyMSkgdGhyb3cgbmV3IFR5cGVFcnJvcihhZGRyZXNzICsgJyBpcyB0b28gc2hvcnQnKTtcbiAgaWYgKHBheWxvYWQubGVuZ3RoID4gMjEpIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgaXMgdG9vIGxvbmcnKTtcbiAgY29uc3QgdmVyc2lvbiA9IHBheWxvYWQucmVhZFVJbnQ4KDApO1xuICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgcmV0dXJuIHsgdmVyc2lvbiwgaGFzaCB9O1xufVxuZXhwb3J0cy5mcm9tQmFzZTU4Q2hlY2sgPSBmcm9tQmFzZTU4Q2hlY2s7XG4vKipcbiAqIGRlY29kZSBhZGRyZXNzIHdpdGggYmVjaDMyIHNwZWNpZmljYXRpb24sICByZXR1cm4gYWRkcmVzcyB2ZXJzaW9u44CBYWRkcmVzcyBwcmVmaXggYW5kIGFkZHJlc3MgZGF0YSBpZiB2YWxpZFxuICovXG5mdW5jdGlvbiBmcm9tQmVjaDMyKGFkZHJlc3MpIHtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IHZlcnNpb247XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgaWYgKHJlc3VsdCkge1xuICAgIHZlcnNpb24gPSByZXN1bHQud29yZHNbMF07XG4gICAgaWYgKHZlcnNpb24gIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgdXNlcyB3cm9uZyBlbmNvZGluZycpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGJlY2gzMl8xLmJlY2gzMm0uZGVjb2RlKGFkZHJlc3MpO1xuICAgIHZlcnNpb24gPSByZXN1bHQud29yZHNbMF07XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgdXNlcyB3cm9uZyBlbmNvZGluZycpO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBiZWNoMzJfMS5iZWNoMzIuZnJvbVdvcmRzKHJlc3VsdC53b3Jkcy5zbGljZSgxKSk7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbixcbiAgICBwcmVmaXg6IHJlc3VsdC5wcmVmaXgsXG4gICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YSksXG4gIH07XG59XG5leHBvcnRzLmZyb21CZWNoMzIgPSBmcm9tQmVjaDMyO1xuLyoqXG4gKiBlbmNvZGUgYWRkcmVzcyBoYXNoIHRvIGJhc2U1OCBhZGRyZXNzIHdpdGggdmVyc2lvblxuICovXG5mdW5jdGlvbiB0b0Jhc2U1OENoZWNrKGhhc2gsIHZlcnNpb24pIHtcbiAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKShcbiAgICAoMCwgdHlwZXNfMS50dXBsZSkodHlwZXNfMS5IYXNoMTYwYml0LCB0eXBlc18xLlVJbnQ4KSxcbiAgICBhcmd1bWVudHMsXG4gICk7XG4gIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjEpO1xuICBwYXlsb2FkLndyaXRlVUludDgodmVyc2lvbiwgMCk7XG4gIGhhc2guY29weShwYXlsb2FkLCAxKTtcbiAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUocGF5bG9hZCk7XG59XG5leHBvcnRzLnRvQmFzZTU4Q2hlY2sgPSB0b0Jhc2U1OENoZWNrO1xuLyoqXG4gKiBlbmNvZGUgYWRkcmVzcyBoYXNoIHRvIGJlY2gzMiBhZGRyZXNzIHdpdGggdmVyc2lvbiBhbmQgcHJlZml4XG4gKi9cbmZ1bmN0aW9uIHRvQmVjaDMyKGRhdGEsIHZlcnNpb24sIHByZWZpeCkge1xuICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMi50b1dvcmRzKGRhdGEpO1xuICB3b3Jkcy51bnNoaWZ0KHZlcnNpb24pO1xuICByZXR1cm4gdmVyc2lvbiA9PT0gMFxuICAgID8gYmVjaDMyXzEuYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzKVxuICAgIDogYmVjaDMyXzEuYmVjaDMybS5lbmNvZGUocHJlZml4LCB3b3Jkcyk7XG59XG5leHBvcnRzLnRvQmVjaDMyID0gdG9CZWNoMzI7XG4vKipcbiAqIGRlY29kZSBhZGRyZXNzIGZyb20gb3V0cHV0IHNjcmlwdCB3aXRoIG5ldHdvcmssIHJldHVybiBhZGRyZXNzIGlmIG1hdGNoZWRcbiAqL1xuZnVuY3Rpb24gZnJvbU91dHB1dFNjcmlwdChvdXRwdXQsIG5ldHdvcmspIHtcbiAgLy8gVE9ETzogTmV0d29ya1xuICBuZXR3b3JrID0gbmV0d29yayB8fCBuZXR3b3Jrcy5iaXRjb2luO1xuICB0cnkge1xuICAgIHJldHVybiBwYXltZW50cy5wMnBraCh7IG91dHB1dCwgbmV0d29yayB9KS5hZGRyZXNzO1xuICB9IGNhdGNoIChlKSB7fVxuICB0cnkge1xuICAgIHJldHVybiBwYXltZW50cy5wMnNoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAyd3BraCh7IG91dHB1dCwgbmV0d29yayB9KS5hZGRyZXNzO1xuICB9IGNhdGNoIChlKSB7fVxuICB0cnkge1xuICAgIHJldHVybiBwYXltZW50cy5wMndzaCh7IG91dHB1dCwgbmV0d29yayB9KS5hZGRyZXNzO1xuICB9IGNhdGNoIChlKSB7fVxuICB0cnkge1xuICAgIHJldHVybiBwYXltZW50cy5wMnRyKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIF90b0Z1dHVyZVNlZ3dpdEFkZHJlc3Mob3V0cHV0LCBuZXR3b3JrKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgdGhyb3cgbmV3IEVycm9yKGJzY3JpcHQudG9BU00ob3V0cHV0KSArICcgaGFzIG5vIG1hdGNoaW5nIEFkZHJlc3MnKTtcbn1cbmV4cG9ydHMuZnJvbU91dHB1dFNjcmlwdCA9IGZyb21PdXRwdXRTY3JpcHQ7XG4vKipcbiAqIGVuY29kZXMgYWRkcmVzcyB0byBvdXRwdXQgc2NyaXB0IHdpdGggbmV0d29yaywgcmV0dXJuIG91dHB1dCBzY3JpcHQgaWYgYWRkcmVzcyBtYXRjaGVkXG4gKi9cbmZ1bmN0aW9uIHRvT3V0cHV0U2NyaXB0KGFkZHJlc3MsIG5ldHdvcmspIHtcbiAgbmV0d29yayA9IG5ldHdvcmsgfHwgbmV0d29ya3MuYml0Y29pbjtcbiAgbGV0IGRlY29kZUJhc2U1ODtcbiAgbGV0IGRlY29kZUJlY2gzMjtcbiAgdHJ5IHtcbiAgICBkZWNvZGVCYXNlNTggPSBmcm9tQmFzZTU4Q2hlY2soYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIGlmIChkZWNvZGVCYXNlNTgpIHtcbiAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsucHViS2V5SGFzaClcbiAgICAgIHJldHVybiBwYXltZW50cy5wMnBraCh7IGhhc2g6IGRlY29kZUJhc2U1OC5oYXNoIH0pLm91dHB1dDtcbiAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsuc2NyaXB0SGFzaClcbiAgICAgIHJldHVybiBwYXltZW50cy5wMnNoKHsgaGFzaDogZGVjb2RlQmFzZTU4Lmhhc2ggfSkub3V0cHV0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVCZWNoMzIgPSBmcm9tQmVjaDMyKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGRlY29kZUJlY2gzMikge1xuICAgICAgaWYgKGRlY29kZUJlY2gzMi5wcmVmaXggIT09IG5ldHdvcmsuYmVjaDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYWRkcmVzcyArICcgaGFzIGFuIGludmFsaWQgcHJlZml4Jyk7XG4gICAgICBpZiAoZGVjb2RlQmVjaDMyLnZlcnNpb24gPT09IDApIHtcbiAgICAgICAgaWYgKGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA9PT0gMjApXG4gICAgICAgICAgcmV0dXJuIHBheW1lbnRzLnAyd3BraCh7IGhhc2g6IGRlY29kZUJlY2gzMi5kYXRhIH0pLm91dHB1dDtcbiAgICAgICAgaWYgKGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA9PT0gMzIpXG4gICAgICAgICAgcmV0dXJuIHBheW1lbnRzLnAyd3NoKHsgaGFzaDogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgfSBlbHNlIGlmIChkZWNvZGVCZWNoMzIudmVyc2lvbiA9PT0gMSkge1xuICAgICAgICBpZiAoZGVjb2RlQmVjaDMyLmRhdGEubGVuZ3RoID09PSAzMilcbiAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ0cih7IHB1YmtleTogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZGVjb2RlQmVjaDMyLnZlcnNpb24gPj0gRlVUVVJFX1NFR1dJVF9NSU5fVkVSU0lPTiAmJlxuICAgICAgICBkZWNvZGVCZWNoMzIudmVyc2lvbiA8PSBGVVRVUkVfU0VHV0lUX01BWF9WRVJTSU9OICYmXG4gICAgICAgIGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA+PSBGVVRVUkVfU0VHV0lUX01JTl9TSVpFICYmXG4gICAgICAgIGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA8PSBGVVRVUkVfU0VHV0lUX01BWF9TSVpFXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS53YXJuKEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbXG4gICAgICAgICAgZGVjb2RlQmVjaDMyLnZlcnNpb24gKyBGVVRVUkVfU0VHV0lUX1ZFUlNJT05fRElGRixcbiAgICAgICAgICBkZWNvZGVCZWNoMzIuZGF0YSxcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihhZGRyZXNzICsgJyBoYXMgbm8gbWF0Y2hpbmcgU2NyaXB0Jyk7XG59XG5leHBvcnRzLnRvT3V0cHV0U2NyaXB0ID0gdG9PdXRwdXRTY3JpcHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bip66.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bip66.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\n// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n// NOTE: SIGHASH byte ignored AND restricted, truncate before use\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = exports.check = void 0;\nfunction check(buffer) {\n  if (buffer.length < 8) return false;\n  if (buffer.length > 72) return false;\n  if (buffer[0] !== 0x30) return false;\n  if (buffer[1] !== buffer.length - 2) return false;\n  if (buffer[2] !== 0x02) return false;\n  const lenR = buffer[3];\n  if (lenR === 0) return false;\n  if (5 + lenR >= buffer.length) return false;\n  if (buffer[4 + lenR] !== 0x02) return false;\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) return false;\n  if (6 + lenR + lenS !== buffer.length) return false;\n  if (buffer[4] & 0x80) return false;\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;\n  if (buffer[lenR + 6] & 0x80) return false;\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    return false;\n  return true;\n}\nexports.check = check;\nfunction decode(buffer) {\n  if (buffer.length < 8) throw new Error('DER sequence length is too short');\n  if (buffer.length > 72) throw new Error('DER sequence length is too long');\n  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');\n  if (buffer[1] !== buffer.length - 2)\n    throw new Error('DER sequence length is invalid');\n  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');\n  const lenR = buffer[3];\n  if (lenR === 0) throw new Error('R length is zero');\n  if (5 + lenR >= buffer.length) throw new Error('R length is too long');\n  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) throw new Error('S length is zero');\n  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');\n  if (buffer[4] & 0x80) throw new Error('R value is negative');\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n    throw new Error('R value excessively padded');\n  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    throw new Error('S value excessively padded');\n  // non-BIP66 - extract R, S values\n  return {\n    r: buffer.slice(4, 4 + lenR),\n    s: buffer.slice(6 + lenR),\n  };\n}\nexports.decode = decode;\n/*\n * Expects r and s to be positive DER integers.\n *\n * The DER format uses the most significant bit as a sign bit (& 0x80).\n * If the significant bit is set AND the integer is positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n */\nfunction encode(r, s) {\n  const lenR = r.length;\n  const lenS = s.length;\n  if (lenR === 0) throw new Error('R length is zero');\n  if (lenS === 0) throw new Error('S length is zero');\n  if (lenR > 33) throw new Error('R length is too long');\n  if (lenS > 33) throw new Error('S length is too long');\n  if (r[0] & 0x80) throw new Error('R value is negative');\n  if (s[0] & 0x80) throw new Error('S value is negative');\n  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n    throw new Error('R value excessively padded');\n  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n    throw new Error('S value excessively padded');\n  const signature = Buffer.allocUnsafe(6 + lenR + lenS);\n  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  signature[0] = 0x30;\n  signature[1] = signature.length - 2;\n  signature[2] = 0x02;\n  signature[3] = r.length;\n  r.copy(signature, 4);\n  signature[4 + lenR] = 0x02;\n  signature[5 + lenR] = s.length;\n  s.copy(signature, 6 + lenR);\n  return signature;\n}\nexports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYmlwNjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2JpcDY2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIFJlZmVyZW5jZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraVxuLy8gRm9ybWF0OiAweDMwIFt0b3RhbC1sZW5ndGhdIDB4MDIgW1ItbGVuZ3RoXSBbUl0gMHgwMiBbUy1sZW5ndGhdIFtTXVxuLy8gTk9URTogU0lHSEFTSCBieXRlIGlnbm9yZWQgQU5EIHJlc3RyaWN0ZWQsIHRydW5jYXRlIGJlZm9yZSB1c2Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5jaGVjayA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNoZWNrKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IDgpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPiA3MikgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmZmVyWzBdICE9PSAweDMwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXJbMV0gIT09IGJ1ZmZlci5sZW5ndGggLSAyKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXJbMl0gIT09IDB4MDIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGVuUiA9IGJ1ZmZlclszXTtcbiAgaWYgKGxlblIgPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKDUgKyBsZW5SID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZmZlcls0ICsgbGVuUl0gIT09IDB4MDIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGVuUyA9IGJ1ZmZlcls1ICsgbGVuUl07XG4gIGlmIChsZW5TID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICg2ICsgbGVuUiArIGxlblMgIT09IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZmZlcls0XSAmIDB4ODApIHJldHVybiBmYWxzZTtcbiAgaWYgKGxlblIgPiAxICYmIGJ1ZmZlcls0XSA9PT0gMHgwMCAmJiAhKGJ1ZmZlcls1XSAmIDB4ODApKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXJbbGVuUiArIDZdICYgMHg4MCkgcmV0dXJuIGZhbHNlO1xuICBpZiAobGVuUyA+IDEgJiYgYnVmZmVyW2xlblIgKyA2XSA9PT0gMHgwMCAmJiAhKGJ1ZmZlcltsZW5SICsgN10gJiAweDgwKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IDgpIHRocm93IG5ldyBFcnJvcignREVSIHNlcXVlbmNlIGxlbmd0aCBpcyB0b28gc2hvcnQnKTtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPiA3MikgdGhyb3cgbmV3IEVycm9yKCdERVIgc2VxdWVuY2UgbGVuZ3RoIGlzIHRvbyBsb25nJyk7XG4gIGlmIChidWZmZXJbMF0gIT09IDB4MzApIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgREVSIHNlcXVlbmNlJyk7XG4gIGlmIChidWZmZXJbMV0gIT09IGJ1ZmZlci5sZW5ndGggLSAyKVxuICAgIHRocm93IG5ldyBFcnJvcignREVSIHNlcXVlbmNlIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIGlmIChidWZmZXJbMl0gIT09IDB4MDIpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgREVSIGludGVnZXInKTtcbiAgY29uc3QgbGVuUiA9IGJ1ZmZlclszXTtcbiAgaWYgKGxlblIgPT09IDApIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgemVybycpO1xuICBpZiAoNSArIGxlblIgPj0gYnVmZmVyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdSIGxlbmd0aCBpcyB0b28gbG9uZycpO1xuICBpZiAoYnVmZmVyWzQgKyBsZW5SXSAhPT0gMHgwMikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBERVIgaW50ZWdlciAoMiknKTtcbiAgY29uc3QgbGVuUyA9IGJ1ZmZlcls1ICsgbGVuUl07XG4gIGlmIChsZW5TID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHplcm8nKTtcbiAgaWYgKDYgKyBsZW5SICsgbGVuUyAhPT0gYnVmZmVyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIGlmIChidWZmZXJbNF0gJiAweDgwKSB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgaWYgKGxlblIgPiAxICYmIGJ1ZmZlcls0XSA9PT0gMHgwMCAmJiAhKGJ1ZmZlcls1XSAmIDB4ODApKVxuICAgIHRocm93IG5ldyBFcnJvcignUiB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgaWYgKGJ1ZmZlcltsZW5SICsgNl0gJiAweDgwKSB0aHJvdyBuZXcgRXJyb3IoJ1MgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgaWYgKGxlblMgPiAxICYmIGJ1ZmZlcltsZW5SICsgNl0gPT09IDB4MDAgJiYgIShidWZmZXJbbGVuUiArIDddICYgMHg4MCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpO1xuICAvLyBub24tQklQNjYgLSBleHRyYWN0IFIsIFMgdmFsdWVzXG4gIHJldHVybiB7XG4gICAgcjogYnVmZmVyLnNsaWNlKDQsIDQgKyBsZW5SKSxcbiAgICBzOiBidWZmZXIuc2xpY2UoNiArIGxlblIpLFxuICB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKlxuICogRXhwZWN0cyByIGFuZCBzIHRvIGJlIHBvc2l0aXZlIERFUiBpbnRlZ2Vycy5cbiAqXG4gKiBUaGUgREVSIGZvcm1hdCB1c2VzIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBhcyBhIHNpZ24gYml0ICgmIDB4ODApLlxuICogSWYgdGhlIHNpZ25pZmljYW50IGJpdCBpcyBzZXQgQU5EIHRoZSBpbnRlZ2VyIGlzIHBvc2l0aXZlLCBhIDB4MDAgaXMgcHJlcGVuZGVkLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgMCA9PiAgICAgMHgwMFxuICogICAgICAxID0+ICAgICAweDAxXG4gKiAgICAgLTEgPT4gICAgIDB4ZmZcbiAqICAgIDEyNyA9PiAgICAgMHg3ZlxuICogICAtMTI3ID0+ICAgICAweDgxXG4gKiAgICAxMjggPT4gICAweDAwODBcbiAqICAgLTEyOCA9PiAgICAgMHg4MFxuICogICAgMjU1ID0+ICAgMHgwMGZmXG4gKiAgIC0yNTUgPT4gICAweGZmMDFcbiAqICAxNjMwMCA9PiAgIDB4M2ZhY1xuICogLTE2MzAwID0+ICAgMHhjMDU0XG4gKiAgNjIzMDAgPT4gMHgwMGYzNWNcbiAqIC02MjMwMCA9PiAweGZmMGNhNFxuICovXG5mdW5jdGlvbiBlbmNvZGUociwgcykge1xuICBjb25zdCBsZW5SID0gci5sZW5ndGg7XG4gIGNvbnN0IGxlblMgPSBzLmxlbmd0aDtcbiAgaWYgKGxlblIgPT09IDApIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgemVybycpO1xuICBpZiAobGVuUyA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB6ZXJvJyk7XG4gIGlmIChsZW5SID4gMzMpIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgdG9vIGxvbmcnKTtcbiAgaWYgKGxlblMgPiAzMykgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB0b28gbG9uZycpO1xuICBpZiAoclswXSAmIDB4ODApIHRocm93IG5ldyBFcnJvcignUiB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICBpZiAoc1swXSAmIDB4ODApIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICBpZiAobGVuUiA+IDEgJiYgclswXSA9PT0gMHgwMCAmJiAhKHJbMV0gJiAweDgwKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gIGlmIChsZW5TID4gMSAmJiBzWzBdID09PSAweDAwICYmICEoc1sxXSAmIDB4ODApKVxuICAgIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDYgKyBsZW5SICsgbGVuUyk7XG4gIC8vIDB4MzAgW3RvdGFsLWxlbmd0aF0gMHgwMiBbUi1sZW5ndGhdIFtSXSAweDAyIFtTLWxlbmd0aF0gW1NdXG4gIHNpZ25hdHVyZVswXSA9IDB4MzA7XG4gIHNpZ25hdHVyZVsxXSA9IHNpZ25hdHVyZS5sZW5ndGggLSAyO1xuICBzaWduYXR1cmVbMl0gPSAweDAyO1xuICBzaWduYXR1cmVbM10gPSByLmxlbmd0aDtcbiAgci5jb3B5KHNpZ25hdHVyZSwgNCk7XG4gIHNpZ25hdHVyZVs0ICsgbGVuUl0gPSAweDAyO1xuICBzaWduYXR1cmVbNSArIGxlblJdID0gcy5sZW5ndGg7XG4gIHMuY29weShzaWduYXR1cmUsIDYgKyBsZW5SKTtcbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bip66.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/block.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/block.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Block = void 0;\nconst bufferutils_1 = __webpack_require__(/*! ./bufferutils */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js\");\nconst bcrypto = __webpack_require__(/*! ./crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nconst merkle_1 = __webpack_require__(/*! ./merkle */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/merkle.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      bufferutils_1.varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    bufferutils_1.varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYmxvY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLG1IQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFVO0FBQ2xDLGlCQUFpQixtQkFBTyxDQUFDLHlHQUFVO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLG1IQUFlO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyx1R0FBUztBQUMvQixRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2Jsb2NrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsb2NrID0gdm9pZCAwO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoJy4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xuY29uc3QgbWVya2xlXzEgPSByZXF1aXJlKCcuL21lcmtsZScpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgeyB0eXBlZm9yY2UgfSA9IHR5cGVzO1xuY29uc3QgZXJyb3JNZXJrbGVOb1R4ZXMgPSBuZXcgVHlwZUVycm9yKFxuICAnQ2Fubm90IGNvbXB1dGUgbWVya2xlIHJvb3QgZm9yIHplcm8gdHJhbnNhY3Rpb25zJyxcbik7XG5jb25zdCBlcnJvcldpdG5lc3NOb3RTZWd3aXQgPSBuZXcgVHlwZUVycm9yKFxuICAnQ2Fubm90IGNvbXB1dGUgd2l0bmVzcyBjb21taXQgZm9yIG5vbi1zZWd3aXQgYmxvY2snLFxuKTtcbmNsYXNzIEJsb2NrIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICB0aGlzLnByZXZIYXNoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWVya2xlUm9vdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IDA7XG4gICAgdGhpcy53aXRuZXNzQ29tbWl0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYml0cyA9IDA7XG4gICAgdGhpcy5ub25jZSA9IDA7XG4gICAgdGhpcy50cmFuc2FjdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCA4MCkgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIgdG9vIHNtYWxsICg8IDgwIGJ5dGVzKScpO1xuICAgIGNvbnN0IGJ1ZmZlclJlYWRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlclJlYWRlcihidWZmZXIpO1xuICAgIGNvbnN0IGJsb2NrID0gbmV3IEJsb2NrKCk7XG4gICAgYmxvY2sudmVyc2lvbiA9IGJ1ZmZlclJlYWRlci5yZWFkSW50MzIoKTtcbiAgICBibG9jay5wcmV2SGFzaCA9IGJ1ZmZlclJlYWRlci5yZWFkU2xpY2UoMzIpO1xuICAgIGJsb2NrLm1lcmtsZVJvb3QgPSBidWZmZXJSZWFkZXIucmVhZFNsaWNlKDMyKTtcbiAgICBibG9jay50aW1lc3RhbXAgPSBidWZmZXJSZWFkZXIucmVhZFVJbnQzMigpO1xuICAgIGJsb2NrLmJpdHMgPSBidWZmZXJSZWFkZXIucmVhZFVJbnQzMigpO1xuICAgIGJsb2NrLm5vbmNlID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKTtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gODApIHJldHVybiBibG9jaztcbiAgICBjb25zdCByZWFkVHJhbnNhY3Rpb24gPSAoKSA9PiB7XG4gICAgICBjb25zdCB0eCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihcbiAgICAgICAgYnVmZmVyUmVhZGVyLmJ1ZmZlci5zbGljZShidWZmZXJSZWFkZXIub2Zmc2V0KSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICk7XG4gICAgICBidWZmZXJSZWFkZXIub2Zmc2V0ICs9IHR4LmJ5dGVMZW5ndGgoKTtcbiAgICAgIHJldHVybiB0eDtcbiAgICB9O1xuICAgIGNvbnN0IG5UcmFuc2FjdGlvbnMgPSBidWZmZXJSZWFkZXIucmVhZFZhckludCgpO1xuICAgIGJsb2NrLnRyYW5zYWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblRyYW5zYWN0aW9uczsgKytpKSB7XG4gICAgICBjb25zdCB0eCA9IHJlYWRUcmFuc2FjdGlvbigpO1xuICAgICAgYmxvY2sudHJhbnNhY3Rpb25zLnB1c2godHgpO1xuICAgIH1cbiAgICBjb25zdCB3aXRuZXNzQ29tbWl0ID0gYmxvY2suZ2V0V2l0bmVzc0NvbW1pdCgpO1xuICAgIC8vIFRoaXMgQmxvY2sgY29udGFpbnMgYSB3aXRuZXNzIGNvbW1pdFxuICAgIGlmICh3aXRuZXNzQ29tbWl0KSBibG9jay53aXRuZXNzQ29tbWl0ID0gd2l0bmVzc0NvbW1pdDtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH1cbiAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgcmV0dXJuIEJsb2NrLmZyb21CdWZmZXIoQnVmZmVyLmZyb20oaGV4LCAnaGV4JykpO1xuICB9XG4gIHN0YXRpYyBjYWxjdWxhdGVUYXJnZXQoYml0cykge1xuICAgIGNvbnN0IGV4cG9uZW50ID0gKChiaXRzICYgMHhmZjAwMDAwMCkgPj4gMjQpIC0gMztcbiAgICBjb25zdCBtYW50aXNzYSA9IGJpdHMgJiAweDAwN2ZmZmZmO1xuICAgIGNvbnN0IHRhcmdldCA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gICAgdGFyZ2V0LndyaXRlVUludEJFKG1hbnRpc3NhLCAyOSAtIGV4cG9uZW50LCAzKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHN0YXRpYyBjYWxjdWxhdGVNZXJrbGVSb290KHRyYW5zYWN0aW9ucywgZm9yV2l0bmVzcykge1xuICAgIHR5cGVmb3JjZShbeyBnZXRIYXNoOiB0eXBlcy5GdW5jdGlvbiB9XSwgdHJhbnNhY3Rpb25zKTtcbiAgICBpZiAodHJhbnNhY3Rpb25zLmxlbmd0aCA9PT0gMCkgdGhyb3cgZXJyb3JNZXJrbGVOb1R4ZXM7XG4gICAgaWYgKGZvcldpdG5lc3MgJiYgIXR4ZXNIYXZlV2l0bmVzc0NvbW1pdCh0cmFuc2FjdGlvbnMpKVxuICAgICAgdGhyb3cgZXJyb3JXaXRuZXNzTm90U2Vnd2l0O1xuICAgIGNvbnN0IGhhc2hlcyA9IHRyYW5zYWN0aW9ucy5tYXAodHJhbnNhY3Rpb24gPT5cbiAgICAgIHRyYW5zYWN0aW9uLmdldEhhc2goZm9yV2l0bmVzcyksXG4gICAgKTtcbiAgICBjb25zdCByb290SGFzaCA9ICgwLCBtZXJrbGVfMS5mYXN0TWVya2xlUm9vdCkoaGFzaGVzLCBiY3J5cHRvLmhhc2gyNTYpO1xuICAgIHJldHVybiBmb3JXaXRuZXNzXG4gICAgICA/IGJjcnlwdG8uaGFzaDI1NihcbiAgICAgICAgICBCdWZmZXIuY29uY2F0KFtyb290SGFzaCwgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzWzBdXSksXG4gICAgICAgIClcbiAgICAgIDogcm9vdEhhc2g7XG4gIH1cbiAgZ2V0V2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoIXR4ZXNIYXZlV2l0bmVzc0NvbW1pdCh0aGlzLnRyYW5zYWN0aW9ucykpIHJldHVybiBudWxsO1xuICAgIC8vIFRoZSBtZXJrbGUgcm9vdCBmb3IgdGhlIHdpdG5lc3MgZGF0YSBpcyBpbiBhbiBPUF9SRVRVUk4gb3V0cHV0LlxuICAgIC8vIFRoZXJlIGlzIG5vIHJ1bGUgZm9yIHRoZSBpbmRleCBvZiB0aGUgb3V0cHV0LCBzbyB1c2UgZmlsdGVyIHRvIGZpbmQgaXQuXG4gICAgLy8gVGhlIHJvb3QgaXMgcHJlcGVuZGVkIHdpdGggMHhhYTIxYTllZCBzbyBjaGVjayBmb3IgMHg2YTI0YWEyMWE5ZWRcbiAgICAvLyBJZiBtdWx0aXBsZSBjb21taXRzIGFyZSBmb3VuZCwgdGhlIG91dHB1dCB3aXRoIGhpZ2hlc3QgaW5kZXggaXMgYXNzdW1lZC5cbiAgICBjb25zdCB3aXRuZXNzQ29tbWl0cyA9IHRoaXMudHJhbnNhY3Rpb25zWzBdLm91dHNcbiAgICAgIC5maWx0ZXIob3V0ID0+XG4gICAgICAgIG91dC5zY3JpcHQuc2xpY2UoMCwgNikuZXF1YWxzKEJ1ZmZlci5mcm9tKCc2YTI0YWEyMWE5ZWQnLCAnaGV4JykpLFxuICAgICAgKVxuICAgICAgLm1hcChvdXQgPT4gb3V0LnNjcmlwdC5zbGljZSg2LCAzOCkpO1xuICAgIGlmICh3aXRuZXNzQ29tbWl0cy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICAgIC8vIFVzZSB0aGUgY29tbWl0IHdpdGggdGhlIGhpZ2hlc3Qgb3V0cHV0IChzaG91bGQgb25seSBiZSBvbmUgdGhvdWdoKVxuICAgIGNvbnN0IHJlc3VsdCA9IHdpdG5lc3NDb21taXRzW3dpdG5lc3NDb21taXRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIEJ1ZmZlciAmJiByZXN1bHQubGVuZ3RoID09PSAzMikpIHJldHVybiBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaGFzV2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLndpdG5lc3NDb21taXQgaW5zdGFuY2VvZiBCdWZmZXIgJiZcbiAgICAgIHRoaXMud2l0bmVzc0NvbW1pdC5sZW5ndGggPT09IDMyXG4gICAgKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuZ2V0V2l0bmVzc0NvbW1pdCgpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzV2l0bmVzcygpIHtcbiAgICByZXR1cm4gYW55VHhIYXNXaXRuZXNzKHRoaXMudHJhbnNhY3Rpb25zKTtcbiAgfVxuICB3ZWlnaHQoKSB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYnl0ZUxlbmd0aChmYWxzZSwgZmFsc2UpO1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5ieXRlTGVuZ3RoKGZhbHNlLCB0cnVlKTtcbiAgICByZXR1cm4gYmFzZSAqIDMgKyB0b3RhbDtcbiAgfVxuICBieXRlTGVuZ3RoKGhlYWRlcnNPbmx5LCBhbGxvd1dpdG5lc3MgPSB0cnVlKSB7XG4gICAgaWYgKGhlYWRlcnNPbmx5IHx8ICF0aGlzLnRyYW5zYWN0aW9ucykgcmV0dXJuIDgwO1xuICAgIHJldHVybiAoXG4gICAgICA4MCArXG4gICAgICBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgodGhpcy50cmFuc2FjdGlvbnMubGVuZ3RoKSArXG4gICAgICB0aGlzLnRyYW5zYWN0aW9ucy5yZWR1Y2UoKGEsIHgpID0+IGEgKyB4LmJ5dGVMZW5ndGgoYWxsb3dXaXRuZXNzKSwgMClcbiAgICApO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgcmV0dXJuIGJjcnlwdG8uaGFzaDI1Nih0aGlzLnRvQnVmZmVyKHRydWUpKTtcbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikodGhpcy5nZXRIYXNoKCkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuICBnZXRVVENEYXRlKCkge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgwKTsgLy8gZXBvY2hcbiAgICBkYXRlLnNldFVUQ1NlY29uZHModGhpcy50aW1lc3RhbXApO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIC8vIFRPRE86IGJ1ZmZlciwgb2Zmc2V0IGNvbXBhdGliaWxpdHlcbiAgdG9CdWZmZXIoaGVhZGVyc09ubHkpIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5ieXRlTGVuZ3RoKGhlYWRlcnNPbmx5KSk7XG4gICAgY29uc3QgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKGJ1ZmZlcik7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlSW50MzIodGhpcy52ZXJzaW9uKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0aGlzLnByZXZIYXNoKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0aGlzLm1lcmtsZVJvb3QpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0aGlzLnRpbWVzdGFtcCk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHRoaXMuYml0cyk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHRoaXMubm9uY2UpO1xuICAgIGlmIChoZWFkZXJzT25seSB8fCAhdGhpcy50cmFuc2FjdGlvbnMpIHJldHVybiBidWZmZXI7XG4gICAgYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kZShcbiAgICAgIHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIGJ1ZmZlcldyaXRlci5vZmZzZXQsXG4gICAgKTtcbiAgICBidWZmZXJXcml0ZXIub2Zmc2V0ICs9IGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGUuYnl0ZXM7XG4gICAgdGhpcy50cmFuc2FjdGlvbnMuZm9yRWFjaCh0eCA9PiB7XG4gICAgICBjb25zdCB0eFNpemUgPSB0eC5ieXRlTGVuZ3RoKCk7IC8vIFRPRE86IGV4dHJhY3QgZnJvbSB0b0J1ZmZlcj9cbiAgICAgIHR4LnRvQnVmZmVyKGJ1ZmZlciwgYnVmZmVyV3JpdGVyLm9mZnNldCk7XG4gICAgICBidWZmZXJXcml0ZXIub2Zmc2V0ICs9IHR4U2l6ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIHRvSGV4KGhlYWRlcnNPbmx5KSB7XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIoaGVhZGVyc09ubHkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuICBjaGVja1R4Um9vdHMoKSB7XG4gICAgLy8gSWYgdGhlIEJsb2NrIGhhcyBzZWd3aXQgdHJhbnNhY3Rpb25zIGJ1dCBubyB3aXRuZXNzIGNvbW1pdCxcbiAgICAvLyB0aGVyZSdzIG5vIHdheSBpdCBjYW4gYmUgdmFsaWQsIHNvIGZhaWwgdGhlIGNoZWNrLlxuICAgIGNvbnN0IGhhc1dpdG5lc3NDb21taXQgPSB0aGlzLmhhc1dpdG5lc3NDb21taXQoKTtcbiAgICBpZiAoIWhhc1dpdG5lc3NDb21taXQgJiYgdGhpcy5oYXNXaXRuZXNzKCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fX2NoZWNrTWVya2xlUm9vdCgpICYmXG4gICAgICAoaGFzV2l0bmVzc0NvbW1pdCA/IHRoaXMuX19jaGVja1dpdG5lc3NDb21taXQoKSA6IHRydWUpXG4gICAgKTtcbiAgfVxuICBjaGVja1Byb29mT2ZXb3JrKCkge1xuICAgIGNvbnN0IGhhc2ggPSAoMCwgYnVmZmVydXRpbHNfMS5yZXZlcnNlQnVmZmVyKSh0aGlzLmdldEhhc2goKSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gQmxvY2suY2FsY3VsYXRlVGFyZ2V0KHRoaXMuYml0cyk7XG4gICAgcmV0dXJuIGhhc2guY29tcGFyZSh0YXJnZXQpIDw9IDA7XG4gIH1cbiAgX19jaGVja01lcmtsZVJvb3QoKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9ucykgdGhyb3cgZXJyb3JNZXJrbGVOb1R4ZXM7XG4gICAgY29uc3QgYWN0dWFsTWVya2xlUm9vdCA9IEJsb2NrLmNhbGN1bGF0ZU1lcmtsZVJvb3QodGhpcy50cmFuc2FjdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLm1lcmtsZVJvb3QuY29tcGFyZShhY3R1YWxNZXJrbGVSb290KSA9PT0gMDtcbiAgfVxuICBfX2NoZWNrV2l0bmVzc0NvbW1pdCgpIHtcbiAgICBpZiAoIXRoaXMudHJhbnNhY3Rpb25zKSB0aHJvdyBlcnJvck1lcmtsZU5vVHhlcztcbiAgICBpZiAoIXRoaXMuaGFzV2l0bmVzc0NvbW1pdCgpKSB0aHJvdyBlcnJvcldpdG5lc3NOb3RTZWd3aXQ7XG4gICAgY29uc3QgYWN0dWFsV2l0bmVzc0NvbW1pdCA9IEJsb2NrLmNhbGN1bGF0ZU1lcmtsZVJvb3QoXG4gICAgICB0aGlzLnRyYW5zYWN0aW9ucyxcbiAgICAgIHRydWUsXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy53aXRuZXNzQ29tbWl0LmNvbXBhcmUoYWN0dWFsV2l0bmVzc0NvbW1pdCkgPT09IDA7XG4gIH1cbn1cbmV4cG9ydHMuQmxvY2sgPSBCbG9jaztcbmZ1bmN0aW9uIHR4ZXNIYXZlV2l0bmVzc0NvbW1pdCh0cmFuc2FjdGlvbnMpIHtcbiAgcmV0dXJuIChcbiAgICB0cmFuc2FjdGlvbnMgaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgIHRyYW5zYWN0aW9uc1swXSAmJlxuICAgIHRyYW5zYWN0aW9uc1swXS5pbnMgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zWzBdICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zWzBdLndpdG5lc3MubGVuZ3RoID4gMFxuICApO1xufVxuZnVuY3Rpb24gYW55VHhIYXNXaXRuZXNzKHRyYW5zYWN0aW9ucykge1xuICByZXR1cm4gKFxuICAgIHRyYW5zYWN0aW9ucyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgdHJhbnNhY3Rpb25zLnNvbWUoXG4gICAgICB0eCA9PlxuICAgICAgICB0eXBlb2YgdHggPT09ICdvYmplY3QnICYmXG4gICAgICAgIHR4LmlucyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgICAgIHR4Lmlucy5zb21lKFxuICAgICAgICAgIGlucHV0ID0+XG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICAgICAgICAgIGlucHV0LndpdG5lc3MubGVuZ3RoID4gMCxcbiAgICAgICAgKSxcbiAgICApXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/block.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BufferReader =\n  exports.BufferWriter =\n  exports.cloneBuffer =\n  exports.reverseBuffer =\n  exports.writeUInt64LE =\n  exports.readUInt64LE =\n  exports.varuint =\n    void 0;\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nconst varuint = __webpack_require__(/*! varuint-bitcoin */ \"(ssr)/./node_modules/.pnpm/varuint-bitcoin@1.1.2/node_modules/varuint-bitcoin/index.js\");\nexports.varuint = varuint;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\n/**\n * Writes a 64-bit unsigned integer in little-endian format to the specified buffer at the given offset.\n *\n * @param buffer - The buffer to write the value to.\n * @param value - The 64-bit unsigned integer value to write.\n * @param offset - The offset in the buffer where the value should be written.\n * @returns The new offset after writing the value.\n */\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n/**\n * Reverses the order of bytes in a buffer.\n * @param buffer - The buffer to reverse.\n * @returns A new buffer with the bytes reversed.\n */\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  static withCapacity(size) {\n    return new BufferWriter(Buffer.alloc(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYnVmZmVydXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLEVBQUUsb0JBQW9CO0FBQ3RCLEVBQUUsbUJBQW1CO0FBQ3JCLEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUUsb0JBQW9CO0FBQ3RCLEVBQUUsZUFBZTtBQUNqQjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyx1R0FBUztBQUMvQixRQUFRLFlBQVk7QUFDcEIsZ0JBQWdCLG1CQUFPLENBQUMsK0dBQWlCO0FBQ3pDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQixXQUFXLFlBQVk7QUFDN0U7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9idWZmZXJ1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdWZmZXJSZWFkZXIgPVxuICBleHBvcnRzLkJ1ZmZlcldyaXRlciA9XG4gIGV4cG9ydHMuY2xvbmVCdWZmZXIgPVxuICBleHBvcnRzLnJldmVyc2VCdWZmZXIgPVxuICBleHBvcnRzLndyaXRlVUludDY0TEUgPVxuICBleHBvcnRzLnJlYWRVSW50NjRMRSA9XG4gIGV4cG9ydHMudmFydWludCA9XG4gICAgdm9pZCAwO1xuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzJyk7XG5jb25zdCB7IHR5cGVmb3JjZSB9ID0gdHlwZXM7XG5jb25zdCB2YXJ1aW50ID0gcmVxdWlyZSgndmFydWludC1iaXRjb2luJyk7XG5leHBvcnRzLnZhcnVpbnQgPSB2YXJ1aW50O1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDExMjdcbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuICBpZiAodmFsdWUgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcignc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcbiAgaWYgKHZhbHVlID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ1JhbmdlRXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZScpO1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cbmZ1bmN0aW9uIHJlYWRVSW50NjRMRShidWZmZXIsIG9mZnNldCkge1xuICBjb25zdCBhID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICBsZXQgYiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gIGIgKj0gMHgxMDAwMDAwMDA7XG4gIHZlcmlmdWludChiICsgYSwgMHgwMDFmZmZmZmZmZmZmZmZmKTtcbiAgcmV0dXJuIGIgKyBhO1xufVxuZXhwb3J0cy5yZWFkVUludDY0TEUgPSByZWFkVUludDY0TEU7XG4vKipcbiAqIFdyaXRlcyBhIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IHRvIHRoZSBzcGVjaWZpZWQgYnVmZmVyIGF0IHRoZSBnaXZlbiBvZmZzZXQuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gd3JpdGUgdGhlIHZhbHVlIHRvLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlIHRvIHdyaXRlLlxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgdmFsdWUgc2hvdWxkIGJlIHdyaXR0ZW4uXG4gKiBAcmV0dXJucyBUaGUgbmV3IG9mZnNldCBhZnRlciB3cml0aW5nIHRoZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gd3JpdGVVSW50NjRMRShidWZmZXIsIHZhbHVlLCBvZmZzZXQpIHtcbiAgdmVyaWZ1aW50KHZhbHVlLCAweDAwMWZmZmZmZmZmZmZmZmYpO1xuICBidWZmZXIud3JpdGVJbnQzMkxFKHZhbHVlICYgLTEsIG9mZnNldCk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkxFKE1hdGguZmxvb3IodmFsdWUgLyAweDEwMDAwMDAwMCksIG9mZnNldCArIDQpO1xuICByZXR1cm4gb2Zmc2V0ICsgODtcbn1cbmV4cG9ydHMud3JpdGVVSW50NjRMRSA9IHdyaXRlVUludDY0TEU7XG4vKipcbiAqIFJldmVyc2VzIHRoZSBvcmRlciBvZiBieXRlcyBpbiBhIGJ1ZmZlci5cbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIHJldmVyc2UuXG4gKiBAcmV0dXJucyBBIG5ldyBidWZmZXIgd2l0aCB0aGUgYnl0ZXMgcmV2ZXJzZWQuXG4gKi9cbmZ1bmN0aW9uIHJldmVyc2VCdWZmZXIoYnVmZmVyKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoIDwgMSkgcmV0dXJuIGJ1ZmZlcjtcbiAgbGV0IGogPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgbGV0IHRtcCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHRtcCA9IGJ1ZmZlcltpXTtcbiAgICBidWZmZXJbaV0gPSBidWZmZXJbal07XG4gICAgYnVmZmVyW2pdID0gdG1wO1xuICAgIGotLTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5yZXZlcnNlQnVmZmVyID0gcmV2ZXJzZUJ1ZmZlcjtcbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlcikge1xuICBjb25zdCBjbG9uZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZmZXIubGVuZ3RoKTtcbiAgYnVmZmVyLmNvcHkoY2xvbmUpO1xuICByZXR1cm4gY2xvbmU7XG59XG5leHBvcnRzLmNsb25lQnVmZmVyID0gY2xvbmVCdWZmZXI7XG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3Igc2VyaWFsaXphdGlvbiBvZiBiaXRjb2luIGRhdGEgdHlwZXMgaW50byBhIHByZS1hbGxvY2F0ZWQgYnVmZmVyLlxuICovXG5jbGFzcyBCdWZmZXJXcml0ZXIge1xuICBzdGF0aWMgd2l0aENhcGFjaXR5KHNpemUpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcihCdWZmZXIuYWxsb2Moc2l6ZSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5CdWZmZXIsIHR5cGVzLlVJbnQzMiksIFtidWZmZXIsIG9mZnNldF0pO1xuICB9XG4gIHdyaXRlVUludDgoaSkge1xuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5idWZmZXIud3JpdGVVSW50OChpLCB0aGlzLm9mZnNldCk7XG4gIH1cbiAgd3JpdGVJbnQzMihpKSB7XG4gICAgdGhpcy5vZmZzZXQgPSB0aGlzLmJ1ZmZlci53cml0ZUludDMyTEUoaSwgdGhpcy5vZmZzZXQpO1xuICB9XG4gIHdyaXRlVUludDMyKGkpIHtcbiAgICB0aGlzLm9mZnNldCA9IHRoaXMuYnVmZmVyLndyaXRlVUludDMyTEUoaSwgdGhpcy5vZmZzZXQpO1xuICB9XG4gIHdyaXRlVUludDY0KGkpIHtcbiAgICB0aGlzLm9mZnNldCA9IHdyaXRlVUludDY0TEUodGhpcy5idWZmZXIsIGksIHRoaXMub2Zmc2V0KTtcbiAgfVxuICB3cml0ZVZhckludChpKSB7XG4gICAgdmFydWludC5lbmNvZGUoaSwgdGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0KTtcbiAgICB0aGlzLm9mZnNldCArPSB2YXJ1aW50LmVuY29kZS5ieXRlcztcbiAgfVxuICB3cml0ZVNsaWNlKHNsaWNlKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8IHRoaXMub2Zmc2V0ICsgc2xpY2UubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB3cml0ZSBzbGljZSBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIHRoaXMub2Zmc2V0ICs9IHNsaWNlLmNvcHkodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0KTtcbiAgfVxuICB3cml0ZVZhclNsaWNlKHNsaWNlKSB7XG4gICAgdGhpcy53cml0ZVZhckludChzbGljZS5sZW5ndGgpO1xuICAgIHRoaXMud3JpdGVTbGljZShzbGljZSk7XG4gIH1cbiAgd3JpdGVWZWN0b3IodmVjdG9yKSB7XG4gICAgdGhpcy53cml0ZVZhckludCh2ZWN0b3IubGVuZ3RoKTtcbiAgICB2ZWN0b3IuZm9yRWFjaChidWYgPT4gdGhpcy53cml0ZVZhclNsaWNlKGJ1ZikpO1xuICB9XG4gIGVuZCgpIHtcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID09PSB0aGlzLm9mZnNldCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJ1ZmZlciBzaXplICR7dGhpcy5idWZmZXIubGVuZ3RofSwgb2Zmc2V0ICR7dGhpcy5vZmZzZXR9YCk7XG4gIH1cbn1cbmV4cG9ydHMuQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIHJlYWRpbmcgb2YgYml0Y29pbiBkYXRhIHR5cGVzIGZyb20gYSBidWZmZXIuXG4gKi9cbmNsYXNzIEJ1ZmZlclJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKGJ1ZmZlciwgb2Zmc2V0ID0gMCkge1xuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5CdWZmZXIsIHR5cGVzLlVJbnQzMiksIFtidWZmZXIsIG9mZnNldF0pO1xuICB9XG4gIHJlYWRVSW50OCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDgodGhpcy5vZmZzZXQpO1xuICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZWFkSW50MzIoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWZmZXIucmVhZEludDMyTEUodGhpcy5vZmZzZXQpO1xuICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZWFkVUludDMyKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRVSW50MzJMRSh0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlYWRVSW50NjQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcmVhZFVJbnQ2NExFKHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5vZmZzZXQgKz0gODtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlYWRWYXJJbnQoKSB7XG4gICAgY29uc3QgdmkgPSB2YXJ1aW50LmRlY29kZSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQpO1xuICAgIHRoaXMub2Zmc2V0ICs9IHZhcnVpbnQuZGVjb2RlLmJ5dGVzO1xuICAgIHJldHVybiB2aTtcbiAgfVxuICByZWFkU2xpY2Uobikge1xuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPCB0aGlzLm9mZnNldCArIG4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgc2xpY2Ugb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBuKTtcbiAgICB0aGlzLm9mZnNldCArPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVhZFZhclNsaWNlKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRTbGljZSh0aGlzLnJlYWRWYXJJbnQoKSk7XG4gIH1cbiAgcmVhZFZlY3RvcigpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMucmVhZFZhckludCgpO1xuICAgIGNvbnN0IHZlY3RvciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykgdmVjdG9yLnB1c2godGhpcy5yZWFkVmFyU2xpY2UoKSk7XG4gICAgcmV0dXJuIHZlY3RvcjtcbiAgfVxufVxuZXhwb3J0cy5CdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.taggedHash =\n  exports.TAGGED_HASH_PREFIXES =\n  exports.TAGS =\n  exports.hash256 =\n  exports.hash160 =\n  exports.sha256 =\n  exports.sha1 =\n  exports.ripemd160 =\n    void 0;\n/**\n * A module for hashing functions.\n * include ripemd160ã€sha1ã€sha256ã€hash160ã€hash256ã€taggedHash\n *\n * @packageDocumentation\n */\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/ripemd160.js\");\nconst sha1_1 = __webpack_require__(/*! @noble/hashes/sha1 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha1.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/sha256.js\");\nfunction ripemd160(buffer) {\n  return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return Buffer.from(\n    (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return Buffer.from(\n    (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash256 = hash256;\nexports.TAGS = [\n  'BIP0340/challenge',\n  'BIP0340/aux',\n  'BIP0340/nonce',\n  'TapLeaf',\n  'TapBranch',\n  'TapSighash',\n  'TapTweak',\n  'KeyAgg list',\n  'KeyAgg coefficient',\n];\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\n/**\n * Defines the tagged hash prefixes used in the crypto module.\n */\nexports.TAGGED_HASH_PREFIXES = {\n  'BIP0340/challenge': Buffer.from([\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n  ]),\n  'BIP0340/aux': Buffer.from([\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n  ]),\n  'BIP0340/nonce': Buffer.from([\n    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,\n    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,\n    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,\n    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,\n  ]),\n  TapLeaf: Buffer.from([\n    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,\n    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,\n    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,\n    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,\n  ]),\n  TapBranch: Buffer.from([\n    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,\n    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,\n    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,\n    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,\n  ]),\n  TapSighash: Buffer.from([\n    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,\n    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,\n    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,\n    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,\n  ]),\n  TapTweak: Buffer.from([\n    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,\n    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,\n    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,\n    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,\n  ]),\n  'KeyAgg list': Buffer.from([\n    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,\n    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,\n    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,\n    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,\n  ]),\n  'KeyAgg coefficient': Buffer.from([\n    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,\n    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,\n    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,\n    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,\n  ]),\n};\nfunction taggedHash(prefix, data) {\n  return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));\n}\nexports.taggedHash = taggedHash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixFQUFFLDRCQUE0QjtBQUM5QixFQUFFLFlBQVk7QUFDZCxFQUFFLGVBQWU7QUFDakIsRUFBRSxlQUFlO0FBQ2pCLEVBQUUsY0FBYztBQUNoQixFQUFFLFlBQVk7QUFDZCxFQUFFLGlCQUFpQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLHVIQUF5QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsNkdBQW9CO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLGlIQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9jcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGFnZ2VkSGFzaCA9XG4gIGV4cG9ydHMuVEFHR0VEX0hBU0hfUFJFRklYRVMgPVxuICBleHBvcnRzLlRBR1MgPVxuICBleHBvcnRzLmhhc2gyNTYgPVxuICBleHBvcnRzLmhhc2gxNjAgPVxuICBleHBvcnRzLnNoYTI1NiA9XG4gIGV4cG9ydHMuc2hhMSA9XG4gIGV4cG9ydHMucmlwZW1kMTYwID1cbiAgICB2b2lkIDA7XG4vKipcbiAqIEEgbW9kdWxlIGZvciBoYXNoaW5nIGZ1bmN0aW9ucy5cbiAqIGluY2x1ZGUgcmlwZW1kMTYw44CBc2hhMeOAgXNoYTI1NuOAgWhhc2gxNjDjgIFoYXNoMjU244CBdGFnZ2VkSGFzaFxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5jb25zdCByaXBlbWQxNjBfMSA9IHJlcXVpcmUoJ0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwJyk7XG5jb25zdCBzaGExXzEgPSByZXF1aXJlKCdAbm9ibGUvaGFzaGVzL3NoYTEnKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZSgnQG5vYmxlL2hhc2hlcy9zaGEyNTYnKTtcbmZ1bmN0aW9uIHJpcGVtZDE2MChidWZmZXIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpKSk7XG59XG5leHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcbmZ1bmN0aW9uIHNoYTEoYnVmZmVyKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2hhMV8xLnNoYTEpKFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpKSk7XG59XG5leHBvcnRzLnNoYTEgPSBzaGExO1xuZnVuY3Rpb24gc2hhMjU2KGJ1ZmZlcikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHNoYTI1Nl8xLnNoYTI1NikoVWludDhBcnJheS5mcm9tKGJ1ZmZlcikpKTtcbn1cbmV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuZnVuY3Rpb24gaGFzaDE2MChidWZmZXIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKCgwLCBzaGEyNTZfMS5zaGEyNTYpKFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpKSksXG4gICk7XG59XG5leHBvcnRzLmhhc2gxNjAgPSBoYXNoMTYwO1xuZnVuY3Rpb24gaGFzaDI1NihidWZmZXIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCBzaGEyNTZfMS5zaGEyNTYpKFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpKSksXG4gICk7XG59XG5leHBvcnRzLmhhc2gyNTYgPSBoYXNoMjU2O1xuZXhwb3J0cy5UQUdTID0gW1xuICAnQklQMDM0MC9jaGFsbGVuZ2UnLFxuICAnQklQMDM0MC9hdXgnLFxuICAnQklQMDM0MC9ub25jZScsXG4gICdUYXBMZWFmJyxcbiAgJ1RhcEJyYW5jaCcsXG4gICdUYXBTaWdoYXNoJyxcbiAgJ1RhcFR3ZWFrJyxcbiAgJ0tleUFnZyBsaXN0JyxcbiAgJ0tleUFnZyBjb2VmZmljaWVudCcsXG5dO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuLyoqXG4gKiBEZWZpbmVzIHRoZSB0YWdnZWQgaGFzaCBwcmVmaXhlcyB1c2VkIGluIHRoZSBjcnlwdG8gbW9kdWxlLlxuICovXG5leHBvcnRzLlRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge1xuICAnQklQMDM0MC9jaGFsbGVuZ2UnOiBCdWZmZXIuZnJvbShbXG4gICAgMTIzLCAxODEsIDQ1LCAxMjIsIDE1OSwgMjM5LCA4OCwgNTAsIDYyLCAxNzcsIDE5MSwgMTIyLCA2NCwgMTI1LCAxNzksIDEzMCxcbiAgICAyMTAsIDI0MywgMjQyLCAyMTYsIDI3LCAxNzcsIDM0LCA3OSwgNzMsIDI1NCwgODEsIDE0MywgMTA5LCA3MiwgMjExLCAxMjQsXG4gICAgMTIzLCAxODEsIDQ1LCAxMjIsIDE1OSwgMjM5LCA4OCwgNTAsIDYyLCAxNzcsIDE5MSwgMTIyLCA2NCwgMTI1LCAxNzksIDEzMCxcbiAgICAyMTAsIDI0MywgMjQyLCAyMTYsIDI3LCAxNzcsIDM0LCA3OSwgNzMsIDI1NCwgODEsIDE0MywgMTA5LCA3MiwgMjExLCAxMjQsXG4gIF0pLFxuICAnQklQMDM0MC9hdXgnOiBCdWZmZXIuZnJvbShbXG4gICAgMjQxLCAyMzksIDc4LCA5NCwgMTkyLCA5OSwgMjAyLCAyMTgsIDEwOSwgMTQ4LCAyMDIsIDI1MCwgMTU3LCAxNTIsIDEyNiwgMTYwLFxuICAgIDEwNSwgMzgsIDg4LCA1NywgMjM2LCAxOTMsIDMxLCAxNTEsIDQ1LCAxMTksIDE2NSwgNDYsIDIxNiwgMTkzLCAyMDQsIDE0NCxcbiAgICAyNDEsIDIzOSwgNzgsIDk0LCAxOTIsIDk5LCAyMDIsIDIxOCwgMTA5LCAxNDgsIDIwMiwgMjUwLCAxNTcsIDE1MiwgMTI2LCAxNjAsXG4gICAgMTA1LCAzOCwgODgsIDU3LCAyMzYsIDE5MywgMzEsIDE1MSwgNDUsIDExOSwgMTY1LCA0NiwgMjE2LCAxOTMsIDIwNCwgMTQ0LFxuICBdKSxcbiAgJ0JJUDAzNDAvbm9uY2UnOiBCdWZmZXIuZnJvbShbXG4gICAgNywgNzMsIDExOSwgNTIsIDE2NywgMTU1LCAyMDMsIDUzLCA5MSwgMTU1LCAxNDAsIDEyNSwgMywgNzksIDE4LCAyOCwgMjQ0LFxuICAgIDUyLCAyMTUsIDYyLCAyNDcsIDQ1LCAyMTgsIDI1LCAxMzUsIDAsIDk3LCAyNTEsIDgyLCAxOTEsIDIzNSwgNDcsIDcsIDczLFxuICAgIDExOSwgNTIsIDE2NywgMTU1LCAyMDMsIDUzLCA5MSwgMTU1LCAxNDAsIDEyNSwgMywgNzksIDE4LCAyOCwgMjQ0LCA1MiwgMjE1LFxuICAgIDYyLCAyNDcsIDQ1LCAyMTgsIDI1LCAxMzUsIDAsIDk3LCAyNTEsIDgyLCAxOTEsIDIzNSwgNDcsXG4gIF0pLFxuICBUYXBMZWFmOiBCdWZmZXIuZnJvbShbXG4gICAgMTc0LCAyMzQsIDE0MywgMjIwLCA2NiwgOCwgMTUyLCA0OSwgNSwgMTE1LCA3NSwgODgsIDgsIDI5LCAzMCwgMzgsIDU2LCAyMTEsXG4gICAgOTUsIDI4LCAxODEsIDY0LCA4LCAyMTIsIDIxMSwgODcsIDIwMiwgMywgMTkwLCAxMjAsIDIzMywgMjM4LCAxNzQsIDIzNCwgMTQzLFxuICAgIDIyMCwgNjYsIDgsIDE1MiwgNDksIDUsIDExNSwgNzUsIDg4LCA4LCAyOSwgMzAsIDM4LCA1NiwgMjExLCA5NSwgMjgsIDE4MSxcbiAgICA2NCwgOCwgMjEyLCAyMTEsIDg3LCAyMDIsIDMsIDE5MCwgMTIwLCAyMzMsIDIzOCxcbiAgXSksXG4gIFRhcEJyYW5jaDogQnVmZmVyLmZyb20oW1xuICAgIDI1LCA2NSwgMTYxLCAyNDIsIDIyOSwgMTEwLCAxODUsIDk1LCAxNjIsIDE2OSwgMjQxLCAxNDgsIDE5MCwgOTIsIDEsIDI0NyxcbiAgICAzMywgMTExLCA1MSwgMjM3LCAxMzAsIDE3NiwgMTQ1LCA3MCwgNTIsIDE0NCwgMjA4LCA5MSwgMjQ1LCAyMiwgMTYwLCAyMSwgMjUsXG4gICAgNjUsIDE2MSwgMjQyLCAyMjksIDExMCwgMTg1LCA5NSwgMTYyLCAxNjksIDI0MSwgMTQ4LCAxOTAsIDkyLCAxLCAyNDcsIDMzLFxuICAgIDExMSwgNTEsIDIzNywgMTMwLCAxNzYsIDE0NSwgNzAsIDUyLCAxNDQsIDIwOCwgOTEsIDI0NSwgMjIsIDE2MCwgMjEsXG4gIF0pLFxuICBUYXBTaWdoYXNoOiBCdWZmZXIuZnJvbShbXG4gICAgMjQ0LCAxMCwgNzIsIDIyMywgNzUsIDQyLCAxMTIsIDIwMCwgMTgwLCAxNDYsIDc1LCAyNDIsIDEwMSwgNzAsIDk3LCAyMzcsIDYxLFxuICAgIDE0OSwgMjUzLCAxMDIsIDE2MywgMTksIDIzNSwgMTM1LCAzNSwgMTE3LCAxNTEsIDE5OCwgNDAsIDIyOCwgMTYwLCA0OSwgMjQ0LFxuICAgIDEwLCA3MiwgMjIzLCA3NSwgNDIsIDExMiwgMjAwLCAxODAsIDE0NiwgNzUsIDI0MiwgMTAxLCA3MCwgOTcsIDIzNywgNjEsIDE0OSxcbiAgICAyNTMsIDEwMiwgMTYzLCAxOSwgMjM1LCAxMzUsIDM1LCAxMTcsIDE1MSwgMTk4LCA0MCwgMjI4LCAxNjAsIDQ5LFxuICBdKSxcbiAgVGFwVHdlYWs6IEJ1ZmZlci5mcm9tKFtcbiAgICAyMzIsIDE1LCAyMjUsIDk5LCAxNTYsIDE1NiwgMTYwLCA4MCwgMjI3LCAxNzUsIDI3LCA1NywgMTkzLCA2NywgMTk4LCA2MiwgNjYsXG4gICAgMTU2LCAxODgsIDIzNSwgMjEsIDIxNywgNjQsIDI1MSwgMTgxLCAxOTcsIDE2MSwgMjQ0LCAxNzUsIDg3LCAxOTcsIDIzMywgMjMyLFxuICAgIDE1LCAyMjUsIDk5LCAxNTYsIDE1NiwgMTYwLCA4MCwgMjI3LCAxNzUsIDI3LCA1NywgMTkzLCA2NywgMTk4LCA2MiwgNjYsIDE1NixcbiAgICAxODgsIDIzNSwgMjEsIDIxNywgNjQsIDI1MSwgMTgxLCAxOTcsIDE2MSwgMjQ0LCAxNzUsIDg3LCAxOTcsIDIzMyxcbiAgXSksXG4gICdLZXlBZ2cgbGlzdCc6IEJ1ZmZlci5mcm9tKFtcbiAgICA3MiwgMjgsIDE1MSwgMjgsIDYwLCAxMSwgNzAsIDIxNSwgMjQwLCAxNzgsIDExNywgMTc0LCA4OSwgMTQxLCA3OCwgNDQsIDEyNixcbiAgICAyMTUsIDQ5LCAxNTYsIDg5LCA3NCwgOTIsIDExMCwgMTk5LCAxNTgsIDE2MCwgMjEyLCAxNTMsIDIsIDE0OCwgMjQwLCA3MiwgMjgsXG4gICAgMTUxLCAyOCwgNjAsIDExLCA3MCwgMjE1LCAyNDAsIDE3OCwgMTE3LCAxNzQsIDg5LCAxNDEsIDc4LCA0NCwgMTI2LCAyMTUsIDQ5LFxuICAgIDE1NiwgODksIDc0LCA5MiwgMTEwLCAxOTksIDE1OCwgMTYwLCAyMTIsIDE1MywgMiwgMTQ4LCAyNDAsXG4gIF0pLFxuICAnS2V5QWdnIGNvZWZmaWNpZW50JzogQnVmZmVyLmZyb20oW1xuICAgIDE5MSwgMjAxLCA0LCAzLCA3NywgMjgsIDEzNiwgMjMyLCAyMDAsIDE0LCAzNCwgMjI5LCA2MSwgMzYsIDg2LCAxMDksIDEwMCxcbiAgICAxMzAsIDc4LCAyMTQsIDY2LCAxMTQsIDEyOSwgMTkyLCAxNDUsIDAsIDI0OSwgNzcsIDIwNSwgODIsIDIwMSwgMTI5LCAxOTEsXG4gICAgMjAxLCA0LCAzLCA3NywgMjgsIDEzNiwgMjMyLCAyMDAsIDE0LCAzNCwgMjI5LCA2MSwgMzYsIDg2LCAxMDksIDEwMCwgMTMwLFxuICAgIDc4LCAyMTQsIDY2LCAxMTQsIDEyOSwgMTkyLCAxNDUsIDAsIDI0OSwgNzcsIDIwNSwgODIsIDIwMSwgMTI5LFxuICBdKSxcbn07XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHByZWZpeCwgZGF0YSkge1xuICByZXR1cm4gc2hhMjU2KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuVEFHR0VEX0hBU0hfUFJFRklYRVNbcHJlZml4XSwgZGF0YV0pKTtcbn1cbmV4cG9ydHMudGFnZ2VkSGFzaCA9IHRhZ2dlZEhhc2g7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ecc_lib.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ecc_lib.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEccLib = exports.initEccLib = void 0;\nconst _ECCLIB_CACHE = {};\n/**\n * Initializes the ECC library with the provided instance.\n * If `eccLib` is `undefined`, the library will be cleared.\n * If `eccLib` is a new instance, it will be verified before setting it as the active library.\n *\n * @param eccLib The instance of the ECC library to initialize.\n * @param opts Extra initialization options. Use {DANGER_DO_NOT_VERIFY_ECCLIB:true} if ecc verification should not be executed. Not recommended!\n */\nfunction initEccLib(eccLib, opts) {\n  if (!eccLib) {\n    // allow clearing the library\n    _ECCLIB_CACHE.eccLib = eccLib;\n  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {\n    if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)\n      // new instance, verify it\n      verifyEcc(eccLib);\n    _ECCLIB_CACHE.eccLib = eccLib;\n  }\n}\nexports.initEccLib = initEccLib;\n/**\n * Retrieves the ECC Library instance.\n * Throws an error if the ECC Library is not provided.\n * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.\n * @returns The ECC Library instance.\n * @throws Error if the ECC Library is not provided.\n */\nfunction getEccLib() {\n  if (!_ECCLIB_CACHE.eccLib)\n    throw new Error(\n      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',\n    );\n  return _ECCLIB_CACHE.eccLib;\n}\nexports.getEccLib = getEccLib;\nconst h = hex => Buffer.from(hex, 'hex');\n/**\n * Verifies the ECC functionality.\n *\n * @param ecc - The TinySecp256k1Interface object.\n */\nfunction verifyEcc(ecc) {\n  assert(typeof ecc.isXOnlyPoint === 'function');\n  assert(\n    ecc.isXOnlyPoint(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    ),\n  );\n  assert(typeof ecc.xOnlyPointAddTweak === 'function');\n  tweakAddVectors.forEach(t => {\n    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));\n    if (t.result === null) {\n      assert(r === null);\n    } else {\n      assert(r !== null);\n      assert(r.parity === t.parity);\n      assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));\n    }\n  });\n}\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\nconst tweakAddVectors = [\n  {\n    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',\n    parity: -1,\n    result: null,\n  },\n  {\n    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',\n    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',\n    parity: 1,\n    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',\n  },\n  {\n    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',\n    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',\n    parity: 0,\n    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',\n  },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvZWNjX2xpYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0NBQWtDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyIvVXNlcnMvYnRjL21pZGwteC1iaXRjb2luLXN1bW1pdC1oYWNrYXRob24tMjAyNS91dHhvLXBzYnQtZGVtby9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvZWNjX2xpYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFY2NMaWIgPSBleHBvcnRzLmluaXRFY2NMaWIgPSB2b2lkIDA7XG5jb25zdCBfRUNDTElCX0NBQ0hFID0ge307XG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBFQ0MgbGlicmFyeSB3aXRoIHRoZSBwcm92aWRlZCBpbnN0YW5jZS5cbiAqIElmIGBlY2NMaWJgIGlzIGB1bmRlZmluZWRgLCB0aGUgbGlicmFyeSB3aWxsIGJlIGNsZWFyZWQuXG4gKiBJZiBgZWNjTGliYCBpcyBhIG5ldyBpbnN0YW5jZSwgaXQgd2lsbCBiZSB2ZXJpZmllZCBiZWZvcmUgc2V0dGluZyBpdCBhcyB0aGUgYWN0aXZlIGxpYnJhcnkuXG4gKlxuICogQHBhcmFtIGVjY0xpYiBUaGUgaW5zdGFuY2Ugb2YgdGhlIEVDQyBsaWJyYXJ5IHRvIGluaXRpYWxpemUuXG4gKiBAcGFyYW0gb3B0cyBFeHRyYSBpbml0aWFsaXphdGlvbiBvcHRpb25zLiBVc2Uge0RBTkdFUl9ET19OT1RfVkVSSUZZX0VDQ0xJQjp0cnVlfSBpZiBlY2MgdmVyaWZpY2F0aW9uIHNob3VsZCBub3QgYmUgZXhlY3V0ZWQuIE5vdCByZWNvbW1lbmRlZCFcbiAqL1xuZnVuY3Rpb24gaW5pdEVjY0xpYihlY2NMaWIsIG9wdHMpIHtcbiAgaWYgKCFlY2NMaWIpIHtcbiAgICAvLyBhbGxvdyBjbGVhcmluZyB0aGUgbGlicmFyeVxuICAgIF9FQ0NMSUJfQ0FDSEUuZWNjTGliID0gZWNjTGliO1xuICB9IGVsc2UgaWYgKGVjY0xpYiAhPT0gX0VDQ0xJQl9DQUNIRS5lY2NMaWIpIHtcbiAgICBpZiAoIW9wdHM/LkRBTkdFUl9ET19OT1RfVkVSSUZZX0VDQ0xJQilcbiAgICAgIC8vIG5ldyBpbnN0YW5jZSwgdmVyaWZ5IGl0XG4gICAgICB2ZXJpZnlFY2MoZWNjTGliKTtcbiAgICBfRUNDTElCX0NBQ0hFLmVjY0xpYiA9IGVjY0xpYjtcbiAgfVxufVxuZXhwb3J0cy5pbml0RWNjTGliID0gaW5pdEVjY0xpYjtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBFQ0MgTGlicmFyeSBpbnN0YW5jZS5cbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgRUNDIExpYnJhcnkgaXMgbm90IHByb3ZpZGVkLlxuICogWW91IG11c3QgY2FsbCBpbml0RWNjTGliKCkgd2l0aCBhIHZhbGlkIFRpbnlTZWNwMjU2azFJbnRlcmZhY2UgaW5zdGFuY2UgYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBFQ0MgTGlicmFyeSBpbnN0YW5jZS5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIEVDQyBMaWJyYXJ5IGlzIG5vdCBwcm92aWRlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RWNjTGliKCkge1xuICBpZiAoIV9FQ0NMSUJfQ0FDSEUuZWNjTGliKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdObyBFQ0MgTGlicmFyeSBwcm92aWRlZC4gWW91IG11c3QgY2FsbCBpbml0RWNjTGliKCkgd2l0aCBhIHZhbGlkIFRpbnlTZWNwMjU2azFJbnRlcmZhY2UgaW5zdGFuY2UnLFxuICAgICk7XG4gIHJldHVybiBfRUNDTElCX0NBQ0hFLmVjY0xpYjtcbn1cbmV4cG9ydHMuZ2V0RWNjTGliID0gZ2V0RWNjTGliO1xuY29uc3QgaCA9IGhleCA9PiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbi8qKlxuICogVmVyaWZpZXMgdGhlIEVDQyBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIEBwYXJhbSBlY2MgLSBUaGUgVGlueVNlY3AyNTZrMUludGVyZmFjZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeUVjYyhlY2MpIHtcbiAgYXNzZXJ0KHR5cGVvZiBlY2MuaXNYT25seVBvaW50ID09PSAnZnVuY3Rpb24nKTtcbiAgYXNzZXJ0KFxuICAgIGVjYy5pc1hPbmx5UG9pbnQoXG4gICAgICBoKCc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyksXG4gICAgKSxcbiAgKTtcbiAgYXNzZXJ0KFxuICAgIGVjYy5pc1hPbmx5UG9pbnQoXG4gICAgICBoKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWVmZmZmYzJlJyksXG4gICAgKSxcbiAgKTtcbiAgYXNzZXJ0KFxuICAgIGVjYy5pc1hPbmx5UG9pbnQoXG4gICAgICBoKCdmOTMwOGEwMTkyNThjMzEwNDkzNDRmODVmODlkNTIyOWI1MzFjODQ1ODM2Zjk5YjA4NjAxZjExM2JjZTAzNmY5JyksXG4gICAgKSxcbiAgKTtcbiAgYXNzZXJ0KFxuICAgIGVjYy5pc1hPbmx5UG9pbnQoXG4gICAgICBoKCcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJyksXG4gICAgKSxcbiAgKTtcbiAgYXNzZXJ0KFxuICAgICFlY2MuaXNYT25seVBvaW50KFxuICAgICAgaCgnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpLFxuICAgICksXG4gICk7XG4gIGFzc2VydChcbiAgICAhZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQodHlwZW9mIGVjYy54T25seVBvaW50QWRkVHdlYWsgPT09ICdmdW5jdGlvbicpO1xuICB0d2Vha0FkZFZlY3RvcnMuZm9yRWFjaCh0ID0+IHtcbiAgICBjb25zdCByID0gZWNjLnhPbmx5UG9pbnRBZGRUd2VhayhoKHQucHVia2V5KSwgaCh0LnR3ZWFrKSk7XG4gICAgaWYgKHQucmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBhc3NlcnQociA9PT0gbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChyICE9PSBudWxsKTtcbiAgICAgIGFzc2VydChyLnBhcml0eSA9PT0gdC5wYXJpdHkpO1xuICAgICAgYXNzZXJ0KEJ1ZmZlci5mcm9tKHIueE9ubHlQdWJrZXkpLmVxdWFscyhoKHQucmVzdWx0KSkpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnQoYm9vbCkge1xuICBpZiAoIWJvb2wpIHRocm93IG5ldyBFcnJvcignZWNjIGxpYnJhcnkgaW52YWxpZCcpO1xufVxuY29uc3QgdHdlYWtBZGRWZWN0b3JzID0gW1xuICB7XG4gICAgcHVia2V5OiAnNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcsXG4gICAgdHdlYWs6ICdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQwJyxcbiAgICBwYXJpdHk6IC0xLFxuICAgIHJlc3VsdDogbnVsbCxcbiAgfSxcbiAge1xuICAgIHB1YmtleTogJzE2MTdkMzhlZDhkODY1N2RhNGQ0NzYxZTgwNTdiYzM5NmVhOWU0YjlkMjk3NzZkNGJlMDk2MDE2ZGJkMjUwOWInLFxuICAgIHR3ZWFrOiAnYTgzOTdhOTM1ZjBkZmNlYmE2YmE5NjE4ZjY0NTFlZjRkODA2MzdhYmY0ZTZhZjI2NjlmYmM5ZGU2YThmZDJhYycsXG4gICAgcGFyaXR5OiAxLFxuICAgIHJlc3VsdDogJ2U0NzhmOTlkYWI5MTA1MmFiMzlhMzNlYTM1ZmQ1ZTZlNDkzM2Y0ZDI4MDIzY2Q1OTdjOWExZjY3NjAzNDZhZGYnLFxuICB9LFxuICB7XG4gICAgcHVia2V5OiAnMmMwYjdjZjk1MzI0YTA3ZDA1Mzk4YjI0MDE3NGRjMGMyYmU0NDRkOTZiMTU5YWE2YzdmN2IxZTY2ODY4MDk5MScsXG4gICAgdHdlYWs6ICc4MjNjM2NkMjE0Mjc0NGIwNzVhODdlYWRlN2UxYjg2NzhiYTMwOGQ1NjYyMjZhMDA1NmNhMmI3YTc2Zjg2YjQ3JyxcbiAgICBwYXJpdHk6IDAsXG4gICAgcmVzdWx0OiAnOTUzNGY4ZGM4YzZkZWRhMmRjMDA3NjU1OTgxYzc4YjQ5YzVkOTZjNzc4ZmJmMzYzNDYyYTExZWM5ZGZkOTQ4YycsXG4gIH0sXG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ecc_lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initEccLib =\n  exports.Transaction =\n  exports.opcodes =\n  exports.Psbt =\n  exports.Block =\n  exports.script =\n  exports.payments =\n  exports.networks =\n  exports.crypto =\n  exports.address =\n    void 0;\nconst address = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/address.js\");\nexports.address = address;\nconst crypto = __webpack_require__(/*! ./crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nexports.crypto = crypto;\nconst networks = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nexports.networks = networks;\nconst payments = __webpack_require__(/*! ./payments */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js\");\nexports.payments = payments;\nconst script = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nexports.script = script;\nvar block_1 = __webpack_require__(/*! ./block */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/block.js\");\nObject.defineProperty(exports, \"Block\", ({\n  enumerable: true,\n  get: function () {\n    return block_1.Block;\n  },\n}));\nvar psbt_1 = __webpack_require__(/*! ./psbt */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt.js\");\nObject.defineProperty(exports, \"Psbt\", ({\n  enumerable: true,\n  get: function () {\n    return psbt_1.Psbt;\n  },\n}));\n/** @hidden */\nvar ops_1 = __webpack_require__(/*! ./ops */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ops.js\");\nObject.defineProperty(exports, \"opcodes\", ({\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n}));\nvar transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js\");\nObject.defineProperty(exports, \"Transaction\", ({\n  enumerable: true,\n  get: function () {\n    return transaction_1.Transaction;\n  },\n}));\nvar ecc_lib_1 = __webpack_require__(/*! ./ecc_lib */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ecc_lib.js\");\nObject.defineProperty(exports, \"initEccLib\", ({\n  enumerable: true,\n  get: function () {\n    return ecc_lib_1.initEccLib;\n  },\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLEVBQUUsbUJBQW1CO0FBQ3JCLEVBQUUsZUFBZTtBQUNqQixFQUFFLFlBQVk7QUFDZCxFQUFFLGFBQWE7QUFDZixFQUFFLGNBQWM7QUFDaEIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsZUFBZTtBQUNqQjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJHQUFXO0FBQ25DLGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMseUdBQVU7QUFDakMsY0FBYztBQUNkLGlCQUFpQixtQkFBTyxDQUFDLDZHQUFZO0FBQ3JDLGdCQUFnQjtBQUNoQixpQkFBaUIsbUJBQU8sQ0FBQyxtSEFBWTtBQUNyQyxnQkFBZ0I7QUFDaEIsZUFBZSxtQkFBTyxDQUFDLHlHQUFVO0FBQ2pDLGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsdUdBQVM7QUFDL0IseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRixhQUFhLG1CQUFPLENBQUMscUdBQVE7QUFDN0Isd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRjtBQUNBLFlBQVksbUJBQU8sQ0FBQyxtR0FBTztBQUMzQiwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsRUFBQztBQUNGLG9CQUFvQixtQkFBTyxDQUFDLG1IQUFlO0FBQzNDLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZ0JBQWdCLG1CQUFPLENBQUMsMkdBQVc7QUFDbkMsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0RWNjTGliID1cbiAgZXhwb3J0cy5UcmFuc2FjdGlvbiA9XG4gIGV4cG9ydHMub3Bjb2RlcyA9XG4gIGV4cG9ydHMuUHNidCA9XG4gIGV4cG9ydHMuQmxvY2sgPVxuICBleHBvcnRzLnNjcmlwdCA9XG4gIGV4cG9ydHMucGF5bWVudHMgPVxuICBleHBvcnRzLm5ldHdvcmtzID1cbiAgZXhwb3J0cy5jcnlwdG8gPVxuICBleHBvcnRzLmFkZHJlc3MgPVxuICAgIHZvaWQgMDtcbmNvbnN0IGFkZHJlc3MgPSByZXF1aXJlKCcuL2FkZHJlc3MnKTtcbmV4cG9ydHMuYWRkcmVzcyA9IGFkZHJlc3M7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xuZXhwb3J0cy5jcnlwdG8gPSBjcnlwdG87XG5jb25zdCBuZXR3b3JrcyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbmV4cG9ydHMubmV0d29ya3MgPSBuZXR3b3JrcztcbmNvbnN0IHBheW1lbnRzID0gcmVxdWlyZSgnLi9wYXltZW50cycpO1xuZXhwb3J0cy5wYXltZW50cyA9IHBheW1lbnRzO1xuY29uc3Qgc2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmV4cG9ydHMuc2NyaXB0ID0gc2NyaXB0O1xudmFyIGJsb2NrXzEgPSByZXF1aXJlKCcuL2Jsb2NrJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0Jsb2NrJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYmxvY2tfMS5CbG9jaztcbiAgfSxcbn0pO1xudmFyIHBzYnRfMSA9IHJlcXVpcmUoJy4vcHNidCcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdQc2J0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHNidF8xLlBzYnQ7XG4gIH0sXG59KTtcbi8qKiBAaGlkZGVuICovXG52YXIgb3BzXzEgPSByZXF1aXJlKCcuL29wcycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdvcGNvZGVzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gb3BzXzEuT1BTO1xuICB9LFxufSk7XG52YXIgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnVHJhbnNhY3Rpb24nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uO1xuICB9LFxufSk7XG52YXIgZWNjX2xpYl8xID0gcmVxdWlyZSgnLi9lY2NfbGliJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2luaXRFY2NMaWInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlY2NfbGliXzEuaW5pdEVjY0xpYjtcbiAgfSxcbn0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/merkle.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/merkle.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fastMerkleRoot = void 0;\n/**\n * Calculates the Merkle root of an array of buffers using a specified digest function.\n *\n * @param values - The array of buffers.\n * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.\n * @returns The Merkle root as a buffer.\n * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.\n */\nfunction fastMerkleRoot(values, digestFn) {\n  if (!Array.isArray(values)) throw TypeError('Expected values Array');\n  if (typeof digestFn !== 'function')\n    throw TypeError('Expected digest Function');\n  let length = values.length;\n  const results = values.concat();\n  while (length > 1) {\n    let j = 0;\n    for (let i = 0; i < length; i += 2, ++j) {\n      const left = results[i];\n      const right = i + 1 === length ? left : results[i + 1];\n      const data = Buffer.concat([left, right]);\n      results[j] = digestFn(data);\n    }\n    length = j;\n  }\n  return results[0];\n}\nexports.fastMerkleRoot = fastMerkleRoot;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvbWVya2xlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyIvVXNlcnMvYnRjL21pZGwteC1iaXRjb2luLXN1bW1pdC1oYWNrYXRob24tMjAyNS91dHhvLXBzYnQtZGVtby9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvbWVya2xlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZhc3RNZXJrbGVSb290ID0gdm9pZCAwO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBNZXJrbGUgcm9vdCBvZiBhbiBhcnJheSBvZiBidWZmZXJzIHVzaW5nIGEgc3BlY2lmaWVkIGRpZ2VzdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIGFycmF5IG9mIGJ1ZmZlcnMuXG4gKiBAcGFyYW0gZGlnZXN0Rm4gLSBUaGUgZGlnZXN0IGZ1bmN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBoYXNoIG9mIHRoZSBjb25jYXRlbmF0ZWQgYnVmZmVycy5cbiAqIEByZXR1cm5zIFRoZSBNZXJrbGUgcm9vdCBhcyBhIGJ1ZmZlci5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHZhbHVlcyBwYXJhbWV0ZXIgaXMgbm90IGFuIGFycmF5IG9yIHRoZSBkaWdlc3RGbiBwYXJhbWV0ZXIgaXMgbm90IGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZhc3RNZXJrbGVSb290KHZhbHVlcywgZGlnZXN0Rm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsdWVzIEFycmF5Jyk7XG4gIGlmICh0eXBlb2YgZGlnZXN0Rm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBkaWdlc3QgRnVuY3Rpb24nKTtcbiAgbGV0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdHMgPSB2YWx1ZXMuY29uY2F0KCk7XG4gIHdoaWxlIChsZW5ndGggPiAxKSB7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIsICsraikge1xuICAgICAgY29uc3QgbGVmdCA9IHJlc3VsdHNbaV07XG4gICAgICBjb25zdCByaWdodCA9IGkgKyAxID09PSBsZW5ndGggPyBsZWZ0IDogcmVzdWx0c1tpICsgMV07XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmNvbmNhdChbbGVmdCwgcmlnaHRdKTtcbiAgICAgIHJlc3VsdHNbal0gPSBkaWdlc3RGbihkYXRhKTtcbiAgICB9XG4gICAgbGVuZ3RoID0gajtcbiAgfVxuICByZXR1cm4gcmVzdWx0c1swXTtcbn1cbmV4cG9ydHMuZmFzdE1lcmtsZVJvb3QgPSBmYXN0TWVya2xlUm9vdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/merkle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// https://en.bitcoin.it/wiki/List_of_address_prefixes\n// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.testnet = exports.regtest = exports.bitcoin = void 0;\n/**\n * Represents the Bitcoin network configuration.\n */\nexports.bitcoin = {\n  /**\n   * The message prefix used for signing Bitcoin messages.\n   */\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  /**\n   * The Bech32 prefix used for Bitcoin addresses.\n   */\n  bech32: 'bc',\n  /**\n   * The BIP32 key prefixes for Bitcoin.\n   */\n  bip32: {\n    /**\n     * The public key prefix for BIP32 extended public keys.\n     */\n    public: 0x0488b21e,\n    /**\n     * The private key prefix for BIP32 extended private keys.\n     */\n    private: 0x0488ade4,\n  },\n  /**\n   * The prefix for Bitcoin public key hashes.\n   */\n  pubKeyHash: 0x00,\n  /**\n   * The prefix for Bitcoin script hashes.\n   */\n  scriptHash: 0x05,\n  /**\n   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.\n   */\n  wif: 0x80,\n};\n/**\n * Represents the regtest network configuration.\n */\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n/**\n * Represents the testnet network configuration.\n */\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvbmV0d29ya3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxlQUFlLEdBQUcsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9uZXR3b3Jrcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2VuLmJpdGNvaW4uaXQvd2lraS9MaXN0X29mX2FkZHJlc3NfcHJlZml4ZXNcbi8vIERvZ2Vjb2luIEJJUDMyIGlzIGEgcHJvcG9zZWQgc3RhbmRhcmQ6IGh0dHBzOi8vYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz00MDk3MzFcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRlc3RuZXQgPSBleHBvcnRzLnJlZ3Rlc3QgPSBleHBvcnRzLmJpdGNvaW4gPSB2b2lkIDA7XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEJpdGNvaW4gbmV0d29yayBjb25maWd1cmF0aW9uLlxuICovXG5leHBvcnRzLmJpdGNvaW4gPSB7XG4gIC8qKlxuICAgKiBUaGUgbWVzc2FnZSBwcmVmaXggdXNlZCBmb3Igc2lnbmluZyBCaXRjb2luIG1lc3NhZ2VzLlxuICAgKi9cbiAgbWVzc2FnZVByZWZpeDogJ1xceDE4Qml0Y29pbiBTaWduZWQgTWVzc2FnZTpcXG4nLFxuICAvKipcbiAgICogVGhlIEJlY2gzMiBwcmVmaXggdXNlZCBmb3IgQml0Y29pbiBhZGRyZXNzZXMuXG4gICAqL1xuICBiZWNoMzI6ICdiYycsXG4gIC8qKlxuICAgKiBUaGUgQklQMzIga2V5IHByZWZpeGVzIGZvciBCaXRjb2luLlxuICAgKi9cbiAgYmlwMzI6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHVibGljIGtleSBwcmVmaXggZm9yIEJJUDMyIGV4dGVuZGVkIHB1YmxpYyBrZXlzLlxuICAgICAqL1xuICAgIHB1YmxpYzogMHgwNDg4YjIxZSxcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpdmF0ZSBrZXkgcHJlZml4IGZvciBCSVAzMiBleHRlbmRlZCBwcml2YXRlIGtleXMuXG4gICAgICovXG4gICAgcHJpdmF0ZTogMHgwNDg4YWRlNCxcbiAgfSxcbiAgLyoqXG4gICAqIFRoZSBwcmVmaXggZm9yIEJpdGNvaW4gcHVibGljIGtleSBoYXNoZXMuXG4gICAqL1xuICBwdWJLZXlIYXNoOiAweDAwLFxuICAvKipcbiAgICogVGhlIHByZWZpeCBmb3IgQml0Y29pbiBzY3JpcHQgaGFzaGVzLlxuICAgKi9cbiAgc2NyaXB0SGFzaDogMHgwNSxcbiAgLyoqXG4gICAqIFRoZSBwcmVmaXggZm9yIEJpdGNvaW4gV2FsbGV0IEltcG9ydCBGb3JtYXQgKFdJRikgcHJpdmF0ZSBrZXlzLlxuICAgKi9cbiAgd2lmOiAweDgwLFxufTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcmVndGVzdCBuZXR3b3JrIGNvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydHMucmVndGVzdCA9IHtcbiAgbWVzc2FnZVByZWZpeDogJ1xceDE4Qml0Y29pbiBTaWduZWQgTWVzc2FnZTpcXG4nLFxuICBiZWNoMzI6ICdiY3J0JyxcbiAgYmlwMzI6IHtcbiAgICBwdWJsaWM6IDB4MDQzNTg3Y2YsXG4gICAgcHJpdmF0ZTogMHgwNDM1ODM5NCxcbiAgfSxcbiAgcHViS2V5SGFzaDogMHg2ZixcbiAgc2NyaXB0SGFzaDogMHhjNCxcbiAgd2lmOiAweGVmLFxufTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdGVzdG5ldCBuZXR3b3JrIGNvbmZpZ3VyYXRpb24uXG4gKi9cbmV4cG9ydHMudGVzdG5ldCA9IHtcbiAgbWVzc2FnZVByZWZpeDogJ1xceDE4Qml0Y29pbiBTaWduZWQgTWVzc2FnZTpcXG4nLFxuICBiZWNoMzI6ICd0YicsXG4gIGJpcDMyOiB7XG4gICAgcHVibGljOiAweDA0MzU4N2NmLFxuICAgIHByaXZhdGU6IDB4MDQzNTgzOTQsXG4gIH0sXG4gIHB1YktleUhhc2g6IDB4NmYsXG4gIHNjcmlwdEhhc2g6IDB4YzQsXG4gIHdpZjogMHhlZixcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ops.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ops.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.REVERSE_OPS = exports.OPS = void 0;\nconst OPS = {\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_NOP3: 178,\n  OP_CHECKSEQUENCEVERIFY: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  OP_CHECKSIGADD: 186,\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255,\n};\nexports.OPS = OPS;\nconst REVERSE_OPS = {};\nexports.REVERSE_OPS = REVERSE_OPS;\nfor (const op of Object.keys(OPS)) {\n  const code = OPS[op];\n  REVERSE_OPS[code] = op;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvb3BzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9vcHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUkVWRVJTRV9PUFMgPSBleHBvcnRzLk9QUyA9IHZvaWQgMDtcbmNvbnN0IE9QUyA9IHtcbiAgT1BfRkFMU0U6IDAsXG4gIE9QXzA6IDAsXG4gIE9QX1BVU0hEQVRBMTogNzYsXG4gIE9QX1BVU0hEQVRBMjogNzcsXG4gIE9QX1BVU0hEQVRBNDogNzgsXG4gIE9QXzFORUdBVEU6IDc5LFxuICBPUF9SRVNFUlZFRDogODAsXG4gIE9QX1RSVUU6IDgxLFxuICBPUF8xOiA4MSxcbiAgT1BfMjogODIsXG4gIE9QXzM6IDgzLFxuICBPUF80OiA4NCxcbiAgT1BfNTogODUsXG4gIE9QXzY6IDg2LFxuICBPUF83OiA4NyxcbiAgT1BfODogODgsXG4gIE9QXzk6IDg5LFxuICBPUF8xMDogOTAsXG4gIE9QXzExOiA5MSxcbiAgT1BfMTI6IDkyLFxuICBPUF8xMzogOTMsXG4gIE9QXzE0OiA5NCxcbiAgT1BfMTU6IDk1LFxuICBPUF8xNjogOTYsXG4gIE9QX05PUDogOTcsXG4gIE9QX1ZFUjogOTgsXG4gIE9QX0lGOiA5OSxcbiAgT1BfTk9USUY6IDEwMCxcbiAgT1BfVkVSSUY6IDEwMSxcbiAgT1BfVkVSTk9USUY6IDEwMixcbiAgT1BfRUxTRTogMTAzLFxuICBPUF9FTkRJRjogMTA0LFxuICBPUF9WRVJJRlk6IDEwNSxcbiAgT1BfUkVUVVJOOiAxMDYsXG4gIE9QX1RPQUxUU1RBQ0s6IDEwNyxcbiAgT1BfRlJPTUFMVFNUQUNLOiAxMDgsXG4gIE9QXzJEUk9QOiAxMDksXG4gIE9QXzJEVVA6IDExMCxcbiAgT1BfM0RVUDogMTExLFxuICBPUF8yT1ZFUjogMTEyLFxuICBPUF8yUk9UOiAxMTMsXG4gIE9QXzJTV0FQOiAxMTQsXG4gIE9QX0lGRFVQOiAxMTUsXG4gIE9QX0RFUFRIOiAxMTYsXG4gIE9QX0RST1A6IDExNyxcbiAgT1BfRFVQOiAxMTgsXG4gIE9QX05JUDogMTE5LFxuICBPUF9PVkVSOiAxMjAsXG4gIE9QX1BJQ0s6IDEyMSxcbiAgT1BfUk9MTDogMTIyLFxuICBPUF9ST1Q6IDEyMyxcbiAgT1BfU1dBUDogMTI0LFxuICBPUF9UVUNLOiAxMjUsXG4gIE9QX0NBVDogMTI2LFxuICBPUF9TVUJTVFI6IDEyNyxcbiAgT1BfTEVGVDogMTI4LFxuICBPUF9SSUdIVDogMTI5LFxuICBPUF9TSVpFOiAxMzAsXG4gIE9QX0lOVkVSVDogMTMxLFxuICBPUF9BTkQ6IDEzMixcbiAgT1BfT1I6IDEzMyxcbiAgT1BfWE9SOiAxMzQsXG4gIE9QX0VRVUFMOiAxMzUsXG4gIE9QX0VRVUFMVkVSSUZZOiAxMzYsXG4gIE9QX1JFU0VSVkVEMTogMTM3LFxuICBPUF9SRVNFUlZFRDI6IDEzOCxcbiAgT1BfMUFERDogMTM5LFxuICBPUF8xU1VCOiAxNDAsXG4gIE9QXzJNVUw6IDE0MSxcbiAgT1BfMkRJVjogMTQyLFxuICBPUF9ORUdBVEU6IDE0MyxcbiAgT1BfQUJTOiAxNDQsXG4gIE9QX05PVDogMTQ1LFxuICBPUF8wTk9URVFVQUw6IDE0NixcbiAgT1BfQUREOiAxNDcsXG4gIE9QX1NVQjogMTQ4LFxuICBPUF9NVUw6IDE0OSxcbiAgT1BfRElWOiAxNTAsXG4gIE9QX01PRDogMTUxLFxuICBPUF9MU0hJRlQ6IDE1MixcbiAgT1BfUlNISUZUOiAxNTMsXG4gIE9QX0JPT0xBTkQ6IDE1NCxcbiAgT1BfQk9PTE9SOiAxNTUsXG4gIE9QX05VTUVRVUFMOiAxNTYsXG4gIE9QX05VTUVRVUFMVkVSSUZZOiAxNTcsXG4gIE9QX05VTU5PVEVRVUFMOiAxNTgsXG4gIE9QX0xFU1NUSEFOOiAxNTksXG4gIE9QX0dSRUFURVJUSEFOOiAxNjAsXG4gIE9QX0xFU1NUSEFOT1JFUVVBTDogMTYxLFxuICBPUF9HUkVBVEVSVEhBTk9SRVFVQUw6IDE2MixcbiAgT1BfTUlOOiAxNjMsXG4gIE9QX01BWDogMTY0LFxuICBPUF9XSVRISU46IDE2NSxcbiAgT1BfUklQRU1EMTYwOiAxNjYsXG4gIE9QX1NIQTE6IDE2NyxcbiAgT1BfU0hBMjU2OiAxNjgsXG4gIE9QX0hBU0gxNjA6IDE2OSxcbiAgT1BfSEFTSDI1NjogMTcwLFxuICBPUF9DT0RFU0VQQVJBVE9SOiAxNzEsXG4gIE9QX0NIRUNLU0lHOiAxNzIsXG4gIE9QX0NIRUNLU0lHVkVSSUZZOiAxNzMsXG4gIE9QX0NIRUNLTVVMVElTSUc6IDE3NCxcbiAgT1BfQ0hFQ0tNVUxUSVNJR1ZFUklGWTogMTc1LFxuICBPUF9OT1AxOiAxNzYsXG4gIE9QX05PUDI6IDE3NyxcbiAgT1BfQ0hFQ0tMT0NLVElNRVZFUklGWTogMTc3LFxuICBPUF9OT1AzOiAxNzgsXG4gIE9QX0NIRUNLU0VRVUVOQ0VWRVJJRlk6IDE3OCxcbiAgT1BfTk9QNDogMTc5LFxuICBPUF9OT1A1OiAxODAsXG4gIE9QX05PUDY6IDE4MSxcbiAgT1BfTk9QNzogMTgyLFxuICBPUF9OT1A4OiAxODMsXG4gIE9QX05PUDk6IDE4NCxcbiAgT1BfTk9QMTA6IDE4NSxcbiAgT1BfQ0hFQ0tTSUdBREQ6IDE4NixcbiAgT1BfUFVCS0VZSEFTSDogMjUzLFxuICBPUF9QVUJLRVk6IDI1NCxcbiAgT1BfSU5WQUxJRE9QQ09ERTogMjU1LFxufTtcbmV4cG9ydHMuT1BTID0gT1BTO1xuY29uc3QgUkVWRVJTRV9PUFMgPSB7fTtcbmV4cG9ydHMuUkVWRVJTRV9PUFMgPSBSRVZFUlNFX09QUztcbmZvciAoY29uc3Qgb3Agb2YgT2JqZWN0LmtleXMoT1BTKSkge1xuICBjb25zdCBjb2RlID0gT1BTW29wXTtcbiAgUkVWRVJTRV9PUFNbY29kZV0gPSBvcDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ops.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/bip341.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/bip341.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tweakKey =\n  exports.tapTweakHash =\n  exports.tapleafHash =\n  exports.findScriptPath =\n  exports.toHashTree =\n  exports.rootHashFromPath =\n  exports.MAX_TAPTREE_DEPTH =\n  exports.LEAF_VERSION_TAPSCRIPT =\n    void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst ecc_lib_1 = __webpack_require__(/*! ../ecc_lib */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ecc_lib.js\");\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nconst bufferutils_1 = __webpack_require__(/*! ../bufferutils */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nexports.LEAF_VERSION_TAPSCRIPT = 0xc0;\nexports.MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\n/**\n * Calculates the root hash from a given control block and leaf hash.\n * @param controlBlock - The control block buffer.\n * @param leafHash - The leaf hash buffer.\n * @returns The root hash buffer.\n * @throws {TypeError} If the control block length is less than 33.\n */\nfunction rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (kj.compare(ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\nexports.rootHashFromPath = rootHashFromPath;\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nfunction toHashTree(scriptTree) {\n  if ((0, types_1.isTapleaf)(scriptTree))\n    return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  hashes.sort((a, b) => a.hash.compare(b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\nexports.toHashTree = toHashTree;\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nfunction findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (node.hash.equals(hash)) {\n    return [];\n  }\n  return undefined;\n}\nexports.findScriptPath = findScriptPath;\nfunction tapleafHash(leaf) {\n  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    buffer_1.Buffer.concat([\n      buffer_1.Buffer.from([version]),\n      serializeScript(leaf.output),\n    ]),\n  );\n}\nexports.tapleafHash = tapleafHash;\nfunction tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\nexports.tapTweakHash = tapTweakHash;\nfunction tweakKey(pubKey, h) {\n  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: buffer_1.Buffer.from(res.xOnlyPubkey),\n  };\n}\nexports.tweakKey = tweakKey;\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));\n}\nfunction serializeScript(s) {\n  const varintLen = bufferutils_1.varuint.encodingLength(s.length);\n  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better\n  bufferutils_1.varuint.encode(s.length, buffer);\n  return buffer_1.Buffer.concat([buffer, s]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvYmlwMzQxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixFQUFFLG9CQUFvQjtBQUN0QixFQUFFLG1CQUFtQjtBQUNyQixFQUFFLHNCQUFzQjtBQUN4QixFQUFFLGtCQUFrQjtBQUNwQixFQUFFLHdCQUF3QjtBQUMxQixFQUFFLHlCQUF5QjtBQUMzQixFQUFFLDhCQUE4QjtBQUNoQztBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLDRHQUFZO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLDBHQUFXO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLG9IQUFnQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBVTtBQUNsQyw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9iaXAzNDEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHdlYWtLZXkgPVxuICBleHBvcnRzLnRhcFR3ZWFrSGFzaCA9XG4gIGV4cG9ydHMudGFwbGVhZkhhc2ggPVxuICBleHBvcnRzLmZpbmRTY3JpcHRQYXRoID1cbiAgZXhwb3J0cy50b0hhc2hUcmVlID1cbiAgZXhwb3J0cy5yb290SGFzaEZyb21QYXRoID1cbiAgZXhwb3J0cy5NQVhfVEFQVFJFRV9ERVBUSCA9XG4gIGV4cG9ydHMuTEVBRl9WRVJTSU9OX1RBUFNDUklQVCA9XG4gICAgdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKCdidWZmZXInKTtcbmNvbnN0IGVjY19saWJfMSA9IHJlcXVpcmUoJy4uL2VjY19saWInKTtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuLi9jcnlwdG8nKTtcbmNvbnN0IGJ1ZmZlcnV0aWxzXzEgPSByZXF1aXJlKCcuLi9idWZmZXJ1dGlscycpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5leHBvcnRzLkxFQUZfVkVSU0lPTl9UQVBTQ1JJUFQgPSAweGMwO1xuZXhwb3J0cy5NQVhfVEFQVFJFRV9ERVBUSCA9IDEyODtcbmNvbnN0IGlzSGFzaEJyYW5jaCA9IGh0ID0+ICdsZWZ0JyBpbiBodCAmJiAncmlnaHQnIGluIGh0O1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSByb290IGhhc2ggZnJvbSBhIGdpdmVuIGNvbnRyb2wgYmxvY2sgYW5kIGxlYWYgaGFzaC5cbiAqIEBwYXJhbSBjb250cm9sQmxvY2sgLSBUaGUgY29udHJvbCBibG9jayBidWZmZXIuXG4gKiBAcGFyYW0gbGVhZkhhc2ggLSBUaGUgbGVhZiBoYXNoIGJ1ZmZlci5cbiAqIEByZXR1cm5zIFRoZSByb290IGhhc2ggYnVmZmVyLlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgY29udHJvbCBibG9jayBsZW5ndGggaXMgbGVzcyB0aGFuIDMzLlxuICovXG5mdW5jdGlvbiByb290SGFzaEZyb21QYXRoKGNvbnRyb2xCbG9jaywgbGVhZkhhc2gpIHtcbiAgaWYgKGNvbnRyb2xCbG9jay5sZW5ndGggPCAzMylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYFRoZSBjb250cm9sLWJsb2NrIGxlbmd0aCBpcyB0b28gc21hbGwuIEdvdCAke2NvbnRyb2xCbG9jay5sZW5ndGh9LCBleHBlY3RlZCBtaW4gMzMuYCxcbiAgICApO1xuICBjb25zdCBtID0gKGNvbnRyb2xCbG9jay5sZW5ndGggLSAzMykgLyAzMjtcbiAgbGV0IGtqID0gbGVhZkhhc2g7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgY29uc3QgZWogPSBjb250cm9sQmxvY2suc2xpY2UoMzMgKyAzMiAqIGosIDY1ICsgMzIgKiBqKTtcbiAgICBpZiAoa2ouY29tcGFyZShlaikgPCAwKSB7XG4gICAgICBraiA9IHRhcEJyYW5jaEhhc2goa2osIGVqKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2ogPSB0YXBCcmFuY2hIYXNoKGVqLCBraik7XG4gICAgfVxuICB9XG4gIHJldHVybiBrajtcbn1cbmV4cG9ydHMucm9vdEhhc2hGcm9tUGF0aCA9IHJvb3RIYXNoRnJvbVBhdGg7XG4vKipcbiAqIEJ1aWxkIGEgaGFzaCB0cmVlIG9mIG1lcmtsZSBub2RlcyBmcm9tIHRoZSBzY3JpcHRzIGJpbmFyeSB0cmVlLlxuICogQHBhcmFtIHNjcmlwdFRyZWUgLSB0aGUgdHJlZSBvZiBzY3JpcHRzIHRvIHBhaXJ3aXNlIGhhc2guXG4gKi9cbmZ1bmN0aW9uIHRvSGFzaFRyZWUoc2NyaXB0VHJlZSkge1xuICBpZiAoKDAsIHR5cGVzXzEuaXNUYXBsZWFmKShzY3JpcHRUcmVlKSlcbiAgICByZXR1cm4geyBoYXNoOiB0YXBsZWFmSGFzaChzY3JpcHRUcmVlKSB9O1xuICBjb25zdCBoYXNoZXMgPSBbdG9IYXNoVHJlZShzY3JpcHRUcmVlWzBdKSwgdG9IYXNoVHJlZShzY3JpcHRUcmVlWzFdKV07XG4gIGhhc2hlcy5zb3J0KChhLCBiKSA9PiBhLmhhc2guY29tcGFyZShiLmhhc2gpKTtcbiAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IGhhc2hlcztcbiAgcmV0dXJuIHtcbiAgICBoYXNoOiB0YXBCcmFuY2hIYXNoKGxlZnQuaGFzaCwgcmlnaHQuaGFzaCksXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgfTtcbn1cbmV4cG9ydHMudG9IYXNoVHJlZSA9IHRvSGFzaFRyZWU7XG4vKipcbiAqIEdpdmVuIGEgSGFzaFRyZWUsIGZpbmRzIHRoZSBwYXRoIGZyb20gYSBwYXJ0aWN1bGFyIGhhc2ggdG8gdGhlIHJvb3QuXG4gKiBAcGFyYW0gbm9kZSAtIHRoZSByb290IG9mIHRoZSB0cmVlXG4gKiBAcGFyYW0gaGFzaCAtIHRoZSBoYXNoIHRvIHNlYXJjaCBmb3JcbiAqIEByZXR1cm5zIC0gYXJyYXkgb2Ygc2libGluZyBoYXNoZXMsIGZyb20gbGVhZiAoaW5jbHVzaXZlKSB0byByb290XG4gKiAoZXhjbHVzaXZlKSBuZWVkZWQgdG8gcHJvdmUgaW5jbHVzaW9uIG9mIHRoZSBzcGVjaWZpZWQgaGFzaC4gdW5kZWZpbmVkIGlmIG5vXG4gKiBwYXRoIGlzIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGZpbmRTY3JpcHRQYXRoKG5vZGUsIGhhc2gpIHtcbiAgaWYgKGlzSGFzaEJyYW5jaChub2RlKSkge1xuICAgIGNvbnN0IGxlZnRQYXRoID0gZmluZFNjcmlwdFBhdGgobm9kZS5sZWZ0LCBoYXNoKTtcbiAgICBpZiAobGVmdFBhdGggIT09IHVuZGVmaW5lZCkgcmV0dXJuIFsuLi5sZWZ0UGF0aCwgbm9kZS5yaWdodC5oYXNoXTtcbiAgICBjb25zdCByaWdodFBhdGggPSBmaW5kU2NyaXB0UGF0aChub2RlLnJpZ2h0LCBoYXNoKTtcbiAgICBpZiAocmlnaHRQYXRoICE9PSB1bmRlZmluZWQpIHJldHVybiBbLi4ucmlnaHRQYXRoLCBub2RlLmxlZnQuaGFzaF07XG4gIH0gZWxzZSBpZiAobm9kZS5oYXNoLmVxdWFscyhoYXNoKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5maW5kU2NyaXB0UGF0aCA9IGZpbmRTY3JpcHRQYXRoO1xuZnVuY3Rpb24gdGFwbGVhZkhhc2gobGVhZikge1xuICBjb25zdCB2ZXJzaW9uID0gbGVhZi52ZXJzaW9uIHx8IGV4cG9ydHMuTEVBRl9WRVJTSU9OX1RBUFNDUklQVDtcbiAgcmV0dXJuIGJjcnlwdG8udGFnZ2VkSGFzaChcbiAgICAnVGFwTGVhZicsXG4gICAgYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbXG4gICAgICBidWZmZXJfMS5CdWZmZXIuZnJvbShbdmVyc2lvbl0pLFxuICAgICAgc2VyaWFsaXplU2NyaXB0KGxlYWYub3V0cHV0KSxcbiAgICBdKSxcbiAgKTtcbn1cbmV4cG9ydHMudGFwbGVhZkhhc2ggPSB0YXBsZWFmSGFzaDtcbmZ1bmN0aW9uIHRhcFR3ZWFrSGFzaChwdWJLZXksIGgpIHtcbiAgcmV0dXJuIGJjcnlwdG8udGFnZ2VkSGFzaChcbiAgICAnVGFwVHdlYWsnLFxuICAgIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoaCA/IFtwdWJLZXksIGhdIDogW3B1YktleV0pLFxuICApO1xufVxuZXhwb3J0cy50YXBUd2Vha0hhc2ggPSB0YXBUd2Vha0hhc2g7XG5mdW5jdGlvbiB0d2Vha0tleShwdWJLZXksIGgpIHtcbiAgaWYgKCFidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIocHViS2V5KSkgcmV0dXJuIG51bGw7XG4gIGlmIChwdWJLZXkubGVuZ3RoICE9PSAzMikgcmV0dXJuIG51bGw7XG4gIGlmIChoICYmIGgubGVuZ3RoICE9PSAzMikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHR3ZWFrSGFzaCA9IHRhcFR3ZWFrSGFzaChwdWJLZXksIGgpO1xuICBjb25zdCByZXMgPSAoMCwgZWNjX2xpYl8xLmdldEVjY0xpYikoKS54T25seVBvaW50QWRkVHdlYWsocHViS2V5LCB0d2Vha0hhc2gpO1xuICBpZiAoIXJlcyB8fCByZXMueE9ubHlQdWJrZXkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIHBhcml0eTogcmVzLnBhcml0eSxcbiAgICB4OiBidWZmZXJfMS5CdWZmZXIuZnJvbShyZXMueE9ubHlQdWJrZXkpLFxuICB9O1xufVxuZXhwb3J0cy50d2Vha0tleSA9IHR3ZWFrS2V5O1xuZnVuY3Rpb24gdGFwQnJhbmNoSGFzaChhLCBiKSB7XG4gIHJldHVybiBiY3J5cHRvLnRhZ2dlZEhhc2goJ1RhcEJyYW5jaCcsIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW2EsIGJdKSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTY3JpcHQocykge1xuICBjb25zdCB2YXJpbnRMZW4gPSBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgocy5sZW5ndGgpO1xuICBjb25zdCBidWZmZXIgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2NVbnNhZmUodmFyaW50TGVuKTsgLy8gYmV0dGVyXG4gIGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGUocy5sZW5ndGgsIGJ1ZmZlcik7XG4gIHJldHVybiBidWZmZXJfMS5CdWZmZXIuY29uY2F0KFtidWZmZXIsIHNdKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/bip341.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/embed.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/embed.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2data = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst OPS = bscript.OPS;\n// output: OP_RETURN ...\n/**\n * Embeds data in a Bitcoin payment.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The modified payment object.\n * @throws {TypeError} If there is not enough data or if the output is invalid.\n */\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      data: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(types_1.typeforce.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvZW1iZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG1CQUFtQixtQkFBTyxDQUFDLDhHQUFhO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDBHQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFVO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyw4R0FBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyIvVXNlcnMvYnRjL21pZGwteC1iaXRjb2luLXN1bW1pdC1oYWNrYXRob24tMjAyNS91dHhvLXBzYnQtZGVtby9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvZW1iZWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJkYXRhID0gdm9pZCAwO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuLy8gb3V0cHV0OiBPUF9SRVRVUk4gLi4uXG4vKipcbiAqIEVtYmVkcyBkYXRhIGluIGEgQml0Y29pbiBwYXltZW50LlxuICogQHBhcmFtIGEgLSBUaGUgcGF5bWVudCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIHBheW1lbnQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBtb2RpZmllZCBwYXltZW50IG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIG9yIGlmIHRoZSBvdXRwdXQgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gcDJkYXRhKGEsIG9wdHMpIHtcbiAgaWYgKCFhLmRhdGEgJiYgIWEub3V0cHV0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKShcbiAgICB7XG4gICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgZGF0YTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBuZXR3b3JrID0gYS5uZXR3b3JrIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgY29uc3QgbyA9IHsgbmFtZTogJ2VtYmVkJywgbmV0d29yayB9O1xuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEuZGF0YSkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF9SRVRVUk5dLmNvbmNhdChhLmRhdGEpKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnZGF0YScsICgpID0+IHtcbiAgICBpZiAoIWEub3V0cHV0KSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEub3V0cHV0KS5zbGljZSgxKTtcbiAgfSk7XG4gIC8vIGV4dGVuZGVkIHZhbGlkYXRpb25cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGNvbnN0IGNodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKGEub3V0cHV0KTtcbiAgICAgIGlmIChjaHVua3NbMF0gIT09IE9QUy5PUF9SRVRVUk4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIWNodW5rcy5zbGljZSgxKS5ldmVyeSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKGEuZGF0YSAmJiAhKDAsIHR5cGVzXzEuc3RhY2tzRXF1YWwpKGEuZGF0YSwgby5kYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJkYXRhID0gcDJkYXRhO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/embed.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2tr =\n  exports.p2wsh =\n  exports.p2wpkh =\n  exports.p2sh =\n  exports.p2pkh =\n  exports.p2pk =\n  exports.p2ms =\n  exports.embed =\n    void 0;\nconst embed_1 = __webpack_require__(/*! ./embed */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/embed.js\");\nObject.defineProperty(exports, \"embed\", ({\n  enumerable: true,\n  get: function () {\n    return embed_1.p2data;\n  },\n}));\nconst p2ms_1 = __webpack_require__(/*! ./p2ms */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2ms.js\");\nObject.defineProperty(exports, \"p2ms\", ({\n  enumerable: true,\n  get: function () {\n    return p2ms_1.p2ms;\n  },\n}));\nconst p2pk_1 = __webpack_require__(/*! ./p2pk */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pk.js\");\nObject.defineProperty(exports, \"p2pk\", ({\n  enumerable: true,\n  get: function () {\n    return p2pk_1.p2pk;\n  },\n}));\nconst p2pkh_1 = __webpack_require__(/*! ./p2pkh */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pkh.js\");\nObject.defineProperty(exports, \"p2pkh\", ({\n  enumerable: true,\n  get: function () {\n    return p2pkh_1.p2pkh;\n  },\n}));\nconst p2sh_1 = __webpack_require__(/*! ./p2sh */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2sh.js\");\nObject.defineProperty(exports, \"p2sh\", ({\n  enumerable: true,\n  get: function () {\n    return p2sh_1.p2sh;\n  },\n}));\nconst p2wpkh_1 = __webpack_require__(/*! ./p2wpkh */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js\");\nObject.defineProperty(exports, \"p2wpkh\", ({\n  enumerable: true,\n  get: function () {\n    return p2wpkh_1.p2wpkh;\n  },\n}));\nconst p2wsh_1 = __webpack_require__(/*! ./p2wsh */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wsh.js\");\nObject.defineProperty(exports, \"p2wsh\", ({\n  enumerable: true,\n  get: function () {\n    return p2wsh_1.p2wsh;\n  },\n}));\nconst p2tr_1 = __webpack_require__(/*! ./p2tr */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2tr.js\");\nObject.defineProperty(exports, \"p2tr\", ({\n  enumerable: true,\n  get: function () {\n    return p2tr_1.p2tr;\n  },\n}));\n// TODO\n// witness commitment\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLEVBQUUsYUFBYTtBQUNmLEVBQUUsY0FBYztBQUNoQixFQUFFLFlBQVk7QUFDZCxFQUFFLGFBQWE7QUFDZixFQUFFLFlBQVk7QUFDZCxFQUFFLFlBQVk7QUFDZCxFQUFFLGFBQWE7QUFDZjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdIQUFTO0FBQ2pDLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZUFBZSxtQkFBTyxDQUFDLDhHQUFRO0FBQy9CLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZUFBZSxtQkFBTyxDQUFDLDhHQUFRO0FBQy9CLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQVM7QUFDakMseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRixlQUFlLG1CQUFPLENBQUMsOEdBQVE7QUFDL0Isd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRixpQkFBaUIsbUJBQU8sQ0FBQyxrSEFBVTtBQUNuQywwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsRUFBQztBQUNGLGdCQUFnQixtQkFBTyxDQUFDLGdIQUFTO0FBQ2pDLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZUFBZSxtQkFBTyxDQUFDLDhHQUFRO0FBQy9CLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0Y7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAydHIgPVxuICBleHBvcnRzLnAyd3NoID1cbiAgZXhwb3J0cy5wMndwa2ggPVxuICBleHBvcnRzLnAyc2ggPVxuICBleHBvcnRzLnAycGtoID1cbiAgZXhwb3J0cy5wMnBrID1cbiAgZXhwb3J0cy5wMm1zID1cbiAgZXhwb3J0cy5lbWJlZCA9XG4gICAgdm9pZCAwO1xuY29uc3QgZW1iZWRfMSA9IHJlcXVpcmUoJy4vZW1iZWQnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZW1iZWQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbWJlZF8xLnAyZGF0YTtcbiAgfSxcbn0pO1xuY29uc3QgcDJtc18xID0gcmVxdWlyZSgnLi9wMm1zJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3AybXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwMm1zXzEucDJtcztcbiAgfSxcbn0pO1xuY29uc3QgcDJwa18xID0gcmVxdWlyZSgnLi9wMnBrJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3AycGsnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwMnBrXzEucDJwaztcbiAgfSxcbn0pO1xuY29uc3QgcDJwa2hfMSA9IHJlcXVpcmUoJy4vcDJwa2gnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncDJwa2gnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwMnBraF8xLnAycGtoO1xuICB9LFxufSk7XG5jb25zdCBwMnNoXzEgPSByZXF1aXJlKCcuL3Ayc2gnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncDJzaCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHAyc2hfMS5wMnNoO1xuICB9LFxufSk7XG5jb25zdCBwMndwa2hfMSA9IHJlcXVpcmUoJy4vcDJ3cGtoJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3Ayd3BraCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHAyd3BraF8xLnAyd3BraDtcbiAgfSxcbn0pO1xuY29uc3QgcDJ3c2hfMSA9IHJlcXVpcmUoJy4vcDJ3c2gnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncDJ3c2gnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwMndzaF8xLnAyd3NoO1xuICB9LFxufSk7XG5jb25zdCBwMnRyXzEgPSByZXF1aXJlKCcuL3AydHInKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncDJ0cicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHAydHJfMS5wMnRyO1xuICB9LFxufSk7XG4vLyBUT0RPXG4vLyB3aXRuZXNzIGNvbW1pdG1lbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.value = exports.prop = void 0;\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvbGF6eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhIiwic291cmNlcyI6WyIvVXNlcnMvYnRjL21pZGwteC1iaXRjb2luLXN1bW1pdC1oYWNrYXRob24tMjAyNS91dHhvLXBzYnQtZGVtby9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvbGF6eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWx1ZSA9IGV4cG9ydHMucHJvcCA9IHZvaWQgMDtcbmZ1bmN0aW9uIHByb3Aob2JqZWN0LCBuYW1lLCBmKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBfdmFsdWUgPSBmLmNhbGwodGhpcyk7XG4gICAgICB0aGlzW25hbWVdID0gX3ZhbHVlO1xuICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICB9LFxuICAgIHNldChfdmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IF92YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9LFxuICB9KTtcbn1cbmV4cG9ydHMucHJvcCA9IHByb3A7XG5mdW5jdGlvbiB2YWx1ZShmKSB7XG4gIGxldCBfdmFsdWU7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKF92YWx1ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gX3ZhbHVlO1xuICAgIF92YWx1ZSA9IGYoKTtcbiAgICByZXR1cm4gX3ZhbHVlO1xuICB9O1xufVxuZXhwb3J0cy52YWx1ZSA9IHZhbHVlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2ms.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2ms.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2ms = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\n/**\n * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The created payment object.\n * @throws {TypeError} If the provided data is not valid.\n */\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      m: types_1.typeforce.maybe(types_1.typeforce.Number),\n      n: types_1.typeforce.maybe(types_1.typeforce.Number),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkeys: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.isPoint),\n      ),\n      signatures: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(isAcceptableSignature),\n      ),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!types_1.typeforce.Number(chunks[0]))\n        throw new TypeError('Output is invalid');\n      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsOEdBQWE7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsMEdBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQVU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDhHQUFRO0FBQzdCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSyxLQUFLLElBQUk7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL3AybXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJtcyA9IHZvaWQgMDtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5jb25zdCBsYXp5ID0gcmVxdWlyZSgnLi9sYXp5Jyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmNvbnN0IE9QX0lOVF9CQVNFID0gT1BTLk9QX1JFU0VSVkVEOyAvLyBPUF8xIC0gMVxuLy8gaW5wdXQ6IE9QXzAgW3NpZ25hdHVyZXMgLi4uXVxuLy8gb3V0cHV0OiBtIFtwdWJLZXlzIC4uLl0gbiBPUF9DSEVDS01VTFRJU0lHXG4vKipcbiAqIFJlcHJlc2VudHMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBQYXktdG8tTXVsdGlzaWcgKFAyTVMpIHBheW1lbnQgb2JqZWN0LlxuICogQHBhcmFtIGEgLSBUaGUgcGF5bWVudCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIHBheW1lbnQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHBheW1lbnQgb2JqZWN0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgcHJvdmlkZWQgZGF0YSBpcyBub3QgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHAybXMoYSwgb3B0cykge1xuICBpZiAoXG4gICAgIWEuaW5wdXQgJiZcbiAgICAhYS5vdXRwdXQgJiZcbiAgICAhKGEucHVia2V5cyAmJiBhLm0gIT09IHVuZGVmaW5lZCkgJiZcbiAgICAhYS5zaWduYXR1cmVzXG4gIClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgZnVuY3Rpb24gaXNBY2NlcHRhYmxlU2lnbmF0dXJlKHgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZSh4KSB8fFxuICAgICAgKG9wdHMuYWxsb3dJbmNvbXBsZXRlICYmIHggPT09IE9QUy5PUF8wKSAhPT0gdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBtOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5OdW1iZXIpLFxuICAgICAgbjogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgIHB1YmtleXM6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEuaXNQb2ludCksXG4gICAgICApLFxuICAgICAgc2lnbmF0dXJlczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YoaXNBY2NlcHRhYmxlU2lnbmF0dXJlKSxcbiAgICAgICksXG4gICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IG5ldHdvcmsgPSBhLm5ldHdvcmsgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICBjb25zdCBvID0geyBuZXR3b3JrIH07XG4gIGxldCBjaHVua3MgPSBbXTtcbiAgbGV0IGRlY29kZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVjb2RlKG91dHB1dCkge1xuICAgIGlmIChkZWNvZGVkKSByZXR1cm47XG4gICAgZGVjb2RlZCA9IHRydWU7XG4gICAgY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUob3V0cHV0KTtcbiAgICBvLm0gPSBjaHVua3NbMF0gLSBPUF9JTlRfQkFTRTtcbiAgICBvLm4gPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDJdIC0gT1BfSU5UX0JBU0U7XG4gICAgby5wdWJrZXlzID0gY2h1bmtzLnNsaWNlKDEsIC0yKTtcbiAgfVxuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEubSkgcmV0dXJuO1xuICAgIGlmICghby5uKSByZXR1cm47XG4gICAgaWYgKCFhLnB1YmtleXMpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFxuICAgICAgW10uY29uY2F0KFxuICAgICAgICBPUF9JTlRfQkFTRSArIGEubSxcbiAgICAgICAgYS5wdWJrZXlzLFxuICAgICAgICBPUF9JTlRfQkFTRSArIG8ubixcbiAgICAgICAgT1BTLk9QX0NIRUNLTVVMVElTSUcsXG4gICAgICApLFxuICAgICk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ20nLCAoKSA9PiB7XG4gICAgaWYgKCFvLm91dHB1dCkgcmV0dXJuO1xuICAgIGRlY29kZShvLm91dHB1dCk7XG4gICAgcmV0dXJuIG8ubTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnbicsICgpID0+IHtcbiAgICBpZiAoIW8ucHVia2V5cykgcmV0dXJuO1xuICAgIHJldHVybiBvLnB1YmtleXMubGVuZ3RoO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdwdWJrZXlzJywgKCkgPT4ge1xuICAgIGlmICghYS5vdXRwdXQpIHJldHVybjtcbiAgICBkZWNvZGUoYS5vdXRwdXQpO1xuICAgIHJldHVybiBvLnB1YmtleXM7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3NpZ25hdHVyZXMnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpLnNsaWNlKDEpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdpbnB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEuc2lnbmF0dXJlcykgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8wXS5jb25jYXQoYS5zaWduYXR1cmVzKSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICduYW1lJywgKCkgPT4ge1xuICAgIGlmICghby5tIHx8ICFvLm4pIHJldHVybjtcbiAgICByZXR1cm4gYHAybXMoJHtvLm19IG9mICR7by5ufSlgO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgZGVjb2RlKGEub3V0cHV0KTtcbiAgICAgIGlmICghdHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKGNodW5rc1swXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIXR5cGVzXzEudHlwZWZvcmNlLk51bWJlcihjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDJdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdICE9PSBPUFMuT1BfQ0hFQ0tNVUxUSVNJRylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChvLm0gPD0gMCB8fCBvLm4gPiAxNiB8fCBvLm0gPiBvLm4gfHwgby5uICE9PSBjaHVua3MubGVuZ3RoIC0gMylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghby5wdWJrZXlzLmV2ZXJ5KHggPT4gKDAsIHR5cGVzXzEuaXNQb2ludCkoeCkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKGEubSAhPT0gdW5kZWZpbmVkICYmIGEubSAhPT0gby5tKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5uICE9PSB1bmRlZmluZWQgJiYgYS5uICE9PSBvLm4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ24gbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChhLnB1YmtleXMgJiYgISgwLCB0eXBlc18xLnN0YWNrc0VxdWFsKShhLnB1YmtleXMsIG8ucHVia2V5cykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleXMgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgaWYgKGEucHVia2V5cykge1xuICAgICAgaWYgKGEubiAhPT0gdW5kZWZpbmVkICYmIGEubiAhPT0gYS5wdWJrZXlzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IGNvdW50IG1pc21hdGNoJyk7XG4gICAgICBvLm4gPSBhLnB1YmtleXMubGVuZ3RoO1xuICAgICAgaWYgKG8ubiA8IG8ubSkgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IGNvdW50IGNhbm5vdCBiZSBsZXNzIHRoYW4gbScpO1xuICAgIH1cbiAgICBpZiAoYS5zaWduYXR1cmVzKSB7XG4gICAgICBpZiAoYS5zaWduYXR1cmVzLmxlbmd0aCA8IG8ubSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBzaWduYXR1cmVzIHByb3ZpZGVkJyk7XG4gICAgICBpZiAoYS5zaWduYXR1cmVzLmxlbmd0aCA+IG8ubSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVG9vIG1hbnkgc2lnbmF0dXJlcyBwcm92aWRlZCcpO1xuICAgIH1cbiAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgaWYgKGEuaW5wdXRbMF0gIT09IE9QUy5PUF8wKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoXG4gICAgICAgIG8uc2lnbmF0dXJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgICAgIW8uc2lnbmF0dXJlcy5ldmVyeShpc0FjY2VwdGFibGVTaWduYXR1cmUpXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGhhcyBpbnZhbGlkIHNpZ25hdHVyZShzKScpO1xuICAgICAgaWYgKGEuc2lnbmF0dXJlcyAmJiAhKDAsIHR5cGVzXzEuc3RhY2tzRXF1YWwpKGEuc2lnbmF0dXJlcywgby5zaWduYXR1cmVzKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5tICE9PSB1bmRlZmluZWQgJiYgYS5tICE9PSBhLnNpZ25hdHVyZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaWduYXR1cmUgY291bnQgbWlzbWF0Y2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAybXMgPSBwMm1zO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2ms.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pk.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pk.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2pk = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst OPS = bscript.OPS;\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\n/**\n * Creates a pay-to-public-key (P2PK) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PK payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!(0, types_1.isPoint)(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJway5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsOEdBQWE7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsMEdBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQVU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDhHQUFRO0FBQzdCO0FBQ0EsV0FBVztBQUNYLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMnBrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAycGsgPSB2b2lkIDA7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG4vLyBpbnB1dDoge3NpZ25hdHVyZX1cbi8vIG91dHB1dDoge3B1YktleX0gT1BfQ0hFQ0tTSUdcbi8qKlxuICogQ3JlYXRlcyBhIHBheS10by1wdWJsaWMta2V5IChQMlBLKSBwYXltZW50IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSBwYXltZW50IG9iamVjdCBjb250YWluaW5nIHRoZSBuZWNlc3NhcnkgZGF0YS5cbiAqIEBwYXJhbSBvcHRzIC0gT3B0aW9uYWwgcGF5bWVudCBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIFAyUEsgcGF5bWVudCBvYmplY3QuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSByZXF1aXJlZCBkYXRhIGlzIG5vdCBwcm92aWRlZCBvciBpZiB0aGUgZGF0YSBpcyBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBwMnBrKGEsIG9wdHMpIHtcbiAgaWYgKCFhLmlucHV0ICYmICFhLm91dHB1dCAmJiAhYS5wdWJrZXkgJiYgIWEuaW5wdXQgJiYgIWEuc2lnbmF0dXJlKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICBwdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEuaXNQb2ludCksXG4gICAgICBzaWduYXR1cmU6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUpLFxuICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBfY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpO1xuICB9KTtcbiAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIGNvbnN0IG8gPSB7IG5hbWU6ICdwMnBrJywgbmV0d29yayB9O1xuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEucHVia2V5KSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbYS5wdWJrZXksIE9QUy5PUF9DSEVDS1NJR10pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdwdWJrZXknLCAoKSA9PiB7XG4gICAgaWYgKCFhLm91dHB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBhLm91dHB1dC5zbGljZSgxLCAtMSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3NpZ25hdHVyZScsICgpID0+IHtcbiAgICBpZiAoIWEuaW5wdXQpIHJldHVybjtcbiAgICByZXR1cm4gX2NodW5rcygpWzBdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdpbnB1dCcsICgpID0+IHtcbiAgICBpZiAoIWEuc2lnbmF0dXJlKSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbYS5zaWduYXR1cmVdKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaW5wdXQpIHJldHVybjtcbiAgICByZXR1cm4gW107XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBpZiAoYS5vdXRwdXRbYS5vdXRwdXQubGVuZ3RoIC0gMV0gIT09IE9QUy5PUF9DSEVDS1NJRylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmICghKDAsIHR5cGVzXzEuaXNQb2ludCkoby5wdWJrZXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgcHVia2V5IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChhLnB1YmtleSAmJiAhYS5wdWJrZXkuZXF1YWxzKG8ucHVia2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IG1pc21hdGNoJyk7XG4gICAgfVxuICAgIGlmIChhLnNpZ25hdHVyZSkge1xuICAgICAgaWYgKGEuaW5wdXQgJiYgIWEuaW5wdXQuZXF1YWxzKG8uaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaWduYXR1cmUgbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgIGlmIChfY2h1bmtzKCkubGVuZ3RoICE9PSAxKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIWJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoby5zaWduYXR1cmUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBoYXMgaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAycGsgPSBwMnBrO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pk.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pkh.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pkh.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2pkh = void 0;\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bs58check = __webpack_require__(/*! bs58check */ \"(ssr)/./node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/index.js\");\nconst OPS = bscript.OPS;\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\n/**\n * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PKH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!(0, types_1.isPoint)(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJwa2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLDBHQUFXO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLDhHQUFhO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDBHQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFVO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyw4R0FBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyw2RkFBVztBQUNyQztBQUNBLFdBQVcsWUFBWTtBQUN2Qiw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMnBraC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnBraCA9IHZvaWQgMDtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuLi9jcnlwdG8nKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5jb25zdCBsYXp5ID0gcmVxdWlyZSgnLi9sYXp5Jyk7XG5jb25zdCBiczU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuLy8gaW5wdXQ6IHtzaWduYXR1cmV9IHtwdWJrZXl9XG4vLyBvdXRwdXQ6IE9QX0RVUCBPUF9IQVNIMTYwIHtoYXNoMTYwKHB1YmtleSl9IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG4vKipcbiAqIENyZWF0ZXMgYSBQYXktdG8tUHVibGljLUtleS1IYXNoIChQMlBLSCkgcGF5bWVudCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGEgLSBUaGUgcGF5bWVudCBvYmplY3QgY29udGFpbmluZyB0aGUgbmVjZXNzYXJ5IGRhdGEuXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIHBheW1lbnQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBQMlBLSCBwYXltZW50IG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHJlcXVpcmVkIGRhdGEgaXMgbm90IHByb3ZpZGVkIG9yIGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHAycGtoKGEsIG9wdHMpIHtcbiAgaWYgKCFhLmFkZHJlc3MgJiYgIWEuaGFzaCAmJiAhYS5vdXRwdXQgJiYgIWEucHVia2V5ICYmICFhLmlucHV0KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBhZGRyZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5TdHJpbmcpLFxuICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigyMCkpLFxuICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDI1KSksXG4gICAgICBwdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEuaXNQb2ludCksXG4gICAgICBzaWduYXR1cmU6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUpLFxuICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShiczU4Y2hlY2suZGVjb2RlKGEuYWRkcmVzcykpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBwYXlsb2FkLnJlYWRVSW50OCgwKTtcbiAgICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uLCBoYXNoIH07XG4gIH0pO1xuICBjb25zdCBfY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpO1xuICB9KTtcbiAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIGNvbnN0IG8gPSB7IG5hbWU6ICdwMnBraCcsIG5ldHdvcmsgfTtcbiAgbGF6eS5wcm9wKG8sICdhZGRyZXNzJywgKCkgPT4ge1xuICAgIGlmICghby5oYXNoKSByZXR1cm47XG4gICAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMSk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KG5ldHdvcmsucHViS2V5SGFzaCwgMCk7XG4gICAgby5oYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gICAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUocGF5bG9hZCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMywgMjMpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmhhc2g7XG4gICAgaWYgKGEucHVia2V5IHx8IG8ucHVia2V5KSByZXR1cm4gYmNyeXB0by5oYXNoMTYwKGEucHVia2V5IHx8IG8ucHVia2V5KTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgIGlmICghby5oYXNoKSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbXG4gICAgICBPUFMuT1BfRFVQLFxuICAgICAgT1BTLk9QX0hBU0gxNjAsXG4gICAgICBvLmhhc2gsXG4gICAgICBPUFMuT1BfRVFVQUxWRVJJRlksXG4gICAgICBPUFMuT1BfQ0hFQ0tTSUcsXG4gICAgXSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3B1YmtleScsICgpID0+IHtcbiAgICBpZiAoIWEuaW5wdXQpIHJldHVybjtcbiAgICByZXR1cm4gX2NodW5rcygpWzFdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIF9jaHVua3MoKVswXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnB1YmtleSkgcmV0dXJuO1xuICAgIGlmICghYS5zaWduYXR1cmUpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFthLnNpZ25hdHVyZSwgYS5wdWJrZXldKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaW5wdXQpIHJldHVybjtcbiAgICByZXR1cm4gW107XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgbGV0IGhhc2ggPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgaWYgKGEuYWRkcmVzcykge1xuICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gbmV0d29yay5wdWJLZXlIYXNoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHZlcnNpb24gb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkuaGFzaC5sZW5ndGggIT09IDIwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgIGhhc2ggPSBfYWRkcmVzcygpLmhhc2g7XG4gICAgfVxuICAgIGlmIChhLmhhc2gpIHtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEuaGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGEuaGFzaDtcbiAgICB9XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGEub3V0cHV0Lmxlbmd0aCAhPT0gMjUgfHxcbiAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF9EVVAgfHxcbiAgICAgICAgYS5vdXRwdXRbMV0gIT09IE9QUy5PUF9IQVNIMTYwIHx8XG4gICAgICAgIGEub3V0cHV0WzJdICE9PSAweDE0IHx8XG4gICAgICAgIGEub3V0cHV0WzIzXSAhPT0gT1BTLk9QX0VRVUFMVkVSSUZZIHx8XG4gICAgICAgIGEub3V0cHV0WzI0XSAhPT0gT1BTLk9QX0NIRUNLU0lHXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBjb25zdCBoYXNoMiA9IGEub3V0cHV0LnNsaWNlKDMsIDIzKTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGhhc2gyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gaGFzaDI7XG4gICAgfVxuICAgIGlmIChhLnB1YmtleSkge1xuICAgICAgY29uc3QgcGtoID0gYmNyeXB0by5oYXNoMTYwKGEucHVia2V5KTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKHBraCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IHBraDtcbiAgICB9XG4gICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgIGNvbnN0IGNodW5rcyA9IF9jaHVua3MoKTtcbiAgICAgIGlmIChjaHVua3MubGVuZ3RoICE9PSAyKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIWJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoY2h1bmtzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaGFzIGludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICBpZiAoISgwLCB0eXBlc18xLmlzUG9pbnQpKGNodW5rc1sxXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGhhcyBpbnZhbGlkIHB1YmtleScpO1xuICAgICAgaWYgKGEuc2lnbmF0dXJlICYmICFhLnNpZ25hdHVyZS5lcXVhbHMoY2h1bmtzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5wdWJrZXkgJiYgIWEucHVia2V5LmVxdWFscyhjaHVua3NbMV0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChjaHVua3NbMV0pO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJwa2ggPSBwMnBraDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2pkh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2sh.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2sh.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2sh = void 0;\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bs58check = __webpack_require__(/*! bs58check */ \"(ssr)/./node_modules/.pnpm/bs58check@3.0.1/node_modules/bs58check/index.js\");\nconst OPS = bscript.OPS;\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n/**\n * Creates a Pay-to-Script-Hash (P2SH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2SH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),\n      redeem: types_1.typeforce.maybe({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    const lastChunk = chunks[chunks.length - 1];\n    return {\n      network,\n      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        if (redeem.output.byteLength > 520)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 520 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osZ0JBQWdCLG1CQUFPLENBQUMsMEdBQVc7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsOEdBQWE7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsMEdBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQVU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDhHQUFRO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLDZGQUFXO0FBQ3JDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMnNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAyc2ggPSB2b2lkIDA7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbi8vIGlucHV0OiBbcmVkZWVtU2NyaXB0U2lnIC4uLl0ge3JlZGVlbVNjcmlwdH1cbi8vIHdpdG5lc3M6IDw/PlxuLy8gb3V0cHV0OiBPUF9IQVNIMTYwIHtoYXNoMTYwKHJlZGVlbVNjcmlwdCl9IE9QX0VRVUFMXG4vKipcbiAqIENyZWF0ZXMgYSBQYXktdG8tU2NyaXB0LUhhc2ggKFAyU0gpIHBheW1lbnQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhIC0gVGhlIHBheW1lbnQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBkYXRhLlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBwYXltZW50IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUDJTSCBwYXltZW50IG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHJlcXVpcmVkIGRhdGEgaXMgbm90IHByb3ZpZGVkIG9yIGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHAyc2goYSwgb3B0cykge1xuICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5yZWRlZW0gJiYgIWEuaW5wdXQpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgIGFkZHJlc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLlN0cmluZyksXG4gICAgICBoYXNoOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDIwKSksXG4gICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjMpKSxcbiAgICAgIHJlZGVlbTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoe1xuICAgICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShcbiAgICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgICksXG4gICAgICB9KSxcbiAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBsZXQgbmV0d29yayA9IGEubmV0d29yaztcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IChhLnJlZGVlbSAmJiBhLnJlZGVlbS5uZXR3b3JrKSB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIH1cbiAgY29uc3QgbyA9IHsgbmV0d29yayB9O1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShiczU4Y2hlY2suZGVjb2RlKGEuYWRkcmVzcykpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBwYXlsb2FkLnJlYWRVSW50OCgwKTtcbiAgICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uLCBoYXNoIH07XG4gIH0pO1xuICBjb25zdCBfY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpO1xuICB9KTtcbiAgY29uc3QgX3JlZGVlbSA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IGNodW5rcyA9IF9jaHVua3MoKTtcbiAgICBjb25zdCBsYXN0Q2h1bmsgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiB7XG4gICAgICBuZXR3b3JrLFxuICAgICAgb3V0cHV0OiBsYXN0Q2h1bmsgPT09IE9QUy5PUF9GQUxTRSA/IEJ1ZmZlci5mcm9tKFtdKSA6IGxhc3RDaHVuayxcbiAgICAgIGlucHV0OiBic2NyaXB0LmNvbXBpbGUoY2h1bmtzLnNsaWNlKDAsIC0xKSksXG4gICAgICB3aXRuZXNzOiBhLndpdG5lc3MgfHwgW10sXG4gICAgfTtcbiAgfSk7XG4gIC8vIG91dHB1dCBkZXBlbmRlbnRzXG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjEpO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChvLm5ldHdvcmsuc2NyaXB0SGFzaCwgMCk7XG4gICAgby5oYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gICAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUocGF5bG9hZCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgLy8gaW4gb3JkZXIgb2YgbGVhc3QgZWZmb3J0XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMiwgMjIpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmhhc2g7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLm91dHB1dCkgcmV0dXJuIGJjcnlwdG8uaGFzaDE2MChvLnJlZGVlbS5vdXRwdXQpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfSEFTSDE2MCwgby5oYXNoLCBPUFMuT1BfRVFVQUxdKTtcbiAgfSk7XG4gIC8vIGlucHV0IGRlcGVuZGVudHNcbiAgbGF6eS5wcm9wKG8sICdyZWRlZW0nLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIF9yZWRlZW0oKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnJlZGVlbSB8fCAhYS5yZWRlZW0uaW5wdXQgfHwgIWEucmVkZWVtLm91dHB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoXG4gICAgICBbXS5jb25jYXQoYnNjcmlwdC5kZWNvbXBpbGUoYS5yZWRlZW0uaW5wdXQpLCBhLnJlZGVlbS5vdXRwdXQpLFxuICAgICk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLndpdG5lc3MpIHJldHVybiBvLnJlZGVlbS53aXRuZXNzO1xuICAgIGlmIChvLmlucHV0KSByZXR1cm4gW107XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ25hbWUnLCAoKSA9PiB7XG4gICAgY29uc3QgbmFtZVBhcnRzID0gWydwMnNoJ107XG4gICAgaWYgKG8ucmVkZWVtICE9PSB1bmRlZmluZWQgJiYgby5yZWRlZW0ubmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgbmFtZVBhcnRzLnB1c2goby5yZWRlZW0ubmFtZSk7XG4gICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCctJyk7XG4gIH0pO1xuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgIGlmIChfYWRkcmVzcygpLnZlcnNpb24gIT09IG5ldHdvcmsuc2NyaXB0SGFzaClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIG9yIE5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmhhc2gubGVuZ3RoICE9PSAyMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICBoYXNoID0gX2FkZHJlc3MoKS5oYXNoO1xuICAgIH1cbiAgICBpZiAoYS5oYXNoKSB7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBhLmhhc2g7XG4gICAgfVxuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgaWYgKFxuICAgICAgICBhLm91dHB1dC5sZW5ndGggIT09IDIzIHx8XG4gICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfSEFTSDE2MCB8fFxuICAgICAgICBhLm91dHB1dFsxXSAhPT0gMHgxNCB8fFxuICAgICAgICBhLm91dHB1dFsyMl0gIT09IE9QUy5PUF9FUVVBTFxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgY29uc3QgaGFzaDIgPSBhLm91dHB1dC5zbGljZSgyLCAyMik7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGhhc2gyO1xuICAgIH1cbiAgICAvLyBpbmxpbmVkIHRvIHByZXZlbnQgJ25vLWlubmVyLWRlY2xhcmF0aW9ucycgZmFpbGluZ1xuICAgIGNvbnN0IGNoZWNrUmVkZWVtID0gcmVkZWVtID0+IHtcbiAgICAgIC8vIGlzIHRoZSByZWRlZW0gb3V0cHV0IGVtcHR5L2ludmFsaWQ/XG4gICAgICBpZiAocmVkZWVtLm91dHB1dCkge1xuICAgICAgICBjb25zdCBkZWNvbXBpbGUgPSBic2NyaXB0LmRlY29tcGlsZShyZWRlZW0ub3V0cHV0KTtcbiAgICAgICAgaWYgKCFkZWNvbXBpbGUgfHwgZGVjb21waWxlLmxlbmd0aCA8IDEpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLm91dHB1dCB0b28gc2hvcnQnKTtcbiAgICAgICAgaWYgKHJlZGVlbS5vdXRwdXQuYnl0ZUxlbmd0aCA+IDUyMClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ1JlZGVlbS5vdXRwdXQgdW5zcGVuZGFibGUgaWYgbGFyZ2VyIHRoYW4gNTIwIGJ5dGVzJyxcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoYnNjcmlwdC5jb3VudE5vblB1c2hPbmx5T1BzKGRlY29tcGlsZSkgPiAyMDEpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdSZWRlZW0ub3V0cHV0IHVuc3BlbmRhYmxlIHdpdGggbW9yZSB0aGFuIDIwMSBub24tcHVzaCBvcHMnLFxuICAgICAgICAgICk7XG4gICAgICAgIC8vIG1hdGNoIGhhc2ggYWdhaW5zdCBvdGhlciBzb3VyY2VzXG4gICAgICAgIGNvbnN0IGhhc2gyID0gYmNyeXB0by5oYXNoMTYwKHJlZGVlbS5vdXRwdXQpO1xuICAgICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICBlbHNlIGhhc2ggPSBoYXNoMjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRlZW0uaW5wdXQpIHtcbiAgICAgICAgY29uc3QgaGFzSW5wdXQgPSByZWRlZW0uaW5wdXQubGVuZ3RoID4gMDtcbiAgICAgICAgY29uc3QgaGFzV2l0bmVzcyA9IHJlZGVlbS53aXRuZXNzICYmIHJlZGVlbS53aXRuZXNzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghaGFzSW5wdXQgJiYgIWhhc1dpdG5lc3MpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VtcHR5IGlucHV0Jyk7XG4gICAgICAgIGlmIChoYXNJbnB1dCAmJiBoYXNXaXRuZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGFuZCB3aXRuZXNzIHByb3ZpZGVkJyk7XG4gICAgICAgIGlmIChoYXNJbnB1dCkge1xuICAgICAgICAgIGNvbnN0IHJpY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUocmVkZWVtLmlucHV0KTtcbiAgICAgICAgICBpZiAoIWJzY3JpcHQuaXNQdXNoT25seShyaWNodW5rcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb24gcHVzaC1vbmx5IHNjcmlwdFNpZycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgY29uc3QgY2h1bmtzID0gX2NodW5rcygpO1xuICAgICAgaWYgKCFjaHVua3MgfHwgY2h1bmtzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IHRvbyBzaG9ydCcpO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoX3JlZGVlbSgpLm91dHB1dCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGNoZWNrUmVkZWVtKF9yZWRlZW0oKSk7XG4gICAgfVxuICAgIGlmIChhLnJlZGVlbSkge1xuICAgICAgaWYgKGEucmVkZWVtLm5ldHdvcmsgJiYgYS5yZWRlZW0ubmV0d29yayAhPT0gbmV0d29yaylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVkZWVtID0gX3JlZGVlbSgpO1xuICAgICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0ICYmICFhLnJlZGVlbS5vdXRwdXQuZXF1YWxzKHJlZGVlbS5vdXRwdXQpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgbWlzbWF0Y2gnKTtcbiAgICAgICAgaWYgKGEucmVkZWVtLmlucHV0ICYmICFhLnJlZGVlbS5pbnB1dC5lcXVhbHMocmVkZWVtLmlucHV0KSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0uaW5wdXQgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrUmVkZWVtKGEucmVkZWVtKTtcbiAgICB9XG4gICAgaWYgKGEud2l0bmVzcykge1xuICAgICAgaWYgKFxuICAgICAgICBhLnJlZGVlbSAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICEoMCwgdHlwZXNfMS5zdGFja3NFcXVhbCkoYS5yZWRlZW0ud2l0bmVzcywgYS53aXRuZXNzKVxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGFuZCByZWRlZW0ud2l0bmVzcyBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJzaCA9IHAyc2g7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2sh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2tr.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2tr.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2tr = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst ecc_lib_1 = __webpack_require__(/*! ../ecc_lib */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ecc_lib.js\");\nconst bip341_1 = __webpack_require__(/*! ./bip341 */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/bip341.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bech32_1 = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js\");\nconst address_1 = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/address.js\");\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\n/**\n * Creates a Pay-to-Taproot (P2TR) payment object.\n *\n * @param a - The payment object containing the necessary data for P2TR.\n * @param opts - Optional payment options.\n * @returns The P2TR payment object.\n * @throws {TypeError} If the provided data is invalid or insufficient.\n */\nfunction p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      signature: types_1.typeforce.maybe(\n        types_1.typeforce.anyOf(\n          types_1.typeforce.BufferN(64),\n          types_1.typeforce.BufferN(65),\n        ),\n      ),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),\n      redeem: types_1.typeforce.maybe({\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    return (0, address_1.fromBech32)(a.address);\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32_1.bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32_1.bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: script,\n        version: leafVersion,\n      });\n      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return bip341_1.LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion:\n        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = buffer_1.Buffer.concat(\n        [\n          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = buffer_1.Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && !a.signature.equals(witness[0]))\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))\n          throw new TypeError('Internal pubkey mismatch');\n        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = (0, bip341_1.tapleafHash)({\n          output: script,\n          version: leafVersion,\n        });\n        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && !pubkey.equals(outputKey.x))\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2tr = p2tr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ0ci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsOEdBQWE7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsMEdBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQVU7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsNEdBQVk7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsa0hBQVU7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLDhHQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHlGQUFRO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLDRHQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG9CQUFvQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL3AydHIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJ0ciA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgZWNjX2xpYl8xID0gcmVxdWlyZSgnLi4vZWNjX2xpYicpO1xuY29uc3QgYmlwMzQxXzEgPSByZXF1aXJlKCcuL2JpcDM0MScpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKCdiZWNoMzInKTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoJy4uL2FkZHJlc3MnKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgVEFQUk9PVF9XSVRORVNTX1ZFUlNJT04gPSAweDAxO1xuY29uc3QgQU5ORVhfUFJFRklYID0gMHg1MDtcbi8qKlxuICogQ3JlYXRlcyBhIFBheS10by1UYXByb290IChQMlRSKSBwYXltZW50IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSBwYXltZW50IG9iamVjdCBjb250YWluaW5nIHRoZSBuZWNlc3NhcnkgZGF0YSBmb3IgUDJUUi5cbiAqIEBwYXJhbSBvcHRzIC0gT3B0aW9uYWwgcGF5bWVudCBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIFAyVFIgcGF5bWVudCBvYmplY3QuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBwcm92aWRlZCBkYXRhIGlzIGludmFsaWQgb3IgaW5zdWZmaWNpZW50LlxuICovXG5mdW5jdGlvbiBwMnRyKGEsIG9wdHMpIHtcbiAgaWYgKFxuICAgICFhLmFkZHJlc3MgJiZcbiAgICAhYS5vdXRwdXQgJiZcbiAgICAhYS5wdWJrZXkgJiZcbiAgICAhYS5pbnRlcm5hbFB1YmtleSAmJlxuICAgICEoYS53aXRuZXNzICYmIGEud2l0bmVzcy5sZW5ndGggPiAxKVxuICApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDApKSxcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzQpKSxcbiAgICAgIGludGVybmFsUHVia2V5OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDMyKSksXG4gICAgICBoYXNoOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDMyKSksXG4gICAgICBwdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzIpKSxcbiAgICAgIHNpZ25hdHVyZTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFueU9mKFxuICAgICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oNjQpLFxuICAgICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oNjUpLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICAgIHdpdG5lc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICApLFxuICAgICAgc2NyaXB0VHJlZTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS5pc1RhcHRyZWUpLFxuICAgICAgcmVkZWVtOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh7XG4gICAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICAgcmVkZWVtVmVyc2lvbjogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICApLFxuICAgICAgfSksXG4gICAgICByZWRlZW1WZXJzaW9uOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5OdW1iZXIpLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgY29uc3QgX2FkZHJlc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICByZXR1cm4gKDAsIGFkZHJlc3NfMS5mcm9tQmVjaDMyKShhLmFkZHJlc3MpO1xuICB9KTtcbiAgLy8gcmVtb3ZlIGFubmV4IGlmIHByZXNlbnQsIGlnbm9yZWQgYnkgdGFwcm9vdFxuICBjb25zdCBfd2l0bmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGlmICghYS53aXRuZXNzIHx8ICFhLndpdG5lc3MubGVuZ3RoKSByZXR1cm47XG4gICAgaWYgKFxuICAgICAgYS53aXRuZXNzLmxlbmd0aCA+PSAyICYmXG4gICAgICBhLndpdG5lc3NbYS53aXRuZXNzLmxlbmd0aCAtIDFdWzBdID09PSBBTk5FWF9QUkVGSVhcbiAgICApIHtcbiAgICAgIHJldHVybiBhLndpdG5lc3Muc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gYS53aXRuZXNzLnNsaWNlKCk7XG4gIH0pO1xuICBjb25zdCBfaGFzaFRyZWUgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICBpZiAoYS5zY3JpcHRUcmVlKSByZXR1cm4gKDAsIGJpcDM0MV8xLnRvSGFzaFRyZWUpKGEuc2NyaXB0VHJlZSk7XG4gICAgaWYgKGEuaGFzaCkgcmV0dXJuIHsgaGFzaDogYS5oYXNoIH07XG4gICAgcmV0dXJuO1xuICB9KTtcbiAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIGNvbnN0IG8gPSB7IG5hbWU6ICdwMnRyJywgbmV0d29yayB9O1xuICBsYXp5LnByb3AobywgJ2FkZHJlc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLnB1YmtleSkgcmV0dXJuO1xuICAgIGNvbnN0IHdvcmRzID0gYmVjaDMyXzEuYmVjaDMybS50b1dvcmRzKG8ucHVia2V5KTtcbiAgICB3b3Jkcy51bnNoaWZ0KFRBUFJPT1RfV0lUTkVTU19WRVJTSU9OKTtcbiAgICByZXR1cm4gYmVjaDMyXzEuYmVjaDMybS5lbmNvZGUobmV0d29yay5iZWNoMzIsIHdvcmRzKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaGFzaCcsICgpID0+IHtcbiAgICBjb25zdCBoYXNoVHJlZSA9IF9oYXNoVHJlZSgpO1xuICAgIGlmIChoYXNoVHJlZSkgcmV0dXJuIGhhc2hUcmVlLmhhc2g7XG4gICAgY29uc3QgdyA9IF93aXRuZXNzKCk7XG4gICAgaWYgKHcgJiYgdy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBjb250cm9sQmxvY2sgPSB3W3cubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBsZWFmVmVyc2lvbiA9IGNvbnRyb2xCbG9ja1swXSAmIHR5cGVzXzEuVEFQTEVBRl9WRVJTSU9OX01BU0s7XG4gICAgICBjb25zdCBzY3JpcHQgPSB3W3cubGVuZ3RoIC0gMl07XG4gICAgICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgICAgICBvdXRwdXQ6IHNjcmlwdCxcbiAgICAgICAgdmVyc2lvbjogbGVhZlZlcnNpb24sXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoMCwgYmlwMzQxXzEucm9vdEhhc2hGcm9tUGF0aCkoY29udHJvbEJsb2NrLCBsZWFmSGFzaCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLnB1YmtleSkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8xLCBvLnB1YmtleV0pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdyZWRlZW1WZXJzaW9uJywgKCkgPT4ge1xuICAgIGlmIChhLnJlZGVlbVZlcnNpb24pIHJldHVybiBhLnJlZGVlbVZlcnNpb247XG4gICAgaWYgKFxuICAgICAgYS5yZWRlZW0gJiZcbiAgICAgIGEucmVkZWVtLnJlZGVlbVZlcnNpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgYS5yZWRlZW0ucmVkZWVtVmVyc2lvbiAhPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuIGEucmVkZWVtLnJlZGVlbVZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiBiaXAzNDFfMS5MRUFGX1ZFUlNJT05fVEFQU0NSSVBUO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdyZWRlZW0nLCAoKSA9PiB7XG4gICAgY29uc3Qgd2l0bmVzcyA9IF93aXRuZXNzKCk7IC8vIHdpdG5lc3Mgd2l0aG91dCBhbm5leFxuICAgIGlmICghd2l0bmVzcyB8fCB3aXRuZXNzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0OiB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMl0sXG4gICAgICB3aXRuZXNzOiB3aXRuZXNzLnNsaWNlKDAsIC0yKSxcbiAgICAgIHJlZGVlbVZlcnNpb246XG4gICAgICAgIHdpdG5lc3Nbd2l0bmVzcy5sZW5ndGggLSAxXVswXSAmIHR5cGVzXzEuVEFQTEVBRl9WRVJTSU9OX01BU0ssXG4gICAgfTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncHVia2V5JywgKCkgPT4ge1xuICAgIGlmIChhLnB1YmtleSkgcmV0dXJuIGEucHVia2V5O1xuICAgIGlmIChhLm91dHB1dCkgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDIpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmRhdGE7XG4gICAgaWYgKG8uaW50ZXJuYWxQdWJrZXkpIHtcbiAgICAgIGNvbnN0IHR3ZWFrZWRLZXkgPSAoMCwgYmlwMzQxXzEudHdlYWtLZXkpKG8uaW50ZXJuYWxQdWJrZXksIG8uaGFzaCk7XG4gICAgICBpZiAodHdlYWtlZEtleSkgcmV0dXJuIHR3ZWFrZWRLZXkueDtcbiAgICB9XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2ludGVybmFsUHVia2V5JywgKCkgPT4ge1xuICAgIGlmIChhLmludGVybmFsUHVia2V5KSByZXR1cm4gYS5pbnRlcm5hbFB1YmtleTtcbiAgICBjb25zdCB3aXRuZXNzID0gX3dpdG5lc3MoKTtcbiAgICBpZiAod2l0bmVzcyAmJiB3aXRuZXNzLmxlbmd0aCA+IDEpXG4gICAgICByZXR1cm4gd2l0bmVzc1t3aXRuZXNzLmxlbmd0aCAtIDFdLnNsaWNlKDEsIDMzKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnc2lnbmF0dXJlJywgKCkgPT4ge1xuICAgIGlmIChhLnNpZ25hdHVyZSkgcmV0dXJuIGEuc2lnbmF0dXJlO1xuICAgIGNvbnN0IHdpdG5lc3MgPSBfd2l0bmVzcygpOyAvLyB3aXRuZXNzIHdpdGhvdXQgYW5uZXhcbiAgICBpZiAoIXdpdG5lc3MgfHwgd2l0bmVzcy5sZW5ndGggIT09IDEpIHJldHVybjtcbiAgICByZXR1cm4gd2l0bmVzc1swXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICBpZiAoYS53aXRuZXNzKSByZXR1cm4gYS53aXRuZXNzO1xuICAgIGNvbnN0IGhhc2hUcmVlID0gX2hhc2hUcmVlKCk7XG4gICAgaWYgKGhhc2hUcmVlICYmIGEucmVkZWVtICYmIGEucmVkZWVtLm91dHB1dCAmJiBhLmludGVybmFsUHVia2V5KSB7XG4gICAgICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgICAgICBvdXRwdXQ6IGEucmVkZWVtLm91dHB1dCxcbiAgICAgICAgdmVyc2lvbjogby5yZWRlZW1WZXJzaW9uLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYXRoID0gKDAsIGJpcDM0MV8xLmZpbmRTY3JpcHRQYXRoKShoYXNoVHJlZSwgbGVhZkhhc2gpO1xuICAgICAgaWYgKCFwYXRoKSByZXR1cm47XG4gICAgICBjb25zdCBvdXRwdXRLZXkgPSAoMCwgYmlwMzQxXzEudHdlYWtLZXkpKGEuaW50ZXJuYWxQdWJrZXksIGhhc2hUcmVlLmhhc2gpO1xuICAgICAgaWYgKCFvdXRwdXRLZXkpIHJldHVybjtcbiAgICAgIGNvbnN0IGNvbnRyb2xCb2NrID0gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChcbiAgICAgICAgW1xuICAgICAgICAgIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtvLnJlZGVlbVZlcnNpb24gfCBvdXRwdXRLZXkucGFyaXR5XSksXG4gICAgICAgICAgYS5pbnRlcm5hbFB1YmtleSxcbiAgICAgICAgXS5jb25jYXQocGF0aCksXG4gICAgICApO1xuICAgICAgcmV0dXJuIFthLnJlZGVlbS5vdXRwdXQsIGNvbnRyb2xCb2NrXTtcbiAgICB9XG4gICAgaWYgKGEuc2lnbmF0dXJlKSByZXR1cm4gW2Euc2lnbmF0dXJlXTtcbiAgfSk7XG4gIC8vIGV4dGVuZGVkIHZhbGlkYXRpb25cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBsZXQgcHVia2V5ID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oW10pO1xuICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgIGlmIChuZXR3b3JrICYmIG5ldHdvcmsuYmVjaDMyICE9PSBfYWRkcmVzcygpLnByZWZpeClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcmVmaXggb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gVEFQUk9PVF9XSVRORVNTX1ZFUlNJT04pXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyB2ZXJzaW9uJyk7XG4gICAgICBpZiAoX2FkZHJlc3MoKS5kYXRhLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyBkYXRhJyk7XG4gICAgICBwdWJrZXkgPSBfYWRkcmVzcygpLmRhdGE7XG4gICAgfVxuICAgIGlmIChhLnB1YmtleSkge1xuICAgICAgaWYgKHB1YmtleS5sZW5ndGggPiAwICYmICFwdWJrZXkuZXF1YWxzKGEucHVia2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IG1pc21hdGNoJyk7XG4gICAgICBlbHNlIHB1YmtleSA9IGEucHVia2V5O1xuICAgIH1cbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYS5vdXRwdXQubGVuZ3RoICE9PSAzNCB8fFxuICAgICAgICBhLm91dHB1dFswXSAhPT0gT1BTLk9QXzEgfHxcbiAgICAgICAgYS5vdXRwdXRbMV0gIT09IDB4MjBcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoID4gMCAmJiAhcHVia2V5LmVxdWFscyhhLm91dHB1dC5zbGljZSgyKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBwdWJrZXkgPSBhLm91dHB1dC5zbGljZSgyKTtcbiAgICB9XG4gICAgaWYgKGEuaW50ZXJuYWxQdWJrZXkpIHtcbiAgICAgIGNvbnN0IHR3ZWFrZWRLZXkgPSAoMCwgYmlwMzQxXzEudHdlYWtLZXkpKGEuaW50ZXJuYWxQdWJrZXksIG8uaGFzaCk7XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCA+IDAgJiYgIXB1YmtleS5lcXVhbHModHdlYWtlZEtleS54KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IG1pc21hdGNoJyk7XG4gICAgICBlbHNlIHB1YmtleSA9IHR3ZWFrZWRLZXkueDtcbiAgICB9XG4gICAgaWYgKHB1YmtleSAmJiBwdWJrZXkubGVuZ3RoKSB7XG4gICAgICBpZiAoISgwLCBlY2NfbGliXzEuZ2V0RWNjTGliKSgpLmlzWE9ubHlQb2ludChwdWJrZXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHB1YmtleSBmb3IgcDJ0cicpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoVHJlZSA9IF9oYXNoVHJlZSgpO1xuICAgIGlmIChhLmhhc2ggJiYgaGFzaFRyZWUpIHtcbiAgICAgIGlmICghYS5oYXNoLmVxdWFscyhoYXNoVHJlZS5oYXNoKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICBpZiAoYS5yZWRlZW0gJiYgYS5yZWRlZW0ub3V0cHV0ICYmIGhhc2hUcmVlKSB7XG4gICAgICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgICAgICBvdXRwdXQ6IGEucmVkZWVtLm91dHB1dCxcbiAgICAgICAgdmVyc2lvbjogby5yZWRlZW1WZXJzaW9uLFxuICAgICAgfSk7XG4gICAgICBpZiAoISgwLCBiaXAzNDFfMS5maW5kU2NyaXB0UGF0aCkoaGFzaFRyZWUsIGxlYWZIYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtIHNjcmlwdCBub3QgaW4gdHJlZScpO1xuICAgIH1cbiAgICBjb25zdCB3aXRuZXNzID0gX3dpdG5lc3MoKTtcbiAgICAvLyBjb21wYXJlIHRoZSBwcm92aWRlZCByZWRlZW0gZGF0YSB3aXRoIHRoZSBvbmUgY29tcHV0ZWQgZnJvbSB3aXRuZXNzXG4gICAgaWYgKGEucmVkZWVtICYmIG8ucmVkZWVtKSB7XG4gICAgICBpZiAoYS5yZWRlZW0ucmVkZWVtVmVyc2lvbikge1xuICAgICAgICBpZiAoYS5yZWRlZW0ucmVkZWVtVmVyc2lvbiAhPT0gby5yZWRlZW0ucmVkZWVtVmVyc2lvbilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0ucmVkZWVtVmVyc2lvbiBhbmQgd2l0bmVzcyBtaXNtYXRjaCcpO1xuICAgICAgfVxuICAgICAgaWYgKGEucmVkZWVtLm91dHB1dCkge1xuICAgICAgICBpZiAoYnNjcmlwdC5kZWNvbXBpbGUoYS5yZWRlZW0ub3V0cHV0KS5sZW5ndGggPT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLm91dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICAgIC8vIG91dHB1dCByZWRlZW0gaXMgY29uc3RydWN0ZWQgZnJvbSB0aGUgd2l0bmVzc1xuICAgICAgICBpZiAoby5yZWRlZW0ub3V0cHV0ICYmICFhLnJlZGVlbS5vdXRwdXQuZXF1YWxzKG8ucmVkZWVtLm91dHB1dCkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLm91dHB1dCBhbmQgd2l0bmVzcyBtaXNtYXRjaCcpO1xuICAgICAgfVxuICAgICAgaWYgKGEucmVkZWVtLndpdG5lc3MpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG8ucmVkZWVtLndpdG5lc3MgJiZcbiAgICAgICAgICAhKDAsIHR5cGVzXzEuc3RhY2tzRXF1YWwpKGEucmVkZWVtLndpdG5lc3MsIG8ucmVkZWVtLndpdG5lc3MpXG4gICAgICAgIClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0ud2l0bmVzcyBhbmQgd2l0bmVzcyBtaXNtYXRjaCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2l0bmVzcyAmJiB3aXRuZXNzLmxlbmd0aCkge1xuICAgICAgaWYgKHdpdG5lc3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGtleSBzcGVuZGluZ1xuICAgICAgICBpZiAoYS5zaWduYXR1cmUgJiYgIWEuc2lnbmF0dXJlLmVxdWFscyh3aXRuZXNzWzBdKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaWduYXR1cmUgbWlzbWF0Y2gnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNjcmlwdCBwYXRoIHNwZW5kaW5nXG4gICAgICAgIGNvbnN0IGNvbnRyb2xCbG9jayA9IHdpdG5lc3Nbd2l0bmVzcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGNvbnRyb2xCbG9jay5sZW5ndGggPCAzMylcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYFRoZSBjb250cm9sLWJsb2NrIGxlbmd0aCBpcyB0b28gc21hbGwuIEdvdCAke2NvbnRyb2xCbG9jay5sZW5ndGh9LCBleHBlY3RlZCBtaW4gMzMuYCxcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoKGNvbnRyb2xCbG9jay5sZW5ndGggLSAzMykgJSAzMiAhPT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYFRoZSBjb250cm9sLWJsb2NrIGxlbmd0aCBvZiAke2NvbnRyb2xCbG9jay5sZW5ndGh9IGlzIGluY29ycmVjdCFgLFxuICAgICAgICAgICk7XG4gICAgICAgIGNvbnN0IG0gPSAoY29udHJvbEJsb2NrLmxlbmd0aCAtIDMzKSAvIDMyO1xuICAgICAgICBpZiAobSA+IDEyOClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYFRoZSBzY3JpcHQgcGF0aCBpcyB0b28gbG9uZy4gR290ICR7bX0sIGV4cGVjdGVkIG1heCAxMjguYCxcbiAgICAgICAgICApO1xuICAgICAgICBjb25zdCBpbnRlcm5hbFB1YmtleSA9IGNvbnRyb2xCbG9jay5zbGljZSgxLCAzMyk7XG4gICAgICAgIGlmIChhLmludGVybmFsUHVia2V5ICYmICFhLmludGVybmFsUHVia2V5LmVxdWFscyhpbnRlcm5hbFB1YmtleSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW50ZXJuYWwgcHVia2V5IG1pc21hdGNoJyk7XG4gICAgICAgIGlmICghKDAsIGVjY19saWJfMS5nZXRFY2NMaWIpKCkuaXNYT25seVBvaW50KGludGVybmFsUHVia2V5KSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGludGVybmFsUHVia2V5IGZvciBwMnRyIHdpdG5lc3MnKTtcbiAgICAgICAgY29uc3QgbGVhZlZlcnNpb24gPSBjb250cm9sQmxvY2tbMF0gJiB0eXBlc18xLlRBUExFQUZfVkVSU0lPTl9NQVNLO1xuICAgICAgICBjb25zdCBzY3JpcHQgPSB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMl07XG4gICAgICAgIGNvbnN0IGxlYWZIYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7XG4gICAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgICAgdmVyc2lvbjogbGVhZlZlcnNpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNoID0gKDAsIGJpcDM0MV8xLnJvb3RIYXNoRnJvbVBhdGgpKGNvbnRyb2xCbG9jaywgbGVhZkhhc2gpO1xuICAgICAgICBjb25zdCBvdXRwdXRLZXkgPSAoMCwgYmlwMzQxXzEudHdlYWtLZXkpKGludGVybmFsUHVia2V5LCBoYXNoKTtcbiAgICAgICAgaWYgKCFvdXRwdXRLZXkpXG4gICAgICAgICAgLy8gdG9kbzogbmVlZHMgdGVzdCBkYXRhXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBvdXRwdXRLZXkgZm9yIHAydHIgd2l0bmVzcycpO1xuICAgICAgICBpZiAocHVia2V5Lmxlbmd0aCAmJiAhcHVia2V5LmVxdWFscyhvdXRwdXRLZXkueCkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IG1pc21hdGNoIGZvciBwMnRyIHdpdG5lc3MnKTtcbiAgICAgICAgaWYgKG91dHB1dEtleS5wYXJpdHkgIT09IChjb250cm9sQmxvY2tbMF0gJiAxKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXJpdHknKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAydHIgPSBwMnRyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2tr.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2wpkh = void 0;\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bech32_1 = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js\");\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n/**\n * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The p2wpkh payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ3cGtoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxnQkFBZ0IsbUJBQU8sQ0FBQywwR0FBVztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyw4R0FBYTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQywwR0FBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBVTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsOEdBQVE7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMseUZBQVE7QUFDakM7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL3Ayd3BraC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMndwa2ggPSB2b2lkIDA7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKCdiZWNoMzInKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuLy8gd2l0bmVzczoge3NpZ25hdHVyZX0ge3B1YktleX1cbi8vIGlucHV0OiA8PlxuLy8gb3V0cHV0OiBPUF8wIHtwdWJLZXlIYXNofVxuLyoqXG4gKiBDcmVhdGVzIGEgcGF5LXRvLXdpdG5lc3MtcHVibGljLWtleS1oYXNoIChwMndwa2gpIHBheW1lbnQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhIC0gVGhlIHBheW1lbnQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBkYXRhLlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBwYXltZW50IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgcDJ3cGtoIHBheW1lbnQgb2JqZWN0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgcmVxdWlyZWQgZGF0YSBpcyBtaXNzaW5nIG9yIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHAyd3BraChhLCBvcHRzKSB7XG4gIGlmICghYS5hZGRyZXNzICYmICFhLmhhc2ggJiYgIWEub3V0cHV0ICYmICFhLnB1YmtleSAmJiAhYS53aXRuZXNzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIGFkZHJlc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLlN0cmluZyksXG4gICAgICBoYXNoOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDIwKSksXG4gICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigwKSksXG4gICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDIyKSksXG4gICAgICBwdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEuaXNQb2ludCksXG4gICAgICBzaWduYXR1cmU6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUpLFxuICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGJlY2gzMl8xLmJlY2gzMi5kZWNvZGUoYS5hZGRyZXNzKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gcmVzdWx0LndvcmRzLnNoaWZ0KCk7XG4gICAgY29uc3QgZGF0YSA9IGJlY2gzMl8xLmJlY2gzMi5mcm9tV29yZHMocmVzdWx0LndvcmRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbixcbiAgICAgIHByZWZpeDogcmVzdWx0LnByZWZpeCxcbiAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGRhdGEpLFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBuZXR3b3JrID0gYS5uZXR3b3JrIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgY29uc3QgbyA9IHsgbmFtZTogJ3Ayd3BraCcsIG5ldHdvcmsgfTtcbiAgbGF6eS5wcm9wKG8sICdhZGRyZXNzJywgKCkgPT4ge1xuICAgIGlmICghby5oYXNoKSByZXR1cm47XG4gICAgY29uc3Qgd29yZHMgPSBiZWNoMzJfMS5iZWNoMzIudG9Xb3JkcyhvLmhhc2gpO1xuICAgIHdvcmRzLnVuc2hpZnQoMHgwMCk7XG4gICAgcmV0dXJuIGJlY2gzMl8xLmJlY2gzMi5lbmNvZGUobmV0d29yay5iZWNoMzIsIHdvcmRzKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaGFzaCcsICgpID0+IHtcbiAgICBpZiAoYS5vdXRwdXQpIHJldHVybiBhLm91dHB1dC5zbGljZSgyLCAyMik7XG4gICAgaWYgKGEuYWRkcmVzcykgcmV0dXJuIF9hZGRyZXNzKCkuZGF0YTtcbiAgICBpZiAoYS5wdWJrZXkgfHwgby5wdWJrZXkpIHJldHVybiBiY3J5cHRvLmhhc2gxNjAoYS5wdWJrZXkgfHwgby5wdWJrZXkpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfMCwgby5oYXNoXSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3B1YmtleScsICgpID0+IHtcbiAgICBpZiAoYS5wdWJrZXkpIHJldHVybiBhLnB1YmtleTtcbiAgICBpZiAoIWEud2l0bmVzcykgcmV0dXJuO1xuICAgIHJldHVybiBhLndpdG5lc3NbMV07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3NpZ25hdHVyZScsICgpID0+IHtcbiAgICBpZiAoIWEud2l0bmVzcykgcmV0dXJuO1xuICAgIHJldHVybiBhLndpdG5lc3NbMF07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2lucHV0JywgKCkgPT4ge1xuICAgIGlmICghby53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICBpZiAoIWEucHVia2V5KSByZXR1cm47XG4gICAgaWYgKCFhLnNpZ25hdHVyZSkgcmV0dXJuO1xuICAgIHJldHVybiBbYS5zaWduYXR1cmUsIGEucHVia2V5XTtcbiAgfSk7XG4gIC8vIGV4dGVuZGVkIHZhbGlkYXRpb25cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBsZXQgaGFzaCA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICBpZiAoYS5hZGRyZXNzKSB7XG4gICAgICBpZiAobmV0d29yayAmJiBuZXR3b3JrLmJlY2gzMiAhPT0gX2FkZHJlc3MoKS5wcmVmaXgpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJlZml4IG9yIE5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLnZlcnNpb24gIT09IDB4MDApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyB2ZXJzaW9uJyk7XG4gICAgICBpZiAoX2FkZHJlc3MoKS5kYXRhLmxlbmd0aCAhPT0gMjApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyBkYXRhJyk7XG4gICAgICBoYXNoID0gX2FkZHJlc3MoKS5kYXRhO1xuICAgIH1cbiAgICBpZiAoYS5oYXNoKSB7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBhLmhhc2g7XG4gICAgfVxuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgaWYgKFxuICAgICAgICBhLm91dHB1dC5sZW5ndGggIT09IDIyIHx8XG4gICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfMCB8fFxuICAgICAgICBhLm91dHB1dFsxXSAhPT0gMHgxNFxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoYS5vdXRwdXQuc2xpY2UoMikpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBhLm91dHB1dC5zbGljZSgyKTtcbiAgICB9XG4gICAgaWYgKGEucHVia2V5KSB7XG4gICAgICBjb25zdCBwa2ggPSBiY3J5cHRvLmhhc2gxNjAoYS5wdWJrZXkpO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gcGtoO1xuICAgICAgaWYgKCEoMCwgdHlwZXNfMS5pc1BvaW50KShhLnB1YmtleSkgfHwgYS5wdWJrZXkubGVuZ3RoICE9PSAzMylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwdWJrZXkgZm9yIHAyd3BraCcpO1xuICAgIH1cbiAgICBpZiAoYS53aXRuZXNzKSB7XG4gICAgICBpZiAoYS53aXRuZXNzLmxlbmd0aCAhPT0gMikgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIWJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoYS53aXRuZXNzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBoYXMgaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgIGlmICghKDAsIHR5cGVzXzEuaXNQb2ludCkoYS53aXRuZXNzWzFdKSB8fCBhLndpdG5lc3NbMV0ubGVuZ3RoICE9PSAzMylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBoYXMgaW52YWxpZCBwdWJrZXknKTtcbiAgICAgIGlmIChhLnNpZ25hdHVyZSAmJiAhYS5zaWduYXR1cmUuZXF1YWxzKGEud2l0bmVzc1swXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEucHVia2V5ICYmICFhLnB1YmtleS5lcXVhbHMoYS53aXRuZXNzWzFdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHVia2V5IG1pc21hdGNoJyk7XG4gICAgICBjb25zdCBwa2ggPSBiY3J5cHRvLmhhc2gxNjAoYS53aXRuZXNzWzFdKTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKHBraCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAyd3BraCA9IHAyd3BraDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wpkh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wsh.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wsh.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2wsh = void 0;\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bech32_1 = __webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js\");\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    (0, types_1.isPoint)(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\n/**\n * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2WSH payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      redeem: types_1.typeforce.maybe({\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty/valid?\n      if (a.redeem.output) {\n        const decompile = bscript.decompile(a.redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output is invalid');\n        if (a.redeem.output.byteLength > 3600)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 3600 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ3c2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLDBHQUFXO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLDhHQUFhO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDBHQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFVO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyw4R0FBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL3Ayd3NoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAyd3NoID0gdm9pZCAwO1xuY29uc3QgYmNyeXB0byA9IHJlcXVpcmUoJy4uL2NyeXB0bycpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IGJlY2gzMl8xID0gcmVxdWlyZSgnYmVjaDMyJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5hbGxvYygwKTtcbmZ1bmN0aW9uIGNodW5rSGFzVW5jb21wcmVzc2VkUHVia2V5KGNodW5rKSB7XG4gIGlmIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgY2h1bmsubGVuZ3RoID09PSA2NSAmJlxuICAgIGNodW5rWzBdID09PSAweDA0ICYmXG4gICAgKDAsIHR5cGVzXzEuaXNQb2ludCkoY2h1bmspXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLy8gaW5wdXQ6IDw+XG4vLyB3aXRuZXNzOiBbcmVkZWVtU2NyaXB0U2lnIC4uLl0ge3JlZGVlbVNjcmlwdH1cbi8vIG91dHB1dDogT1BfMCB7c2hhMjU2KHJlZGVlbVNjcmlwdCl9XG4vKipcbiAqIENyZWF0ZXMgYSBQYXktdG8tV2l0bmVzcy1TY3JpcHQtSGFzaCAoUDJXU0gpIHBheW1lbnQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhIC0gVGhlIHBheW1lbnQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBkYXRhLlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBwYXltZW50IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUDJXU0ggcGF5bWVudCBvYmplY3QuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSByZXF1aXJlZCBkYXRhIGlzIG1pc3Npbmcgb3IgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gcDJ3c2goYSwgb3B0cykge1xuICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5yZWRlZW0gJiYgIWEud2l0bmVzcylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKShcbiAgICB7XG4gICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgYWRkcmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuU3RyaW5nKSxcbiAgICAgIGhhc2g6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMzIpKSxcbiAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigzNCkpLFxuICAgICAgcmVkZWVtOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh7XG4gICAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIHdpdG5lc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICAgKSxcbiAgICAgIH0pLFxuICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMCkpLFxuICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IGJlY2gzMl8xLmJlY2gzMi5kZWNvZGUoYS5hZGRyZXNzKTtcbiAgICBjb25zdCB2ZXJzaW9uID0gcmVzdWx0LndvcmRzLnNoaWZ0KCk7XG4gICAgY29uc3QgZGF0YSA9IGJlY2gzMl8xLmJlY2gzMi5mcm9tV29yZHMocmVzdWx0LndvcmRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbixcbiAgICAgIHByZWZpeDogcmVzdWx0LnByZWZpeCxcbiAgICAgIGRhdGE6IEJ1ZmZlci5mcm9tKGRhdGEpLFxuICAgIH07XG4gIH0pO1xuICBjb25zdCBfcmNodW5rcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLnJlZGVlbS5pbnB1dCk7XG4gIH0pO1xuICBsZXQgbmV0d29yayA9IGEubmV0d29yaztcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IChhLnJlZGVlbSAmJiBhLnJlZGVlbS5uZXR3b3JrKSB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIH1cbiAgY29uc3QgbyA9IHsgbmV0d29yayB9O1xuICBsYXp5LnByb3AobywgJ2FkZHJlc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMi50b1dvcmRzKG8uaGFzaCk7XG4gICAgd29yZHMudW5zaGlmdCgweDAwKTtcbiAgICByZXR1cm4gYmVjaDMyXzEuYmVjaDMyLmVuY29kZShuZXR3b3JrLmJlY2gzMiwgd29yZHMpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdoYXNoJywgKCkgPT4ge1xuICAgIGlmIChhLm91dHB1dCkgcmV0dXJuIGEub3V0cHV0LnNsaWNlKDIpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmRhdGE7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLm91dHB1dCkgcmV0dXJuIGJjcnlwdG8uc2hhMjU2KG8ucmVkZWVtLm91dHB1dCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ291dHB1dCcsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW09QUy5PUF8wLCBvLmhhc2hdKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncmVkZWVtJywgKCkgPT4ge1xuICAgIGlmICghYS53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogYS53aXRuZXNzW2Eud2l0bmVzcy5sZW5ndGggLSAxXSxcbiAgICAgIGlucHV0OiBFTVBUWV9CVUZGRVIsXG4gICAgICB3aXRuZXNzOiBhLndpdG5lc3Muc2xpY2UoMCwgLTEpLFxuICAgIH07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2lucHV0JywgKCkgPT4ge1xuICAgIGlmICghby53aXRuZXNzKSByZXR1cm47XG4gICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICAvLyB0cmFuc2Zvcm0gcmVkZWVtIGlucHV0IHRvIHdpdG5lc3Mgc3RhY2s/XG4gICAgaWYgKFxuICAgICAgYS5yZWRlZW0gJiZcbiAgICAgIGEucmVkZWVtLmlucHV0ICYmXG4gICAgICBhLnJlZGVlbS5pbnB1dC5sZW5ndGggPiAwICYmXG4gICAgICBhLnJlZGVlbS5vdXRwdXQgJiZcbiAgICAgIGEucmVkZWVtLm91dHB1dC5sZW5ndGggPiAwXG4gICAgKSB7XG4gICAgICBjb25zdCBzdGFjayA9IGJzY3JpcHQudG9TdGFjayhfcmNodW5rcygpKTtcbiAgICAgIC8vIGFzc2lnbiwgYW5kIGJsYW5rIHRoZSBleGlzdGluZyBpbnB1dFxuICAgICAgby5yZWRlZW0gPSBPYmplY3QuYXNzaWduKHsgd2l0bmVzczogc3RhY2sgfSwgYS5yZWRlZW0pO1xuICAgICAgby5yZWRlZW0uaW5wdXQgPSBFTVBUWV9CVUZGRVI7XG4gICAgICByZXR1cm4gW10uY29uY2F0KHN0YWNrLCBhLnJlZGVlbS5vdXRwdXQpO1xuICAgIH1cbiAgICBpZiAoIWEucmVkZWVtKSByZXR1cm47XG4gICAgaWYgKCFhLnJlZGVlbS5vdXRwdXQpIHJldHVybjtcbiAgICBpZiAoIWEucmVkZWVtLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4gW10uY29uY2F0KGEucmVkZWVtLndpdG5lc3MsIGEucmVkZWVtLm91dHB1dCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ25hbWUnLCAoKSA9PiB7XG4gICAgY29uc3QgbmFtZVBhcnRzID0gWydwMndzaCddO1xuICAgIGlmIChvLnJlZGVlbSAhPT0gdW5kZWZpbmVkICYmIG8ucmVkZWVtLm5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgIG5hbWVQYXJ0cy5wdXNoKG8ucmVkZWVtLm5hbWUpO1xuICAgIHJldHVybiBuYW1lUGFydHMuam9pbignLScpO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgIGlmIChfYWRkcmVzcygpLnByZWZpeCAhPT0gbmV0d29yay5iZWNoMzIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJlZml4IG9yIE5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLnZlcnNpb24gIT09IDB4MDApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyB2ZXJzaW9uJyk7XG4gICAgICBpZiAoX2FkZHJlc3MoKS5kYXRhLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYWRkcmVzcyBkYXRhJyk7XG4gICAgICBoYXNoID0gX2FkZHJlc3MoKS5kYXRhO1xuICAgIH1cbiAgICBpZiAoYS5oYXNoKSB7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBhLmhhc2g7XG4gICAgfVxuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgaWYgKFxuICAgICAgICBhLm91dHB1dC5sZW5ndGggIT09IDM0IHx8XG4gICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfMCB8fFxuICAgICAgICBhLm91dHB1dFsxXSAhPT0gMHgyMFxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgY29uc3QgaGFzaDIgPSBhLm91dHB1dC5zbGljZSgyKTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGhhc2gyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gaGFzaDI7XG4gICAgfVxuICAgIGlmIChhLnJlZGVlbSkge1xuICAgICAgaWYgKGEucmVkZWVtLm5ldHdvcmsgJiYgYS5yZWRlZW0ubmV0d29yayAhPT0gbmV0d29yaylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgLy8gaXMgdGhlcmUgdHdvIHJlZGVlbSBzb3VyY2VzP1xuICAgICAgaWYgKFxuICAgICAgICBhLnJlZGVlbS5pbnB1dCAmJlxuICAgICAgICBhLnJlZGVlbS5pbnB1dC5sZW5ndGggPiAwICYmXG4gICAgICAgIGEucmVkZWVtLndpdG5lc3MgJiZcbiAgICAgICAgYS5yZWRlZW0ud2l0bmVzcy5sZW5ndGggPiAwXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FtYmlndW91cyB3aXRuZXNzIHNvdXJjZScpO1xuICAgICAgLy8gaXMgdGhlIHJlZGVlbSBvdXRwdXQgbm9uLWVtcHR5L3ZhbGlkP1xuICAgICAgaWYgKGEucmVkZWVtLm91dHB1dCkge1xuICAgICAgICBjb25zdCBkZWNvbXBpbGUgPSBic2NyaXB0LmRlY29tcGlsZShhLnJlZGVlbS5vdXRwdXQpO1xuICAgICAgICBpZiAoIWRlY29tcGlsZSB8fCBkZWNvbXBpbGUubGVuZ3RoIDwgMSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0ub3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgICAgaWYgKGEucmVkZWVtLm91dHB1dC5ieXRlTGVuZ3RoID4gMzYwMClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ1JlZGVlbS5vdXRwdXQgdW5zcGVuZGFibGUgaWYgbGFyZ2VyIHRoYW4gMzYwMCBieXRlcycsXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKGJzY3JpcHQuY291bnROb25QdXNoT25seU9QcyhkZWNvbXBpbGUpID4gMjAxKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnUmVkZWVtLm91dHB1dCB1bnNwZW5kYWJsZSB3aXRoIG1vcmUgdGhhbiAyMDEgbm9uLXB1c2ggb3BzJyxcbiAgICAgICAgICApO1xuICAgICAgICAvLyBtYXRjaCBoYXNoIGFnYWluc3Qgb3RoZXIgc291cmNlc1xuICAgICAgICBjb25zdCBoYXNoMiA9IGJjcnlwdG8uc2hhMjU2KGEucmVkZWVtLm91dHB1dCk7XG4gICAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGhhc2gyKSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICAgIGVsc2UgaGFzaCA9IGhhc2gyO1xuICAgICAgfVxuICAgICAgaWYgKGEucmVkZWVtLmlucHV0ICYmICFic2NyaXB0LmlzUHVzaE9ubHkoX3JjaHVua3MoKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vbiBwdXNoLW9ubHkgc2NyaXB0U2lnJyk7XG4gICAgICBpZiAoXG4gICAgICAgIGEud2l0bmVzcyAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICEoMCwgdHlwZXNfMS5zdGFja3NFcXVhbCkoYS53aXRuZXNzLCBhLnJlZGVlbS53aXRuZXNzKVxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGFuZCByZWRlZW0ud2l0bmVzcyBtaXNtYXRjaCcpO1xuICAgICAgaWYgKFxuICAgICAgICAoYS5yZWRlZW0uaW5wdXQgJiYgX3JjaHVua3MoKS5zb21lKGNodW5rSGFzVW5jb21wcmVzc2VkUHVia2V5KSkgfHxcbiAgICAgICAgKGEucmVkZWVtLm91dHB1dCAmJlxuICAgICAgICAgIChic2NyaXB0LmRlY29tcGlsZShhLnJlZGVlbS5vdXRwdXQpIHx8IFtdKS5zb21lKFxuICAgICAgICAgICAgY2h1bmtIYXNVbmNvbXByZXNzZWRQdWJrZXksXG4gICAgICAgICAgKSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdyZWRlZW0uaW5wdXQgb3IgcmVkZWVtLm91dHB1dCBjb250YWlucyB1bmNvbXByZXNzZWQgcHVia2V5JyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGEud2l0bmVzcyAmJiBhLndpdG5lc3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgd1NjcmlwdCA9IGEud2l0bmVzc1thLndpdG5lc3MubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYS5yZWRlZW0gJiYgYS5yZWRlZW0ub3V0cHV0ICYmICFhLnJlZGVlbS5vdXRwdXQuZXF1YWxzKHdTY3JpcHQpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGFuZCByZWRlZW0ub3V0cHV0IG1pc21hdGNoJyk7XG4gICAgICBpZiAoXG4gICAgICAgIGEud2l0bmVzcy5zb21lKGNodW5rSGFzVW5jb21wcmVzc2VkUHVia2V5KSB8fFxuICAgICAgICAoYnNjcmlwdC5kZWNvbXBpbGUod1NjcmlwdCkgfHwgW10pLnNvbWUoY2h1bmtIYXNVbmNvbXByZXNzZWRQdWJrZXkpXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgY29udGFpbnMgdW5jb21wcmVzc2VkIHB1YmtleScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJ3c2ggPSBwMndzaDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/p2wsh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Psbt = void 0;\nconst bip174_1 = __webpack_require__(/*! bip174 */ \"(ssr)/./node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/psbt.js\");\nconst varuint = __webpack_require__(/*! bip174/src/lib/converter/varint */ \"(ssr)/./node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/varint.js\");\nconst utils_1 = __webpack_require__(/*! bip174/src/lib/utils */ \"(ssr)/./node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/utils.js\");\nconst address_1 = __webpack_require__(/*! ./address */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/address.js\");\nconst bufferutils_1 = __webpack_require__(/*! ./bufferutils */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js\");\nconst networks_1 = __webpack_require__(/*! ./networks */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/networks.js\");\nconst payments = __webpack_require__(/*! ./payments */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js\");\nconst bip341_1 = __webpack_require__(/*! ./payments/bip341 */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/bip341.js\");\nconst bscript = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js\");\nconst bip371_1 = __webpack_require__(/*! ./psbt/bip371 */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/bip371.js\");\nconst psbtutils_1 = __webpack_require__(/*! ./psbt/psbtutils */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/psbtutils.js\");\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n *\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n *\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n *\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n *\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n *\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecessor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: (0, bufferutils_1.cloneBuffer)(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = (0, address_1.fromOutputScript)(\n          output.script,\n          this.opts.network,\n        );\n      } catch (_) {}\n      return {\n        script: (0, bufferutils_1.cloneBuffer)(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = (0, address_1.toOutputScript)(address, network);\n      outputData = Object.assign({}, outputData, { script });\n    }\n    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n        signature: (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return {\n          tapKeySig: (0, bip371_1.serializeTaprootSignature)(\n            sig,\n            input.sighashType,\n          ),\n        };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n                signature: (0, bip371_1.serializeTaprootSignature)(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(\n          'hex',\n        )}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    (0, bip371_1.checkTaprootInputFields)(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    (0, bip371_1.checkTaprootOutputFields)(\n      outputData,\n      updateData,\n      'updateOutput',\n    );\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = (0, bip371_1.isTaprootInput)(input)\n      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)\n      : (0, psbtutils_1.checkInputForSig)(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        p2wsh.witness,\n      );\n    } else {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecessor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(pubicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);\n    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = (0, bip341_1.tapleafHash)({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);\n  const isP2SHP2WSH =\n    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);\n  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (\n    (0, psbtutils_1.isP2WPKH)(script) ||\n    (0, psbtutils_1.isP2SHScript)(script)\n  ) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';\n  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';\n  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';\n  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsMkZBQVE7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsZ0lBQWlDO0FBQ3pELGdCQUFnQixtQkFBTyxDQUFDLDBHQUFzQjtBQUM5QyxrQkFBa0IsbUJBQU8sQ0FBQywyR0FBVztBQUNyQyxzQkFBc0IsbUJBQU8sQ0FBQyxtSEFBZTtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQyw2R0FBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxtSEFBWTtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQywySEFBbUI7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMseUdBQVU7QUFDbEMsc0JBQXNCLG1CQUFPLENBQUMsbUhBQWU7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsbUhBQWU7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMseUhBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLG1DQUFtQyxnQkFBZ0IsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQSxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBLHlEQUF5RCxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RCxNQUFNO0FBQ04sY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFdBQVcsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFdBQVc7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVksZUFBZTtBQUM5RDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFLDBCQUEwQixTQUFTO0FBQ25DLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUSw4QkFBOEIsdUJBQXVCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxtQkFBbUIsTUFBTSxRQUFRLEdBQUcsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlCQUFpQjtBQUNwRSxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxVQUFVLHlCQUF5QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLE1BQU07QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLElBQUk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnRjL21pZGwteC1iaXRjb2luLXN1bW1pdC1oYWNrYXRob24tMjAyNS91dHhvLXBzYnQtZGVtby9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qc2J0ID0gdm9pZCAwO1xuY29uc3QgYmlwMTc0XzEgPSByZXF1aXJlKCdiaXAxNzQnKTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCdiaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvdmFyaW50Jyk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZSgnYmlwMTc0L3NyYy9saWIvdXRpbHMnKTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoJy4vYWRkcmVzcycpO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoJy4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuL25ldHdvcmtzJyk7XG5jb25zdCBwYXltZW50cyA9IHJlcXVpcmUoJy4vcGF5bWVudHMnKTtcbmNvbnN0IGJpcDM0MV8xID0gcmVxdWlyZSgnLi9wYXltZW50cy9iaXAzNDEnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuL3NjcmlwdCcpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoJy4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IGJpcDM3MV8xID0gcmVxdWlyZSgnLi9wc2J0L2JpcDM3MScpO1xuY29uc3QgcHNidHV0aWxzXzEgPSByZXF1aXJlKCcuL3BzYnQvcHNidHV0aWxzJyk7XG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgZGVmYXVsdCBhcmd1bWVudHMgZm9yIGEgUHNidCBpbnN0YW5jZS5cbiAqL1xuY29uc3QgREVGQVVMVF9PUFRTID0ge1xuICAvKipcbiAgICogQSBiaXRjb2luanMgTmV0d29yayBvYmplY3QuIFRoaXMgaXMgb25seSB1c2VkIGlmIHlvdSBwYXNzIGFuIGBhZGRyZXNzYFxuICAgKiBwYXJhbWV0ZXIgdG8gYWRkT3V0cHV0LiBPdGhlcndpc2UgaXQgaXMgbm90IG5lZWRlZCBhbmQgY2FuIGJlIGxlZnQgZGVmYXVsdC5cbiAgICovXG4gIG5ldHdvcms6IG5ldHdvcmtzXzEuYml0Y29pbixcbiAgLyoqXG4gICAqIFdoZW4gZXh0cmFjdFRyYW5zYWN0aW9uIGlzIGNhbGxlZCwgdGhlIGZlZSByYXRlIGlzIGNoZWNrZWQuXG4gICAqIFRISVMgSVMgTk9UIFRPIEJFIFJFTElFRCBPTi5cbiAgICogSXQgaXMgb25seSBoZXJlIGFzIGEgbGFzdCBkaXRjaCBlZmZvcnQgdG8gcHJldmVudCBzZW5kaW5nIGEgNTAwIEJUQyBmZWUgZXRjLlxuICAgKi9cbiAgbWF4aW11bUZlZVJhdGU6IDUwMDAsIC8vIHNhdG9zaGkgcGVyIGJ5dGVcbn07XG4vKipcbiAqIFBzYnQgY2xhc3MgY2FuIHBhcnNlIGFuZCBnZW5lcmF0ZSBhIFBTQlQgYmluYXJ5IGJhc2VkIG9mZiBvZiB0aGUgQklQMTc0LlxuICogVGhlcmUgYXJlIDYgcm9sZXMgdGhhdCB0aGlzIGNsYXNzIGZ1bGZpbGxzLiAoRXhwbGFpbmVkIGluIEJJUDE3NClcbiAqXG4gKiBDcmVhdG9yOiBUaGlzIGNhbiBiZSBkb25lIHdpdGggYG5ldyBQc2J0KClgXG4gKlxuICogVXBkYXRlcjogVGhpcyBjYW4gYmUgZG9uZSB3aXRoIGBwc2J0LmFkZElucHV0KGlucHV0KWAsIGBwc2J0LmFkZElucHV0cyhpbnB1dHMpYCxcbiAqICAgYHBzYnQuYWRkT3V0cHV0KG91dHB1dClgLCBgcHNidC5hZGRPdXRwdXRzKG91dHB1dHMpYCB3aGVuIHlvdSBhcmUgbG9va2luZyB0b1xuICogICBhZGQgbmV3IGlucHV0cyBhbmQgb3V0cHV0cyB0byB0aGUgUFNCVCwgYW5kIGBwc2J0LnVwZGF0ZUdsb2JhbChpdGVtT2JqZWN0KWAsXG4gKiAgIGBwc2J0LnVwZGF0ZUlucHV0KGl0ZW1PYmplY3QpYCwgYHBzYnQudXBkYXRlT3V0cHV0KGl0ZW1PYmplY3QpYFxuICogICBhZGRJbnB1dCByZXF1aXJlcyBoYXNoOiBCdWZmZXIgfCBzdHJpbmc7IGFuZCBpbmRleDogbnVtYmVyOyBhcyBhdHRyaWJ1dGVzXG4gKiAgIGFuZCBjYW4gYWxzbyBpbmNsdWRlIGFueSBhdHRyaWJ1dGVzIHRoYXQgYXJlIHVzZWQgaW4gdXBkYXRlSW5wdXQgbWV0aG9kLlxuICogICBhZGRPdXRwdXQgcmVxdWlyZXMgc2NyaXB0OiBCdWZmZXI7IGFuZCB2YWx1ZTogbnVtYmVyOyBhbmQgbGlrZXdpc2UgY2FuIGluY2x1ZGVcbiAqICAgZGF0YSBmb3IgdXBkYXRlT3V0cHV0LlxuICogICBGb3IgYSBsaXN0IG9mIHdoYXQgYXR0cmlidXRlcyBzaG91bGQgYmUgd2hhdCB0eXBlcy4gQ2hlY2sgdGhlIGJpcDE3NCBsaWJyYXJ5LlxuICogICBBbHNvLCBjaGVjayB0aGUgaW50ZWdyYXRpb24gdGVzdHMgZm9yIHNvbWUgZXhhbXBsZXMgb2YgdXNhZ2UuXG4gKlxuICogU2lnbmVyOiBUaGVyZSBhcmUgYSBmZXcgbWV0aG9kcy4gc2lnbkFsbElucHV0cyBhbmQgc2lnbkFsbElucHV0c0FzeW5jLCB3aGljaCB3aWxsIHNlYXJjaCBhbGwgaW5wdXRcbiAqICAgaW5mb3JtYXRpb24gZm9yIHlvdXIgcHVia2V5IG9yIHB1YmtleWhhc2gsIGFuZCBvbmx5IHNpZ24gaW5wdXRzIHdoZXJlIGl0IGZpbmRzXG4gKiAgIHlvdXIgaW5mby4gT3IgeW91IGNhbiBleHBsaWNpdGx5IHNpZ24gYSBzcGVjaWZpYyBpbnB1dCB3aXRoIHNpZ25JbnB1dCBhbmRcbiAqICAgc2lnbklucHV0QXN5bmMuIEZvciB0aGUgYXN5bmMgbWV0aG9kcyB5b3UgY2FuIGNyZWF0ZSBhIFNpZ25lckFzeW5jIG9iamVjdFxuICogICBhbmQgdXNlIHNvbWV0aGluZyBsaWtlIGEgaGFyZHdhcmUgd2FsbGV0IHRvIHNpZ24gd2l0aC4gKFlvdSBtdXN0IGltcGxlbWVudCB0aGlzKVxuICpcbiAqIENvbWJpbmVyOiBwc2J0cyBjYW4gYmUgY29tYmluZWQgZWFzaWx5IHdpdGggYHBzYnQuY29tYmluZShwc2J0MiwgcHNidDMsIHBzYnQ0IC4uLilgXG4gKiAgIHRoZSBwc2J0IGNhbGxpbmcgY29tYmluZSB3aWxsIGFsd2F5cyBoYXZlIHByZWNlZGVuY2Ugd2hlbiBhIGNvbmZsaWN0IG9jY3Vycy5cbiAqICAgQ29tYmluZSBjaGVja3MgaWYgdGhlIGludGVybmFsIGJpdGNvaW4gdHJhbnNhY3Rpb24gaXMgdGhlIHNhbWUsIHNvIGJlIHN1cmUgdGhhdFxuICogICBhbGwgc2VxdWVuY2VzLCB2ZXJzaW9uLCBsb2NrdGltZSwgZXRjLiBhcmUgdGhlIHNhbWUgYmVmb3JlIGNvbWJpbmluZy5cbiAqXG4gKiBJbnB1dCBGaW5hbGl6ZXI6IFRoaXMgcm9sZSBpcyBmYWlybHkgaW1wb3J0YW50LiBOb3Qgb25seSBkb2VzIGl0IG5lZWQgdG8gY29uc3RydWN0XG4gKiAgIHRoZSBpbnB1dCBzY3JpcHRTaWdzIGFuZCB3aXRuZXNzZXMsIGJ1dCBpdCBTSE9VTEQgdmVyaWZ5IHRoZSBzaWduYXR1cmVzIGV0Yy5cbiAqICAgQmVmb3JlIHJ1bm5pbmcgYHBzYnQuZmluYWxpemVBbGxJbnB1dHMoKWAgcGxlYXNlIHJ1biBgcHNidC52YWxpZGF0ZVNpZ25hdHVyZXNPZkFsbElucHV0cygpYFxuICogICBSdW5uaW5nIGFueSBmaW5hbGl6ZSBtZXRob2Qgd2lsbCBkZWxldGUgYW55IGRhdGEgaW4gdGhlIGlucHV0KHMpIHRoYXQgYXJlIG5vIGxvbmdlclxuICogICBuZWVkZWQgZHVlIHRvIHRoZSBmaW5hbGl6ZWQgc2NyaXB0cyBjb250YWluaW5nIHRoZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBUcmFuc2FjdGlvbiBFeHRyYWN0b3I6IFRoaXMgcm9sZSB3aWxsIHBlcmZvcm0gc29tZSBjaGVja3MgYmVmb3JlIHJldHVybmluZyBhXG4gKiAgIFRyYW5zYWN0aW9uIG9iamVjdC4gU3VjaCBhcyBmZWUgcmF0ZSBub3QgYmVpbmcgbGFyZ2VyIHRoYW4gbWF4aW11bUZlZVJhdGUgZXRjLlxuICovXG5jbGFzcyBQc2J0IHtcbiAgc3RhdGljIGZyb21CYXNlNjQoZGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpO1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmZmVyLCBvcHRzKTtcbiAgfVxuICBzdGF0aWMgZnJvbUhleChkYXRhLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCAnaGV4Jyk7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUJ1ZmZlcihidWZmZXIsIG9wdHMpO1xuICB9XG4gIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlciwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgcHNidEJhc2UgPSBiaXAxNzRfMS5Qc2J0LmZyb21CdWZmZXIoYnVmZmVyLCB0cmFuc2FjdGlvbkZyb21CdWZmZXIpO1xuICAgIGNvbnN0IHBzYnQgPSBuZXcgUHNidChvcHRzLCBwc2J0QmFzZSk7XG4gICAgY2hlY2tUeEZvckR1cGVJbnMocHNidC5fX0NBQ0hFLl9fVFgsIHBzYnQuX19DQUNIRSk7XG4gICAgcmV0dXJuIHBzYnQ7XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9LCBkYXRhID0gbmV3IGJpcDE3NF8xLlBzYnQobmV3IFBzYnRUcmFuc2FjdGlvbigpKSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgLy8gc2V0IGRlZmF1bHRzXG4gICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRTLCBvcHRzKTtcbiAgICB0aGlzLl9fQ0FDSEUgPSB7XG4gICAgICBfX05PTl9XSVRORVNTX1VUWE9fVFhfQ0FDSEU6IFtdLFxuICAgICAgX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRTogW10sXG4gICAgICBfX1RYX0lOX0NBQ0hFOiB7fSxcbiAgICAgIF9fVFg6IHRoaXMuZGF0YS5nbG9iYWxNYXAudW5zaWduZWRUeC50eCxcbiAgICAgIC8vIFBzYnQncyBwcmVkZWNlc3NvciAoVHJhbnNhY3Rpb25CdWlsZGVyIC0gbm93IHJlbW92ZWQpIGJlaGF2aW9yXG4gICAgICAvLyB3YXMgdG8gbm90IGNvbmZpcm0gaW5wdXQgdmFsdWVzICBiZWZvcmUgc2lnbmluZy5cbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGhpZ2hseSBlbmNvdXJhZ2UgcGVvcGxlIHRvIGdldFxuICAgICAgLy8gdGhlIGZ1bGwgcGFyZW50IHRyYW5zYWN0aW9uIHRvIHZlcmlmeSB2YWx1ZXMsIHRoZSBhYmlsaXR5IHRvXG4gICAgICAvLyBzaWduIG5vbi1zZWd3aXQgaW5wdXRzIHdpdGhvdXQgdGhlIGZ1bGwgdHJhbnNhY3Rpb24gd2FzIG9mdGVuXG4gICAgICAvLyByZXF1ZXN0ZWQuIFNvIHRoZSBvbmx5IHdheSB0byBhY3RpdmF0ZSBpcyB0byB1c2UgQHRzLWlnbm9yZS5cbiAgICAgIC8vIFdlIHdpbGwgZGlzYWJsZSBleHBvcnRpbmcgdGhlIFBzYnQgd2hlbiB1bnNhZmUgc2lnbiBpcyBhY3RpdmUuXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIG5vdCBCSVAxNzQgY29tcGxpYW50LlxuICAgICAgX19VTlNBRkVfU0lHTl9OT05TRUdXSVQ6IGZhbHNlLFxuICAgIH07XG4gICAgaWYgKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoID09PSAwKSB0aGlzLnNldFZlcnNpb24oMik7XG4gICAgLy8gTWFrZSBkYXRhIGhpZGRlbiB3aGVuIGVudW1lcmF0aW5nXG4gICAgY29uc3QgZHBldyA9IChvYmosIGF0dHIsIGVudW1lcmFibGUsIHdyaXRhYmxlKSA9PlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgYXR0ciwge1xuICAgICAgICBlbnVtZXJhYmxlLFxuICAgICAgICB3cml0YWJsZSxcbiAgICAgIH0pO1xuICAgIGRwZXcodGhpcywgJ19fQ0FDSEUnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZHBldyh0aGlzLCAnb3B0cycsIGZhbHNlLCB0cnVlKTtcbiAgfVxuICBnZXQgaW5wdXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmlucHV0cy5sZW5ndGg7XG4gIH1cbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19DQUNIRS5fX1RYLnZlcnNpb247XG4gIH1cbiAgc2V0IHZlcnNpb24odmVyc2lvbikge1xuICAgIHRoaXMuc2V0VmVyc2lvbih2ZXJzaW9uKTtcbiAgfVxuICBnZXQgbG9ja3RpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19DQUNIRS5fX1RYLmxvY2t0aW1lO1xuICB9XG4gIHNldCBsb2NrdGltZShsb2NrdGltZSkge1xuICAgIHRoaXMuc2V0TG9ja3RpbWUobG9ja3RpbWUpO1xuICB9XG4gIGdldCB0eElucHV0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fX0NBQ0hFLl9fVFguaW5zLm1hcChpbnB1dCA9PiAoe1xuICAgICAgaGFzaDogKDAsIGJ1ZmZlcnV0aWxzXzEuY2xvbmVCdWZmZXIpKGlucHV0Lmhhc2gpLFxuICAgICAgaW5kZXg6IGlucHV0LmluZGV4LFxuICAgICAgc2VxdWVuY2U6IGlucHV0LnNlcXVlbmNlLFxuICAgIH0pKTtcbiAgfVxuICBnZXQgdHhPdXRwdXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9fQ0FDSEUuX19UWC5vdXRzLm1hcChvdXRwdXQgPT4ge1xuICAgICAgbGV0IGFkZHJlc3M7XG4gICAgICB0cnkge1xuICAgICAgICBhZGRyZXNzID0gKDAsIGFkZHJlc3NfMS5mcm9tT3V0cHV0U2NyaXB0KShcbiAgICAgICAgICBvdXRwdXQuc2NyaXB0LFxuICAgICAgICAgIHRoaXMub3B0cy5uZXR3b3JrLFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmlwdDogKDAsIGJ1ZmZlcnV0aWxzXzEuY2xvbmVCdWZmZXIpKG91dHB1dC5zY3JpcHQpLFxuICAgICAgICB2YWx1ZTogb3V0cHV0LnZhbHVlLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBjb21iaW5lKC4uLnRob3NlKSB7XG4gICAgdGhpcy5kYXRhLmNvbWJpbmUoLi4udGhvc2UubWFwKG8gPT4gby5kYXRhKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgY2xvbmluZ1xuICAgIGNvbnN0IHJlcyA9IFBzYnQuZnJvbUJ1ZmZlcih0aGlzLmRhdGEudG9CdWZmZXIoKSk7XG4gICAgcmVzLm9wdHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMub3B0cykpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgc2V0TWF4aW11bUZlZVJhdGUoc2F0b3NoaVBlckJ5dGUpIHtcbiAgICBjaGVjazMyQml0KHNhdG9zaGlQZXJCeXRlKTsgLy8gNDIuOSBCVEMgcGVyIGJ5dGUgSVMgZXhjZXNzaXZlLi4uIHNvIHRocm93XG4gICAgdGhpcy5vcHRzLm1heGltdW1GZWVSYXRlID0gc2F0b3NoaVBlckJ5dGU7XG4gIH1cbiAgc2V0VmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgY2hlY2szMkJpdCh2ZXJzaW9uKTtcbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ3NldFZlcnNpb24nKTtcbiAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgIGMuX19UWC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjLl9fRVhUUkFDVEVEX1RYID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldExvY2t0aW1lKGxvY2t0aW1lKSB7XG4gICAgY2hlY2szMkJpdChsb2NrdGltZSk7XG4gICAgY2hlY2tJbnB1dHNGb3JQYXJ0aWFsU2lnKHRoaXMuZGF0YS5pbnB1dHMsICdzZXRMb2NrdGltZScpO1xuICAgIGNvbnN0IGMgPSB0aGlzLl9fQ0FDSEU7XG4gICAgYy5fX1RYLmxvY2t0aW1lID0gbG9ja3RpbWU7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRJbnB1dFNlcXVlbmNlKGlucHV0SW5kZXgsIHNlcXVlbmNlKSB7XG4gICAgY2hlY2szMkJpdChzZXF1ZW5jZSk7XG4gICAgY2hlY2tJbnB1dHNGb3JQYXJ0aWFsU2lnKHRoaXMuZGF0YS5pbnB1dHMsICdzZXRJbnB1dFNlcXVlbmNlJyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICBpZiAoYy5fX1RYLmlucy5sZW5ndGggPD0gaW5wdXRJbmRleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBpbmRleCB0b28gaGlnaCcpO1xuICAgIH1cbiAgICBjLl9fVFguaW5zW2lucHV0SW5kZXhdLnNlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRJbnB1dHMoaW5wdXREYXRhcykge1xuICAgIGlucHV0RGF0YXMuZm9yRWFjaChpbnB1dERhdGEgPT4gdGhpcy5hZGRJbnB1dChpbnB1dERhdGEpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRJbnB1dChpbnB1dERhdGEpIHtcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSB8fFxuICAgICAgIWlucHV0RGF0YSB8fFxuICAgICAgaW5wdXREYXRhLmhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaW5wdXREYXRhLmluZGV4ID09PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LmFkZElucHV0LiBgICtcbiAgICAgICAgICBgUmVxdWlyZXMgc2luZ2xlIG9iamVjdCB3aXRoIGF0IGxlYXN0IFtoYXNoXSBhbmQgW2luZGV4XWAsXG4gICAgICApO1xuICAgIH1cbiAgICAoMCwgYmlwMzcxXzEuY2hlY2tUYXByb290SW5wdXRGaWVsZHMpKGlucHV0RGF0YSwgaW5wdXREYXRhLCAnYWRkSW5wdXQnKTtcbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ2FkZElucHV0Jyk7XG4gICAgaWYgKGlucHV0RGF0YS53aXRuZXNzU2NyaXB0KSBjaGVja0ludmFsaWRQMldTSChpbnB1dERhdGEud2l0bmVzc1NjcmlwdCk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICB0aGlzLmRhdGEuYWRkSW5wdXQoaW5wdXREYXRhKTtcbiAgICBjb25zdCB0eEluID0gYy5fX1RYLmluc1tjLl9fVFguaW5zLmxlbmd0aCAtIDFdO1xuICAgIGNoZWNrVHhJbnB1dENhY2hlKGMsIHR4SW4pO1xuICAgIGNvbnN0IGlucHV0SW5kZXggPSB0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdO1xuICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgYWRkTm9uV2l0bmVzc1R4Q2FjaGUodGhpcy5fX0NBQ0hFLCBpbnB1dCwgaW5wdXRJbmRleCk7XG4gICAgfVxuICAgIGMuX19GRUUgPSB1bmRlZmluZWQ7XG4gICAgYy5fX0ZFRV9SQVRFID0gdW5kZWZpbmVkO1xuICAgIGMuX19FWFRSQUNURURfVFggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkT3V0cHV0cyhvdXRwdXREYXRhcykge1xuICAgIG91dHB1dERhdGFzLmZvckVhY2gob3V0cHV0RGF0YSA9PiB0aGlzLmFkZE91dHB1dChvdXRwdXREYXRhKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkT3V0cHV0KG91dHB1dERhdGEpIHtcbiAgICBpZiAoXG4gICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSB8fFxuICAgICAgIW91dHB1dERhdGEgfHxcbiAgICAgIG91dHB1dERhdGEudmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKG91dHB1dERhdGEuYWRkcmVzcyA9PT0gdW5kZWZpbmVkICYmIG91dHB1dERhdGEuc2NyaXB0ID09PSB1bmRlZmluZWQpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC5hZGRPdXRwdXQuIGAgK1xuICAgICAgICAgIGBSZXF1aXJlcyBzaW5nbGUgb2JqZWN0IHdpdGggYXQgbGVhc3QgW3NjcmlwdCBvciBhZGRyZXNzXSBhbmQgW3ZhbHVlXWAsXG4gICAgICApO1xuICAgIH1cbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ2FkZE91dHB1dCcpO1xuICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gb3V0cHV0RGF0YTtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB7IG5ldHdvcmsgfSA9IHRoaXMub3B0cztcbiAgICAgIGNvbnN0IHNjcmlwdCA9ICgwLCBhZGRyZXNzXzEudG9PdXRwdXRTY3JpcHQpKGFkZHJlc3MsIG5ldHdvcmspO1xuICAgICAgb3V0cHV0RGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIG91dHB1dERhdGEsIHsgc2NyaXB0IH0pO1xuICAgIH1cbiAgICAoMCwgYmlwMzcxXzEuY2hlY2tUYXByb290T3V0cHV0RmllbGRzKShvdXRwdXREYXRhLCBvdXRwdXREYXRhLCAnYWRkT3V0cHV0Jyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICB0aGlzLmRhdGEuYWRkT3V0cHV0KG91dHB1dERhdGEpO1xuICAgIGMuX19GRUUgPSB1bmRlZmluZWQ7XG4gICAgYy5fX0ZFRV9SQVRFID0gdW5kZWZpbmVkO1xuICAgIGMuX19FWFRSQUNURURfVFggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZXh0cmFjdFRyYW5zYWN0aW9uKGRpc2FibGVGZWVDaGVjaykge1xuICAgIGlmICghdGhpcy5kYXRhLmlucHV0cy5ldmVyeShpc0ZpbmFsaXplZCkpIHRocm93IG5ldyBFcnJvcignTm90IGZpbmFsaXplZCcpO1xuICAgIGNvbnN0IGMgPSB0aGlzLl9fQ0FDSEU7XG4gICAgaWYgKCFkaXNhYmxlRmVlQ2hlY2spIHtcbiAgICAgIGNoZWNrRmVlcyh0aGlzLCBjLCB0aGlzLm9wdHMpO1xuICAgIH1cbiAgICBpZiAoYy5fX0VYVFJBQ1RFRF9UWCkgcmV0dXJuIGMuX19FWFRSQUNURURfVFg7XG4gICAgY29uc3QgdHggPSBjLl9fVFguY2xvbmUoKTtcbiAgICBpbnB1dEZpbmFsaXplR2V0QW10cyh0aGlzLmRhdGEuaW5wdXRzLCB0eCwgYywgdHJ1ZSk7XG4gICAgcmV0dXJuIHR4O1xuICB9XG4gIGdldEZlZVJhdGUoKSB7XG4gICAgcmV0dXJuIGdldFR4Q2FjaGVWYWx1ZShcbiAgICAgICdfX0ZFRV9SQVRFJyxcbiAgICAgICdmZWUgcmF0ZScsXG4gICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICk7XG4gIH1cbiAgZ2V0RmVlKCkge1xuICAgIHJldHVybiBnZXRUeENhY2hlVmFsdWUoJ19fRkVFJywgJ2ZlZScsIHRoaXMuZGF0YS5pbnB1dHMsIHRoaXMuX19DQUNIRSk7XG4gIH1cbiAgZmluYWxpemVBbGxJbnB1dHMoKSB7XG4gICAgKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgMCk7IC8vIG1ha2luZyBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lXG4gICAgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpLmZvckVhY2goaWR4ID0+IHRoaXMuZmluYWxpemVJbnB1dChpZHgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmaW5hbGl6ZUlucHV0KGlucHV0SW5kZXgsIGZpbmFsU2NyaXB0c0Z1bmMpIHtcbiAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgIHJldHVybiB0aGlzLl9maW5hbGl6ZVRhcHJvb3RJbnB1dChcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgZmluYWxTY3JpcHRzRnVuYyxcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplSW5wdXQoaW5wdXRJbmRleCwgaW5wdXQsIGZpbmFsU2NyaXB0c0Z1bmMpO1xuICB9XG4gIGZpbmFsaXplVGFwcm9vdElucHV0KFxuICAgIGlucHV0SW5kZXgsXG4gICAgdGFwTGVhZkhhc2hUb0ZpbmFsaXplLFxuICAgIGZpbmFsU2NyaXB0c0Z1bmMgPSBiaXAzNzFfMS50YXBTY3JpcHRGaW5hbGl6ZXIsXG4gICkge1xuICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVGFwcm9vdElucHV0KFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgdGFwTGVhZkhhc2hUb0ZpbmFsaXplLFxuICAgICAgICBmaW5hbFNjcmlwdHNGdW5jLFxuICAgICAgKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5hbGl6ZSBpbnB1dCAjJHtpbnB1dEluZGV4fS4gTm90IFRhcHJvb3QuYCk7XG4gIH1cbiAgX2ZpbmFsaXplSW5wdXQoaW5wdXRJbmRleCwgaW5wdXQsIGZpbmFsU2NyaXB0c0Z1bmMgPSBnZXRGaW5hbFNjcmlwdHMpIHtcbiAgICBjb25zdCB7IHNjcmlwdCwgaXNQMlNILCBpc1AyV1NILCBpc1NlZ3dpdCB9ID0gZ2V0U2NyaXB0RnJvbUlucHV0KFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGlucHV0LFxuICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICk7XG4gICAgaWYgKCFzY3JpcHQpIHRocm93IG5ldyBFcnJvcihgTm8gc2NyaXB0IGZvdW5kIGZvciBpbnB1dCAjJHtpbnB1dEluZGV4fWApO1xuICAgIGNoZWNrUGFydGlhbFNpZ1NpZ2hhc2hlcyhpbnB1dCk7XG4gICAgY29uc3QgeyBmaW5hbFNjcmlwdFNpZywgZmluYWxTY3JpcHRXaXRuZXNzIH0gPSBmaW5hbFNjcmlwdHNGdW5jKFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGlucHV0LFxuICAgICAgc2NyaXB0LFxuICAgICAgaXNTZWd3aXQsXG4gICAgICBpc1AyU0gsXG4gICAgICBpc1AyV1NILFxuICAgICk7XG4gICAgaWYgKGZpbmFsU2NyaXB0U2lnKSB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFNpZyB9KTtcbiAgICBpZiAoZmluYWxTY3JpcHRXaXRuZXNzKVxuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRXaXRuZXNzIH0pO1xuICAgIGlmICghZmluYWxTY3JpcHRTaWcgJiYgIWZpbmFsU2NyaXB0V2l0bmVzcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBlcnJvciBmaW5hbGl6aW5nIGlucHV0ICMke2lucHV0SW5kZXh9YCk7XG4gICAgdGhpcy5kYXRhLmNsZWFyRmluYWxpemVkSW5wdXQoaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2ZpbmFsaXplVGFwcm9vdElucHV0KFxuICAgIGlucHV0SW5kZXgsXG4gICAgaW5wdXQsXG4gICAgdGFwTGVhZkhhc2hUb0ZpbmFsaXplLFxuICAgIGZpbmFsU2NyaXB0c0Z1bmMgPSBiaXAzNzFfMS50YXBTY3JpcHRGaW5hbGl6ZXIsXG4gICkge1xuICAgIGlmICghaW5wdXQud2l0bmVzc1V0eG8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDYW5ub3QgZmluYWxpemUgaW5wdXQgIyR7aW5wdXRJbmRleH0uIE1pc3Npbmcgd2l0aG5lc3MgdXR4by5gLFxuICAgICAgKTtcbiAgICAvLyBDaGVjayBrZXkgc3BlbmQgZmlyc3QuIEluY3JlYXNlZCBwcml2YWN5IGFuZCByZWR1Y2VkIGJsb2NrIHNwYWNlLlxuICAgIGlmIChpbnB1dC50YXBLZXlTaWcpIHtcbiAgICAgIGNvbnN0IHBheW1lbnQgPSBwYXltZW50cy5wMnRyKHtcbiAgICAgICAgb3V0cHV0OiBpbnB1dC53aXRuZXNzVXR4by5zY3JpcHQsXG4gICAgICAgIHNpZ25hdHVyZTogaW5wdXQudGFwS2V5U2lnLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBmaW5hbFNjcmlwdFdpdG5lc3MgPSAoMCwgcHNidHV0aWxzXzEud2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzKShcbiAgICAgICAgcGF5bWVudC53aXRuZXNzLFxuICAgICAgKTtcbiAgICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IGZpbmFsU2NyaXB0V2l0bmVzcyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBmaW5hbFNjcmlwdFdpdG5lc3MgfSA9IGZpbmFsU2NyaXB0c0Z1bmMoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIGlucHV0LFxuICAgICAgICB0YXBMZWFmSGFzaFRvRmluYWxpemUsXG4gICAgICApO1xuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRXaXRuZXNzIH0pO1xuICAgIH1cbiAgICB0aGlzLmRhdGEuY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRJbnB1dFR5cGUoaW5wdXRJbmRleCkge1xuICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgY29uc3Qgc2NyaXB0ID0gZ2V0U2NyaXB0RnJvbVV0eG8oaW5wdXRJbmRleCwgaW5wdXQsIHRoaXMuX19DQUNIRSk7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0TWVhbmluZ2Z1bFNjcmlwdChcbiAgICAgIHNjcmlwdCxcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICAnaW5wdXQnLFxuICAgICAgaW5wdXQucmVkZWVtU2NyaXB0IHx8IHJlZGVlbUZyb21GaW5hbFNjcmlwdFNpZyhpbnB1dC5maW5hbFNjcmlwdFNpZyksXG4gICAgICBpbnB1dC53aXRuZXNzU2NyaXB0IHx8XG4gICAgICAgIHJlZGVlbUZyb21GaW5hbFdpdG5lc3NTY3JpcHQoaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzKSxcbiAgICApO1xuICAgIGNvbnN0IHR5cGUgPSByZXN1bHQudHlwZSA9PT0gJ3JhdycgPyAnJyA6IHJlc3VsdC50eXBlICsgJy0nO1xuICAgIGNvbnN0IG1haW5UeXBlID0gY2xhc3NpZnlTY3JpcHQocmVzdWx0Lm1lYW5pbmdmdWxTY3JpcHQpO1xuICAgIHJldHVybiB0eXBlICsgbWFpblR5cGU7XG4gIH1cbiAgaW5wdXRIYXNQdWJrZXkoaW5wdXRJbmRleCwgcHVia2V5KSB7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICByZXR1cm4gcHVia2V5SW5JbnB1dChwdWJrZXksIGlucHV0LCBpbnB1dEluZGV4LCB0aGlzLl9fQ0FDSEUpO1xuICB9XG4gIGlucHV0SGFzSERLZXkoaW5wdXRJbmRleCwgcm9vdCkge1xuICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgY29uc3QgZGVyaXZhdGlvbklzTWluZSA9IGJpcDMyRGVyaXZhdGlvbklzTWluZShyb290KTtcbiAgICByZXR1cm4gKFxuICAgICAgISFpbnB1dC5iaXAzMkRlcml2YXRpb24gJiYgaW5wdXQuYmlwMzJEZXJpdmF0aW9uLnNvbWUoZGVyaXZhdGlvbklzTWluZSlcbiAgICApO1xuICB9XG4gIG91dHB1dEhhc1B1YmtleShvdXRwdXRJbmRleCwgcHVia2V5KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JPdXRwdXQpKHRoaXMuZGF0YS5vdXRwdXRzLCBvdXRwdXRJbmRleCk7XG4gICAgcmV0dXJuIHB1YmtleUluT3V0cHV0KHB1YmtleSwgb3V0cHV0LCBvdXRwdXRJbmRleCwgdGhpcy5fX0NBQ0hFKTtcbiAgfVxuICBvdXRwdXRIYXNIREtleShvdXRwdXRJbmRleCwgcm9vdCkge1xuICAgIGNvbnN0IG91dHB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9yT3V0cHV0KSh0aGlzLmRhdGEub3V0cHV0cywgb3V0cHV0SW5kZXgpO1xuICAgIGNvbnN0IGRlcml2YXRpb25Jc01pbmUgPSBiaXAzMkRlcml2YXRpb25Jc01pbmUocm9vdCk7XG4gICAgcmV0dXJuIChcbiAgICAgICEhb3V0cHV0LmJpcDMyRGVyaXZhdGlvbiAmJiBvdXRwdXQuYmlwMzJEZXJpdmF0aW9uLnNvbWUoZGVyaXZhdGlvbklzTWluZSlcbiAgICApO1xuICB9XG4gIHZhbGlkYXRlU2lnbmF0dXJlc09mQWxsSW5wdXRzKHZhbGlkYXRvcikge1xuICAgICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIDApOyAvLyBtYWtpbmcgc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZVxuICAgIGNvbnN0IHJlc3VsdHMgPSByYW5nZSh0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCkubWFwKGlkeCA9PlxuICAgICAgdGhpcy52YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0KGlkeCwgdmFsaWRhdG9yKSxcbiAgICApO1xuICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoZmluYWwsIHJlcykgPT4gcmVzID09PSB0cnVlICYmIGZpbmFsLCB0cnVlKTtcbiAgfVxuICB2YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0KGlucHV0SW5kZXgsIHZhbGlkYXRvciwgcHVia2V5KSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdO1xuICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2lnbmF0dXJlc09mVGFwcm9vdElucHV0KFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICB2YWxpZGF0b3IsXG4gICAgICAgIHB1YmtleSxcbiAgICAgICk7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXQoaW5wdXRJbmRleCwgdmFsaWRhdG9yLCBwdWJrZXkpO1xuICB9XG4gIF92YWxpZGF0ZVNpZ25hdHVyZXNPZklucHV0KGlucHV0SW5kZXgsIHZhbGlkYXRvciwgcHVia2V5KSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdO1xuICAgIGNvbnN0IHBhcnRpYWxTaWcgPSAoaW5wdXQgfHwge30pLnBhcnRpYWxTaWc7XG4gICAgaWYgKCFpbnB1dCB8fCAhcGFydGlhbFNpZyB8fCBwYXJ0aWFsU2lnLmxlbmd0aCA8IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZXMgdG8gdmFsaWRhdGUnKTtcbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCB2YWxpZGF0b3IgZnVuY3Rpb24gdG8gdmFsaWRhdGUgc2lnbmF0dXJlcycpO1xuICAgIGNvbnN0IG15U2lncyA9IHB1YmtleVxuICAgICAgPyBwYXJ0aWFsU2lnLmZpbHRlcihzaWcgPT4gc2lnLnB1YmtleS5lcXVhbHMocHVia2V5KSlcbiAgICAgIDogcGFydGlhbFNpZztcbiAgICBpZiAobXlTaWdzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyBmb3IgdGhpcyBwdWJrZXknKTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgbGV0IGhhc2hDYWNoZTtcbiAgICBsZXQgc2NyaXB0Q2FjaGU7XG4gICAgbGV0IHNpZ2hhc2hDYWNoZTtcbiAgICBmb3IgKGNvbnN0IHBTaWcgb2YgbXlTaWdzKSB7XG4gICAgICBjb25zdCBzaWcgPSBic2NyaXB0LnNpZ25hdHVyZS5kZWNvZGUocFNpZy5zaWduYXR1cmUpO1xuICAgICAgY29uc3QgeyBoYXNoLCBzY3JpcHQgfSA9XG4gICAgICAgIHNpZ2hhc2hDYWNoZSAhPT0gc2lnLmhhc2hUeXBlXG4gICAgICAgICAgPyBnZXRIYXNoRm9yU2lnKFxuICAgICAgICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBpbnB1dCwgeyBzaWdoYXNoVHlwZTogc2lnLmhhc2hUeXBlIH0pLFxuICAgICAgICAgICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiB7IGhhc2g6IGhhc2hDYWNoZSwgc2NyaXB0OiBzY3JpcHRDYWNoZSB9O1xuICAgICAgc2lnaGFzaENhY2hlID0gc2lnLmhhc2hUeXBlO1xuICAgICAgaGFzaENhY2hlID0gaGFzaDtcbiAgICAgIHNjcmlwdENhY2hlID0gc2NyaXB0O1xuICAgICAgY2hlY2tTY3JpcHRGb3JQdWJrZXkocFNpZy5wdWJrZXksIHNjcmlwdCwgJ3ZlcmlmeScpO1xuICAgICAgcmVzdWx0cy5wdXNoKHZhbGlkYXRvcihwU2lnLnB1YmtleSwgaGFzaCwgc2lnLnNpZ25hdHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cy5ldmVyeShyZXMgPT4gcmVzID09PSB0cnVlKTtcbiAgfVxuICB2YWxpZGF0ZVNpZ25hdHVyZXNPZlRhcHJvb3RJbnB1dChpbnB1dEluZGV4LCB2YWxpZGF0b3IsIHB1YmtleSkge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XTtcbiAgICBjb25zdCB0YXBLZXlTaWcgPSAoaW5wdXQgfHwge30pLnRhcEtleVNpZztcbiAgICBjb25zdCB0YXBTY3JpcHRTaWcgPSAoaW5wdXQgfHwge30pLnRhcFNjcmlwdFNpZztcbiAgICBpZiAoIWlucHV0ICYmICF0YXBLZXlTaWcgJiYgISh0YXBTY3JpcHRTaWcgJiYgIXRhcFNjcmlwdFNpZy5sZW5ndGgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduYXR1cmVzIHRvIHZhbGlkYXRlJyk7XG4gICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgdmFsaWRhdG9yIGZ1bmN0aW9uIHRvIHZhbGlkYXRlIHNpZ25hdHVyZXMnKTtcbiAgICBwdWJrZXkgPSBwdWJrZXkgJiYgKDAsIGJpcDM3MV8xLnRvWE9ubHkpKHB1YmtleSk7XG4gICAgY29uc3QgYWxsSGFzaHNlcyA9IHB1YmtleVxuICAgICAgPyBnZXRUYXByb290SGFzaGVzRm9yU2lnKFxuICAgICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgdGhpcy5kYXRhLmlucHV0cyxcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgICApXG4gICAgICA6IGdldEFsbFRhcHJvb3RIYXNoZXNGb3JTaWcoXG4gICAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgICAgKTtcbiAgICBpZiAoIWFsbEhhc2hzZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZXMgZm9yIHRoaXMgcHVia2V5Jyk7XG4gICAgY29uc3QgdGFwS2V5SGFzaCA9IGFsbEhhc2hzZXMuZmluZChoID0+ICFoLmxlYWZIYXNoKTtcbiAgICBsZXQgdmFsaWRhdGlvblJlc3VsdENvdW50ID0gMDtcbiAgICBpZiAodGFwS2V5U2lnICYmIHRhcEtleUhhc2gpIHtcbiAgICAgIGNvbnN0IGlzVmFsaWRUYXBrZXlTaWcgPSB2YWxpZGF0b3IoXG4gICAgICAgIHRhcEtleUhhc2gucHVia2V5LFxuICAgICAgICB0YXBLZXlIYXNoLmhhc2gsXG4gICAgICAgIHRyaW1UYXByb290U2lnKHRhcEtleVNpZyksXG4gICAgICApO1xuICAgICAgaWYgKCFpc1ZhbGlkVGFwa2V5U2lnKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YWxpZGF0aW9uUmVzdWx0Q291bnQrKztcbiAgICB9XG4gICAgaWYgKHRhcFNjcmlwdFNpZykge1xuICAgICAgZm9yIChjb25zdCB0YXBTaWcgb2YgdGFwU2NyaXB0U2lnKSB7XG4gICAgICAgIGNvbnN0IHRhcFNpZ0hhc2ggPSBhbGxIYXNoc2VzLmZpbmQoaCA9PiB0YXBTaWcucHVia2V5LmVxdWFscyhoLnB1YmtleSkpO1xuICAgICAgICBpZiAodGFwU2lnSGFzaCkge1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWRUYXBTY3JpcHRTaWcgPSB2YWxpZGF0b3IoXG4gICAgICAgICAgICB0YXBTaWcucHVia2V5LFxuICAgICAgICAgICAgdGFwU2lnSGFzaC5oYXNoLFxuICAgICAgICAgICAgdHJpbVRhcHJvb3RTaWcodGFwU2lnLnNpZ25hdHVyZSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWlzVmFsaWRUYXBTY3JpcHRTaWcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdENvdW50ID4gMDtcbiAgfVxuICBzaWduQWxsSW5wdXRzSEQoXG4gICAgaGRLZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgaWYgKCFoZEtleVBhaXIgfHwgIWhkS2V5UGFpci5wdWJsaWNLZXkgfHwgIWhkS2V5UGFpci5maW5nZXJwcmludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgaSBvZiByYW5nZSh0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc2lnbklucHV0SEQoaSwgaGRLZXlQYWlyLCBzaWdoYXNoVHlwZXMpO1xuICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNpZ25BbGxJbnB1dHNIREFzeW5jKFxuICAgIGhkS2V5UGFpcixcbiAgICBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sXG4gICkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIHRoaXMuc2lnbklucHV0SERBc3luYyhpLCBoZEtleVBhaXIsIHNpZ2hhc2hUeXBlcykudGhlbihcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHRzLmV2ZXJ5KHYgPT4gdiA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIGlucHV0cyB3ZXJlIHNpZ25lZCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBzaWduSW5wdXRIRChcbiAgICBpbnB1dEluZGV4LFxuICAgIGhkS2V5UGFpcixcbiAgICBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sXG4gICkge1xuICAgIGlmICghaGRLZXlQYWlyIHx8ICFoZEtleVBhaXIucHVibGljS2V5IHx8ICFoZEtleVBhaXIuZmluZ2VycHJpbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBIRFNpZ25lciB0byBzaWduIGlucHV0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lcnMgPSBnZXRTaWduZXJzRnJvbUhEKGlucHV0SW5kZXgsIHRoaXMuZGF0YS5pbnB1dHMsIGhkS2V5UGFpcik7XG4gICAgc2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiB0aGlzLnNpZ25JbnB1dChpbnB1dEluZGV4LCBzaWduZXIsIHNpZ2hhc2hUeXBlcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNpZ25JbnB1dEhEQXN5bmMoXG4gICAgaW5wdXRJbmRleCxcbiAgICBoZEtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFoZEtleVBhaXIgfHwgIWhkS2V5UGFpci5wdWJsaWNLZXkgfHwgIWhkS2V5UGFpci5maW5nZXJwcmludCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTmVlZCBIRFNpZ25lciB0byBzaWduIGlucHV0JykpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmVycyA9IGdldFNpZ25lcnNGcm9tSEQoaW5wdXRJbmRleCwgdGhpcy5kYXRhLmlucHV0cywgaGRLZXlQYWlyKTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gc2lnbmVycy5tYXAoc2lnbmVyID0+XG4gICAgICAgIHRoaXMuc2lnbklucHV0QXN5bmMoaW5wdXRJbmRleCwgc2lnbmVyLCBzaWdoYXNoVHlwZXMpLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcylcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbiAgc2lnbkFsbElucHV0cyhrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIFNpZ25lciB0byBzaWduIGlucHV0Jyk7XG4gICAgLy8gVE9ETzogQWRkIGEgcHVia2V5L3B1YmtleWhhc2ggY2FjaGUgdG8gZWFjaCBpbnB1dFxuICAgIC8vIGFzIGlucHV0IGluZm9ybWF0aW9uIGlzIGFkZGVkLCB0aGVuIGV2ZW50dWFsbHlcbiAgICAvLyBvcHRpbWl6ZSB0aGlzIG1ldGhvZC5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zaWduSW5wdXQoaSwga2V5UGFpciwgc2lnaGFzaFR5cGVzKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHRydWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHRzLmV2ZXJ5KHYgPT4gdiA9PT0gZmFsc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0cyB3ZXJlIHNpZ25lZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzaWduQWxsSW5wdXRzQXN5bmMoa2V5UGFpciwgc2lnaGFzaFR5cGVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdOZWVkIFNpZ25lciB0byBzaWduIGlucHV0JykpO1xuICAgICAgLy8gVE9ETzogQWRkIGEgcHVia2V5L3B1YmtleWhhc2ggY2FjaGUgdG8gZWFjaCBpbnB1dFxuICAgICAgLy8gYXMgaW5wdXQgaW5mb3JtYXRpb24gaXMgYWRkZWQsIHRoZW4gZXZlbnR1YWxseVxuICAgICAgLy8gb3B0aW1pemUgdGhpcyBtZXRob2QuXG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBbaV0gb2YgdGhpcy5kYXRhLmlucHV0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICB0aGlzLnNpZ25JbnB1dEFzeW5jKGksIGtleVBhaXIsIHNpZ2hhc2hUeXBlcykudGhlbihcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHRzLmV2ZXJ5KHYgPT4gdiA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05vIGlucHV0cyB3ZXJlIHNpZ25lZCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBzaWduSW5wdXQoaW5wdXRJbmRleCwga2V5UGFpciwgc2lnaGFzaFR5cGVzKSB7XG4gICAgaWYgKCFrZXlQYWlyIHx8ICFrZXlQYWlyLnB1YmxpY0tleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2lnblRhcHJvb3RJbnB1dChcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGtleVBhaXIsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25JbnB1dChpbnB1dEluZGV4LCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpO1xuICB9XG4gIHNpZ25UYXByb290SW5wdXQoaW5wdXRJbmRleCwga2V5UGFpciwgdGFwTGVhZkhhc2hUb1NpZ24sIHNpZ2hhc2hUeXBlcykge1xuICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgIHJldHVybiB0aGlzLl9zaWduVGFwcm9vdElucHV0KFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAga2V5UGFpcixcbiAgICAgICAgdGFwTGVhZkhhc2hUb1NpZ24sXG4gICAgICAgIHNpZ2hhc2hUeXBlcyxcbiAgICAgICk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAjJHtpbnB1dEluZGV4fSBpcyBub3Qgb2YgdHlwZSBUYXByb290LmApO1xuICB9XG4gIF9zaWduSW5wdXQoXG4gICAgaW5wdXRJbmRleCxcbiAgICBrZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSB9ID0gZ2V0SGFzaEFuZFNpZ2hhc2hUeXBlKFxuICAgICAgdGhpcy5kYXRhLmlucHV0cyxcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBrZXlQYWlyLnB1YmxpY0tleSxcbiAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgIHNpZ2hhc2hUeXBlcyxcbiAgICApO1xuICAgIGNvbnN0IHBhcnRpYWxTaWcgPSBbXG4gICAgICB7XG4gICAgICAgIHB1YmtleToga2V5UGFpci5wdWJsaWNLZXksXG4gICAgICAgIHNpZ25hdHVyZTogYnNjcmlwdC5zaWduYXR1cmUuZW5jb2RlKGtleVBhaXIuc2lnbihoYXNoKSwgc2lnaGFzaFR5cGUpLFxuICAgICAgfSxcbiAgICBdO1xuICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHBhcnRpYWxTaWcgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX3NpZ25UYXByb290SW5wdXQoXG4gICAgaW5wdXRJbmRleCxcbiAgICBpbnB1dCxcbiAgICBrZXlQYWlyLFxuICAgIHRhcExlYWZIYXNoVG9TaWduLFxuICAgIGFsbG93ZWRTaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFRdLFxuICApIHtcbiAgICBjb25zdCBoYXNoZXNGb3JTaWcgPSB0aGlzLmNoZWNrVGFwcm9vdEhhc2hlc0ZvclNpZyhcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBpbnB1dCxcbiAgICAgIGtleVBhaXIsXG4gICAgICB0YXBMZWFmSGFzaFRvU2lnbixcbiAgICAgIGFsbG93ZWRTaWdoYXNoVHlwZXMsXG4gICAgKTtcbiAgICBjb25zdCB0YXBLZXlTaWcgPSBoYXNoZXNGb3JTaWdcbiAgICAgIC5maWx0ZXIoaCA9PiAhaC5sZWFmSGFzaClcbiAgICAgIC5tYXAoaCA9PlxuICAgICAgICAoMCwgYmlwMzcxXzEuc2VyaWFsaXplVGFwcm9vdFNpZ25hdHVyZSkoXG4gICAgICAgICAga2V5UGFpci5zaWduU2Nobm9ycihoLmhhc2gpLFxuICAgICAgICAgIGlucHV0LnNpZ2hhc2hUeXBlLFxuICAgICAgICApLFxuICAgICAgKVswXTtcbiAgICBjb25zdCB0YXBTY3JpcHRTaWcgPSBoYXNoZXNGb3JTaWdcbiAgICAgIC5maWx0ZXIoaCA9PiAhIWgubGVhZkhhc2gpXG4gICAgICAubWFwKGggPT4gKHtcbiAgICAgICAgcHVia2V5OiAoMCwgYmlwMzcxXzEudG9YT25seSkoa2V5UGFpci5wdWJsaWNLZXkpLFxuICAgICAgICBzaWduYXR1cmU6ICgwLCBiaXAzNzFfMS5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlKShcbiAgICAgICAgICBrZXlQYWlyLnNpZ25TY2hub3JyKGguaGFzaCksXG4gICAgICAgICAgaW5wdXQuc2lnaGFzaFR5cGUsXG4gICAgICAgICksXG4gICAgICAgIGxlYWZIYXNoOiBoLmxlYWZIYXNoLFxuICAgICAgfSkpO1xuICAgIGlmICh0YXBLZXlTaWcpIHtcbiAgICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHRhcEtleVNpZyB9KTtcbiAgICB9XG4gICAgaWYgKHRhcFNjcmlwdFNpZy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHRhcFNjcmlwdFNpZyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2lnbklucHV0QXN5bmMoaW5wdXRJbmRleCwga2V5UGFpciwgc2lnaGFzaFR5cGVzKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCFrZXlQYWlyIHx8ICFrZXlQYWlyLnB1YmxpY0tleSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIFNpZ25lciB0byBzaWduIGlucHV0Jyk7XG4gICAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgICByZXR1cm4gdGhpcy5fc2lnblRhcHJvb3RJbnB1dEFzeW5jKFxuICAgICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAga2V5UGFpcixcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuX3NpZ25JbnB1dEFzeW5jKGlucHV0SW5kZXgsIGtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gICAgfSk7XG4gIH1cbiAgc2lnblRhcHJvb3RJbnB1dEFzeW5jKGlucHV0SW5kZXgsIGtleVBhaXIsIHRhcExlYWZIYXNoLCBzaWdoYXNoVHlwZXMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dCkpXG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduVGFwcm9vdElucHV0QXN5bmMoXG4gICAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBrZXlQYWlyLFxuICAgICAgICAgIHRhcExlYWZIYXNoLFxuICAgICAgICAgIHNpZ2hhc2hUeXBlcyxcbiAgICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5wdXQgIyR7aW5wdXRJbmRleH0gaXMgbm90IG9mIHR5cGUgVGFwcm9vdC5gKTtcbiAgICB9KTtcbiAgfVxuICBfc2lnbklucHV0QXN5bmMoXG4gICAgaW5wdXRJbmRleCxcbiAgICBrZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSB9ID0gZ2V0SGFzaEFuZFNpZ2hhc2hUeXBlKFxuICAgICAgdGhpcy5kYXRhLmlucHV0cyxcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBrZXlQYWlyLnB1YmxpY0tleSxcbiAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgIHNpZ2hhc2hUeXBlcyxcbiAgICApO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5UGFpci5zaWduKGhhc2gpKS50aGVuKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBwYXJ0aWFsU2lnID0gW1xuICAgICAgICB7XG4gICAgICAgICAgcHVia2V5OiBrZXlQYWlyLnB1YmxpY0tleSxcbiAgICAgICAgICBzaWduYXR1cmU6IGJzY3JpcHQuc2lnbmF0dXJlLmVuY29kZShzaWduYXR1cmUsIHNpZ2hhc2hUeXBlKSxcbiAgICAgICAgfSxcbiAgICAgIF07XG4gICAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBwYXJ0aWFsU2lnIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9zaWduVGFwcm9vdElucHV0QXN5bmMoXG4gICAgaW5wdXRJbmRleCxcbiAgICBpbnB1dCxcbiAgICBrZXlQYWlyLFxuICAgIHRhcExlYWZIYXNoLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVF0sXG4gICkge1xuICAgIGNvbnN0IGhhc2hlc0ZvclNpZyA9IHRoaXMuY2hlY2tUYXByb290SGFzaGVzRm9yU2lnKFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGlucHV0LFxuICAgICAga2V5UGFpcixcbiAgICAgIHRhcExlYWZIYXNoLFxuICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICk7XG4gICAgY29uc3Qgc2lnbmF0dXJlUHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCB0YXBLZXlIYXNoID0gaGFzaGVzRm9yU2lnLmZpbHRlcihoID0+ICFoLmxlYWZIYXNoKVswXTtcbiAgICBpZiAodGFwS2V5SGFzaCkge1xuICAgICAgY29uc3QgdGFwS2V5U2lnUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShcbiAgICAgICAga2V5UGFpci5zaWduU2Nobm9ycih0YXBLZXlIYXNoLmhhc2gpLFxuICAgICAgKS50aGVuKHNpZyA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdGFwS2V5U2lnOiAoMCwgYmlwMzcxXzEuc2VyaWFsaXplVGFwcm9vdFNpZ25hdHVyZSkoXG4gICAgICAgICAgICBzaWcsXG4gICAgICAgICAgICBpbnB1dC5zaWdoYXNoVHlwZSxcbiAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBzaWduYXR1cmVQcm9taXNlcy5wdXNoKHRhcEtleVNpZ1Byb21pc2UpO1xuICAgIH1cbiAgICBjb25zdCB0YXBTY3JpcHRIYXNoZXMgPSBoYXNoZXNGb3JTaWcuZmlsdGVyKGggPT4gISFoLmxlYWZIYXNoKTtcbiAgICBpZiAodGFwU2NyaXB0SGFzaGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGFwU2NyaXB0U2lnUHJvbWlzZXMgPSB0YXBTY3JpcHRIYXNoZXMubWFwKHRzaCA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5UGFpci5zaWduU2Nobm9ycih0c2guaGFzaCkpLnRoZW4oXG4gICAgICAgICAgc2lnbmF0dXJlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcFNjcmlwdFNpZyA9IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHB1YmtleTogKDAsIGJpcDM3MV8xLnRvWE9ubHkpKGtleVBhaXIucHVibGljS2V5KSxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6ICgwLCBiaXAzNzFfMS5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlKShcbiAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAgIGlucHV0LnNpZ2hhc2hUeXBlLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbGVhZkhhc2g6IHRzaC5sZWFmSGFzaCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICByZXR1cm4geyB0YXBTY3JpcHRTaWcgfTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgICBzaWduYXR1cmVQcm9taXNlcy5wdXNoKC4uLnRhcFNjcmlwdFNpZ1Byb21pc2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHNpZ25hdHVyZVByb21pc2VzKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmVzdWx0cy5mb3JFYWNoKHYgPT4gdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHYpKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1RhcHJvb3RIYXNoZXNGb3JTaWcoXG4gICAgaW5wdXRJbmRleCxcbiAgICBpbnB1dCxcbiAgICBrZXlQYWlyLFxuICAgIHRhcExlYWZIYXNoVG9TaWduLFxuICAgIGFsbG93ZWRTaWdoYXNoVHlwZXMsXG4gICkge1xuICAgIGlmICh0eXBlb2Yga2V5UGFpci5zaWduU2Nobm9yciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE5lZWQgU2Nobm9yciBTaWduZXIgdG8gc2lnbiB0YXByb290IGlucHV0ICMke2lucHV0SW5kZXh9LmAsXG4gICAgICApO1xuICAgIGNvbnN0IGhhc2hlc0ZvclNpZyA9IGdldFRhcHJvb3RIYXNoZXNGb3JTaWcoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgaW5wdXQsXG4gICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAga2V5UGFpci5wdWJsaWNLZXksXG4gICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgICB0YXBMZWFmSGFzaFRvU2lnbixcbiAgICAgIGFsbG93ZWRTaWdoYXNoVHlwZXMsXG4gICAgKTtcbiAgICBpZiAoIWhhc2hlc0ZvclNpZyB8fCAhaGFzaGVzRm9yU2lnLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbiBub3Qgc2lnbiBmb3IgaW5wdXQgIyR7aW5wdXRJbmRleH0gd2l0aCB0aGUga2V5ICR7a2V5UGFpci5wdWJsaWNLZXkudG9TdHJpbmcoXG4gICAgICAgICAgJ2hleCcsXG4gICAgICAgICl9YCxcbiAgICAgICk7XG4gICAgcmV0dXJuIGhhc2hlc0ZvclNpZztcbiAgfVxuICB0b0J1ZmZlcigpIHtcbiAgICBjaGVja0NhY2hlKHRoaXMuX19DQUNIRSk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS50b0J1ZmZlcigpO1xuICB9XG4gIHRvSGV4KCkge1xuICAgIGNoZWNrQ2FjaGUodGhpcy5fX0NBQ0hFKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnRvSGV4KCk7XG4gIH1cbiAgdG9CYXNlNjQoKSB7XG4gICAgY2hlY2tDYWNoZSh0aGlzLl9fQ0FDSEUpO1xuICAgIHJldHVybiB0aGlzLmRhdGEudG9CYXNlNjQoKTtcbiAgfVxuICB1cGRhdGVHbG9iYWwodXBkYXRlRGF0YSkge1xuICAgIHRoaXMuZGF0YS51cGRhdGVHbG9iYWwodXBkYXRlRGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgdXBkYXRlRGF0YSkge1xuICAgIGlmICh1cGRhdGVEYXRhLndpdG5lc3NTY3JpcHQpIGNoZWNrSW52YWxpZFAyV1NIKHVwZGF0ZURhdGEud2l0bmVzc1NjcmlwdCk7XG4gICAgKDAsIGJpcDM3MV8xLmNoZWNrVGFwcm9vdElucHV0RmllbGRzKShcbiAgICAgIHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF0sXG4gICAgICB1cGRhdGVEYXRhLFxuICAgICAgJ3VwZGF0ZUlucHV0JyxcbiAgICApO1xuICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB1cGRhdGVEYXRhKTtcbiAgICBpZiAodXBkYXRlRGF0YS5ub25XaXRuZXNzVXR4bykge1xuICAgICAgYWRkTm9uV2l0bmVzc1R4Q2FjaGUoXG4gICAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgICAgdGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XSxcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVwZGF0ZU91dHB1dChvdXRwdXRJbmRleCwgdXBkYXRlRGF0YSkge1xuICAgIGNvbnN0IG91dHB1dERhdGEgPSB0aGlzLmRhdGEub3V0cHV0c1tvdXRwdXRJbmRleF07XG4gICAgKDAsIGJpcDM3MV8xLmNoZWNrVGFwcm9vdE91dHB1dEZpZWxkcykoXG4gICAgICBvdXRwdXREYXRhLFxuICAgICAgdXBkYXRlRGF0YSxcbiAgICAgICd1cGRhdGVPdXRwdXQnLFxuICAgICk7XG4gICAgdGhpcy5kYXRhLnVwZGF0ZU91dHB1dChvdXRwdXRJbmRleCwgdXBkYXRlRGF0YSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkVW5rbm93bktleVZhbFRvR2xvYmFsKGtleVZhbCkge1xuICAgIHRoaXMuZGF0YS5hZGRVbmtub3duS2V5VmFsVG9HbG9iYWwoa2V5VmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRVbmtub3duS2V5VmFsVG9JbnB1dChpbnB1dEluZGV4LCBrZXlWYWwpIHtcbiAgICB0aGlzLmRhdGEuYWRkVW5rbm93bktleVZhbFRvSW5wdXQoaW5wdXRJbmRleCwga2V5VmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRVbmtub3duS2V5VmFsVG9PdXRwdXQob3V0cHV0SW5kZXgsIGtleVZhbCkge1xuICAgIHRoaXMuZGF0YS5hZGRVbmtub3duS2V5VmFsVG9PdXRwdXQob3V0cHV0SW5kZXgsIGtleVZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KSB7XG4gICAgdGhpcy5kYXRhLmNsZWFyRmluYWxpemVkSW5wdXQoaW5wdXRJbmRleCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmV4cG9ydHMuUHNidCA9IFBzYnQ7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbmVlZGVkIHRvIHBhc3MgdG8gdGhlIGJpcDE3NCBiYXNlIGNsYXNzJ3MgZnJvbUJ1ZmZlci5cbiAqIEl0IHRha2VzIHRoZSBcInRyYW5zYWN0aW9uIGJ1ZmZlclwiIHBvcnRpb24gb2YgdGhlIHBzYnQgYnVmZmVyIGFuZCByZXR1cm5zIGFcbiAqIFRyYW5zYWN0aW9uIChGcm9tIHRoZSBiaXAxNzQgbGlicmFyeSkgaW50ZXJmYWNlLlxuICovXG5jb25zdCB0cmFuc2FjdGlvbkZyb21CdWZmZXIgPSBidWZmZXIgPT4gbmV3IFBzYnRUcmFuc2FjdGlvbihidWZmZXIpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIFRyYW5zYWN0aW9uIGludGVyZmFjZSBmcm9tIGJpcDE3NCBsaWJyYXJ5LlxuICogSXQgY29udGFpbnMgYSBiaXRjb2luanMtbGliIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAqL1xuY2xhc3MgUHNidFRyYW5zYWN0aW9uIHtcbiAgY29uc3RydWN0b3IoYnVmZmVyID0gQnVmZmVyLmZyb20oWzIsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSkge1xuICAgIHRoaXMudHggPSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLmZyb21CdWZmZXIoYnVmZmVyKTtcbiAgICBjaGVja1R4RW1wdHkodGhpcy50eCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG4gIH1cbiAgZ2V0SW5wdXRPdXRwdXRDb3VudHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0Q291bnQ6IHRoaXMudHguaW5zLmxlbmd0aCxcbiAgICAgIG91dHB1dENvdW50OiB0aGlzLnR4Lm91dHMubGVuZ3RoLFxuICAgIH07XG4gIH1cbiAgYWRkSW5wdXQoaW5wdXQpIHtcbiAgICBpZiAoXG4gICAgICBpbnB1dC5oYXNoID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGlucHV0LmluZGV4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICghQnVmZmVyLmlzQnVmZmVyKGlucHV0Lmhhc2gpICYmIHR5cGVvZiBpbnB1dC5oYXNoICE9PSAnc3RyaW5nJykgfHxcbiAgICAgIHR5cGVvZiBpbnB1dC5pbmRleCAhPT0gJ251bWJlcidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIGlucHV0LicpO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID1cbiAgICAgIHR5cGVvZiBpbnB1dC5oYXNoID09PSAnc3RyaW5nJ1xuICAgICAgICA/ICgwLCBidWZmZXJ1dGlsc18xLnJldmVyc2VCdWZmZXIpKEJ1ZmZlci5mcm9tKGlucHV0Lmhhc2gsICdoZXgnKSlcbiAgICAgICAgOiBpbnB1dC5oYXNoO1xuICAgIHRoaXMudHguYWRkSW5wdXQoaGFzaCwgaW5wdXQuaW5kZXgsIGlucHV0LnNlcXVlbmNlKTtcbiAgfVxuICBhZGRPdXRwdXQob3V0cHV0KSB7XG4gICAgaWYgKFxuICAgICAgb3V0cHV0LnNjcmlwdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBvdXRwdXQudmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgIUJ1ZmZlci5pc0J1ZmZlcihvdXRwdXQuc2NyaXB0KSB8fFxuICAgICAgdHlwZW9mIG91dHB1dC52YWx1ZSAhPT0gJ251bWJlcidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIG91dHB1dC4nKTtcbiAgICB9XG4gICAgdGhpcy50eC5hZGRPdXRwdXQob3V0cHV0LnNjcmlwdCwgb3V0cHV0LnZhbHVlKTtcbiAgfVxuICB0b0J1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy50eC50b0J1ZmZlcigpO1xuICB9XG59XG5mdW5jdGlvbiBjYW5GaW5hbGl6ZShpbnB1dCwgc2NyaXB0LCBzY3JpcHRUeXBlKSB7XG4gIHN3aXRjaCAoc2NyaXB0VHlwZSkge1xuICAgIGNhc2UgJ3B1YmtleSc6XG4gICAgY2FzZSAncHVia2V5aGFzaCc6XG4gICAgY2FzZSAnd2l0bmVzc3B1YmtleWhhc2gnOlxuICAgICAgcmV0dXJuIGhhc1NpZ3MoMSwgaW5wdXQucGFydGlhbFNpZyk7XG4gICAgY2FzZSAnbXVsdGlzaWcnOlxuICAgICAgY29uc3QgcDJtcyA9IHBheW1lbnRzLnAybXMoeyBvdXRwdXQ6IHNjcmlwdCB9KTtcbiAgICAgIHJldHVybiBoYXNTaWdzKHAybXMubSwgaW5wdXQucGFydGlhbFNpZywgcDJtcy5wdWJrZXlzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0NhY2hlKGNhY2hlKSB7XG4gIGlmIChjYWNoZS5fX1VOU0FGRV9TSUdOX05PTlNFR1dJVCAhPT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBCSVAxNzQgY29tcGxpYW50LCBjYW4gbm90IGV4cG9ydCcpO1xuICB9XG59XG5mdW5jdGlvbiBoYXNTaWdzKG5lZWRlZFNpZ3MsIHBhcnRpYWxTaWcsIHB1YmtleXMpIHtcbiAgaWYgKCFwYXJ0aWFsU2lnKSByZXR1cm4gZmFsc2U7XG4gIGxldCBzaWdzO1xuICBpZiAocHVia2V5cykge1xuICAgIHNpZ3MgPSBwdWJrZXlzXG4gICAgICAubWFwKHBrZXkgPT4ge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBjb21wcmVzc1B1YmtleShwa2V5KTtcbiAgICAgICAgcmV0dXJuIHBhcnRpYWxTaWcuZmluZChwU2lnID0+IHBTaWcucHVia2V5LmVxdWFscyhwdWJrZXkpKTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKHYgPT4gISF2KTtcbiAgfSBlbHNlIHtcbiAgICBzaWdzID0gcGFydGlhbFNpZztcbiAgfVxuICBpZiAoc2lncy5sZW5ndGggPiBuZWVkZWRTaWdzKSB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHNpZ25hdHVyZXMnKTtcbiAgcmV0dXJuIHNpZ3MubGVuZ3RoID09PSBuZWVkZWRTaWdzO1xufVxuZnVuY3Rpb24gaXNGaW5hbGl6ZWQoaW5wdXQpIHtcbiAgcmV0dXJuICEhaW5wdXQuZmluYWxTY3JpcHRTaWcgfHwgISFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3M7XG59XG5mdW5jdGlvbiBiaXAzMkRlcml2YXRpb25Jc01pbmUocm9vdCkge1xuICByZXR1cm4gZCA9PiB7XG4gICAgaWYgKCFkLm1hc3RlckZpbmdlcnByaW50LmVxdWFscyhyb290LmZpbmdlcnByaW50KSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghcm9vdC5kZXJpdmVQYXRoKGQucGF0aCkucHVibGljS2V5LmVxdWFscyhkLnB1YmtleSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrMzJCaXQobnVtKSB7XG4gIGlmIChcbiAgICB0eXBlb2YgbnVtICE9PSAnbnVtYmVyJyB8fFxuICAgIG51bSAhPT0gTWF0aC5mbG9vcihudW0pIHx8XG4gICAgbnVtID4gMHhmZmZmZmZmZiB8fFxuICAgIG51bSA8IDBcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIDMyIGJpdCBpbnRlZ2VyJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRmVlcyhwc2J0LCBjYWNoZSwgb3B0cykge1xuICBjb25zdCBmZWVSYXRlID0gY2FjaGUuX19GRUVfUkFURSB8fCBwc2J0LmdldEZlZVJhdGUoKTtcbiAgY29uc3QgdnNpemUgPSBjYWNoZS5fX0VYVFJBQ1RFRF9UWC52aXJ0dWFsU2l6ZSgpO1xuICBjb25zdCBzYXRvc2hpcyA9IGZlZVJhdGUgKiB2c2l6ZTtcbiAgaWYgKGZlZVJhdGUgPj0gb3B0cy5tYXhpbXVtRmVlUmF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBXYXJuaW5nOiBZb3UgYXJlIHBheWluZyBhcm91bmQgJHsoc2F0b3NoaXMgLyAxZTgpLnRvRml4ZWQoOCl9IGluIGAgK1xuICAgICAgICBgZmVlcywgd2hpY2ggaXMgJHtmZWVSYXRlfSBzYXRvc2hpIHBlciBieXRlIGZvciBhIHRyYW5zYWN0aW9uIGAgK1xuICAgICAgICBgd2l0aCBhIFZTaXplIG9mICR7dnNpemV9IGJ5dGVzIChzZWd3aXQgY291bnRlZCBhcyAwLjI1IGJ5dGUgcGVyIGAgK1xuICAgICAgICBgYnl0ZSkuIFVzZSBzZXRNYXhpbXVtRmVlUmF0ZSBtZXRob2QgdG8gcmFpc2UgeW91ciB0aHJlc2hvbGQsIG9yIGAgK1xuICAgICAgICBgcGFzcyB0cnVlIHRvIHRoZSBmaXJzdCBhcmcgb2YgZXh0cmFjdFRyYW5zYWN0aW9uLmAsXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbnB1dHNGb3JQYXJ0aWFsU2lnKGlucHV0cywgYWN0aW9uKSB7XG4gIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICBjb25zdCB0aHJvd3MgPSAoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KVxuICAgICAgPyAoMCwgYmlwMzcxXzEuY2hlY2tUYXByb290SW5wdXRGb3JTaWdzKShpbnB1dCwgYWN0aW9uKVxuICAgICAgOiAoMCwgcHNidHV0aWxzXzEuY2hlY2tJbnB1dEZvclNpZykoaW5wdXQsIGFjdGlvbik7XG4gICAgaWYgKHRocm93cylcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBtb2RpZnkgdHJhbnNhY3Rpb24sIHNpZ25hdHVyZXMgZXhpc3QuJyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tQYXJ0aWFsU2lnU2lnaGFzaGVzKGlucHV0KSB7XG4gIGlmICghaW5wdXQuc2lnaGFzaFR5cGUgfHwgIWlucHV0LnBhcnRpYWxTaWcpIHJldHVybjtcbiAgY29uc3QgeyBwYXJ0aWFsU2lnLCBzaWdoYXNoVHlwZSB9ID0gaW5wdXQ7XG4gIHBhcnRpYWxTaWcuZm9yRWFjaChwU2lnID0+IHtcbiAgICBjb25zdCB7IGhhc2hUeXBlIH0gPSBic2NyaXB0LnNpZ25hdHVyZS5kZWNvZGUocFNpZy5zaWduYXR1cmUpO1xuICAgIGlmIChzaWdoYXNoVHlwZSAhPT0gaGFzaFR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIHNpZ2hhc2ggZG9lcyBub3QgbWF0Y2ggaW5wdXQgc2lnaGFzaCB0eXBlJyk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2NyaXB0Rm9yUHVia2V5KHB1YmtleSwgc2NyaXB0LCBhY3Rpb24pIHtcbiAgaWYgKCEoMCwgcHNidHV0aWxzXzEucHVia2V5SW5TY3JpcHQpKHB1YmtleSwgc2NyaXB0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW4gbm90ICR7YWN0aW9ufSBmb3IgdGhpcyBpbnB1dCB3aXRoIHRoZSBrZXkgJHtwdWJrZXkudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tUeEVtcHR5KHR4KSB7XG4gIGNvbnN0IGlzRW1wdHkgPSB0eC5pbnMuZXZlcnkoXG4gICAgaW5wdXQgPT5cbiAgICAgIGlucHV0LnNjcmlwdCAmJlxuICAgICAgaW5wdXQuc2NyaXB0Lmxlbmd0aCA9PT0gMCAmJlxuICAgICAgaW5wdXQud2l0bmVzcyAmJlxuICAgICAgaW5wdXQud2l0bmVzcy5sZW5ndGggPT09IDAsXG4gICk7XG4gIGlmICghaXNFbXB0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBUcmFuc2FjdGlvbiBTY3JpcHRTaWdzIGFyZSBub3QgZW1wdHknKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tUeEZvckR1cGVJbnModHgsIGNhY2hlKSB7XG4gIHR4Lmlucy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICBjaGVja1R4SW5wdXRDYWNoZShjYWNoZSwgaW5wdXQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNoZWNrVHhJbnB1dENhY2hlKGNhY2hlLCBpbnB1dCkge1xuICBjb25zdCBrZXkgPVxuICAgICgwLCBidWZmZXJ1dGlsc18xLnJldmVyc2VCdWZmZXIpKEJ1ZmZlci5mcm9tKGlucHV0Lmhhc2gpKS50b1N0cmluZygnaGV4JykgK1xuICAgICc6JyArXG4gICAgaW5wdXQuaW5kZXg7XG4gIGlmIChjYWNoZS5fX1RYX0lOX0NBQ0hFW2tleV0pIHRocm93IG5ldyBFcnJvcignRHVwbGljYXRlIGlucHV0IGRldGVjdGVkLicpO1xuICBjYWNoZS5fX1RYX0lOX0NBQ0hFW2tleV0gPSAxO1xufVxuZnVuY3Rpb24gc2NyaXB0Q2hlY2tlckZhY3RvcnkocGF5bWVudCwgcGF5bWVudFNjcmlwdE5hbWUpIHtcbiAgcmV0dXJuIChpbnB1dEluZGV4LCBzY3JpcHRQdWJLZXksIHJlZGVlbVNjcmlwdCwgaW9UeXBlKSA9PiB7XG4gICAgY29uc3QgcmVkZWVtU2NyaXB0T3V0cHV0ID0gcGF5bWVudCh7XG4gICAgICByZWRlZW06IHsgb3V0cHV0OiByZWRlZW1TY3JpcHQgfSxcbiAgICB9KS5vdXRwdXQ7XG4gICAgaWYgKCFzY3JpcHRQdWJLZXkuZXF1YWxzKHJlZGVlbVNjcmlwdE91dHB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7cGF5bWVudFNjcmlwdE5hbWV9IGZvciAke2lvVHlwZX0gIyR7aW5wdXRJbmRleH0gZG9lc24ndCBtYXRjaCB0aGUgc2NyaXB0UHViS2V5IGluIHRoZSBwcmV2b3V0YCxcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgY2hlY2tSZWRlZW1TY3JpcHQgPSBzY3JpcHRDaGVja2VyRmFjdG9yeShwYXltZW50cy5wMnNoLCAnUmVkZWVtIHNjcmlwdCcpO1xuY29uc3QgY2hlY2tXaXRuZXNzU2NyaXB0ID0gc2NyaXB0Q2hlY2tlckZhY3RvcnkoXG4gIHBheW1lbnRzLnAyd3NoLFxuICAnV2l0bmVzcyBzY3JpcHQnLFxuKTtcbmZ1bmN0aW9uIGdldFR4Q2FjaGVWYWx1ZShrZXksIG5hbWUsIGlucHV0cywgYykge1xuICBpZiAoIWlucHV0cy5ldmVyeShpc0ZpbmFsaXplZCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBQU0JUIG11c3QgYmUgZmluYWxpemVkIHRvIGNhbGN1bGF0ZSAke25hbWV9YCk7XG4gIGlmIChrZXkgPT09ICdfX0ZFRV9SQVRFJyAmJiBjLl9fRkVFX1JBVEUpIHJldHVybiBjLl9fRkVFX1JBVEU7XG4gIGlmIChrZXkgPT09ICdfX0ZFRScgJiYgYy5fX0ZFRSkgcmV0dXJuIGMuX19GRUU7XG4gIGxldCB0eDtcbiAgbGV0IG11c3RGaW5hbGl6ZSA9IHRydWU7XG4gIGlmIChjLl9fRVhUUkFDVEVEX1RYKSB7XG4gICAgdHggPSBjLl9fRVhUUkFDVEVEX1RYO1xuICAgIG11c3RGaW5hbGl6ZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHR4ID0gYy5fX1RYLmNsb25lKCk7XG4gIH1cbiAgaW5wdXRGaW5hbGl6ZUdldEFtdHMoaW5wdXRzLCB0eCwgYywgbXVzdEZpbmFsaXplKTtcbiAgaWYgKGtleSA9PT0gJ19fRkVFX1JBVEUnKSByZXR1cm4gYy5fX0ZFRV9SQVRFO1xuICBlbHNlIGlmIChrZXkgPT09ICdfX0ZFRScpIHJldHVybiBjLl9fRkVFO1xufVxuZnVuY3Rpb24gZ2V0RmluYWxTY3JpcHRzKGlucHV0SW5kZXgsIGlucHV0LCBzY3JpcHQsIGlzU2Vnd2l0LCBpc1AyU0gsIGlzUDJXU0gpIHtcbiAgY29uc3Qgc2NyaXB0VHlwZSA9IGNsYXNzaWZ5U2NyaXB0KHNjcmlwdCk7XG4gIGlmICghY2FuRmluYWxpemUoaW5wdXQsIHNjcmlwdCwgc2NyaXB0VHlwZSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGZpbmFsaXplIGlucHV0ICMke2lucHV0SW5kZXh9YCk7XG4gIHJldHVybiBwcmVwYXJlRmluYWxTY3JpcHRzKFxuICAgIHNjcmlwdCxcbiAgICBzY3JpcHRUeXBlLFxuICAgIGlucHV0LnBhcnRpYWxTaWcsXG4gICAgaXNTZWd3aXQsXG4gICAgaXNQMlNILFxuICAgIGlzUDJXU0gsXG4gICk7XG59XG5mdW5jdGlvbiBwcmVwYXJlRmluYWxTY3JpcHRzKFxuICBzY3JpcHQsXG4gIHNjcmlwdFR5cGUsXG4gIHBhcnRpYWxTaWcsXG4gIGlzU2Vnd2l0LFxuICBpc1AyU0gsXG4gIGlzUDJXU0gsXG4pIHtcbiAgbGV0IGZpbmFsU2NyaXB0U2lnO1xuICBsZXQgZmluYWxTY3JpcHRXaXRuZXNzO1xuICAvLyBXb3csIHRoZSBwYXltZW50cyBBUEkgaXMgdmVyeSBoYW5keVxuICBjb25zdCBwYXltZW50ID0gZ2V0UGF5bWVudChzY3JpcHQsIHNjcmlwdFR5cGUsIHBhcnRpYWxTaWcpO1xuICBjb25zdCBwMndzaCA9ICFpc1AyV1NIID8gbnVsbCA6IHBheW1lbnRzLnAyd3NoKHsgcmVkZWVtOiBwYXltZW50IH0pO1xuICBjb25zdCBwMnNoID0gIWlzUDJTSCA/IG51bGwgOiBwYXltZW50cy5wMnNoKHsgcmVkZWVtOiBwMndzaCB8fCBwYXltZW50IH0pO1xuICBpZiAoaXNTZWd3aXQpIHtcbiAgICBpZiAocDJ3c2gpIHtcbiAgICAgIGZpbmFsU2NyaXB0V2l0bmVzcyA9ICgwLCBwc2J0dXRpbHNfMS53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MpKFxuICAgICAgICBwMndzaC53aXRuZXNzLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluYWxTY3JpcHRXaXRuZXNzID0gKDAsIHBzYnR1dGlsc18xLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcykoXG4gICAgICAgIHBheW1lbnQud2l0bmVzcyxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwMnNoKSB7XG4gICAgICBmaW5hbFNjcmlwdFNpZyA9IHAyc2guaW5wdXQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwMnNoKSB7XG4gICAgICBmaW5hbFNjcmlwdFNpZyA9IHAyc2guaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmFsU2NyaXB0U2lnID0gcGF5bWVudC5pbnB1dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmaW5hbFNjcmlwdFNpZyxcbiAgICBmaW5hbFNjcmlwdFdpdG5lc3MsXG4gIH07XG59XG5mdW5jdGlvbiBnZXRIYXNoQW5kU2lnaGFzaFR5cGUoXG4gIGlucHV0cyxcbiAgaW5wdXRJbmRleCxcbiAgcHVia2V5LFxuICBjYWNoZSxcbiAgc2lnaGFzaFR5cGVzLFxuKSB7XG4gIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkoaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgY29uc3QgeyBoYXNoLCBzaWdoYXNoVHlwZSwgc2NyaXB0IH0gPSBnZXRIYXNoRm9yU2lnKFxuICAgIGlucHV0SW5kZXgsXG4gICAgaW5wdXQsXG4gICAgY2FjaGUsXG4gICAgZmFsc2UsXG4gICAgc2lnaGFzaFR5cGVzLFxuICApO1xuICBjaGVja1NjcmlwdEZvclB1YmtleShwdWJrZXksIHNjcmlwdCwgJ3NpZ24nKTtcbiAgcmV0dXJuIHtcbiAgICBoYXNoLFxuICAgIHNpZ2hhc2hUeXBlLFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFzaEZvclNpZyhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUsIGZvclZhbGlkYXRlLCBzaWdoYXNoVHlwZXMpIHtcbiAgY29uc3QgdW5zaWduZWRUeCA9IGNhY2hlLl9fVFg7XG4gIGNvbnN0IHNpZ2hhc2hUeXBlID1cbiAgICBpbnB1dC5zaWdoYXNoVHlwZSB8fCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMO1xuICBjaGVja1NpZ2hhc2hUeXBlQWxsb3dlZChzaWdoYXNoVHlwZSwgc2lnaGFzaFR5cGVzKTtcbiAgbGV0IGhhc2g7XG4gIGxldCBwcmV2b3V0O1xuICBpZiAoaW5wdXQubm9uV2l0bmVzc1V0eG8pIHtcbiAgICBjb25zdCBub25XaXRuZXNzVXR4b1R4ID0gbm9uV2l0bmVzc1V0eG9UeEZyb21DYWNoZShcbiAgICAgIGNhY2hlLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnB1dEluZGV4LFxuICAgICk7XG4gICAgY29uc3QgcHJldm91dEhhc2ggPSB1bnNpZ25lZFR4Lmluc1tpbnB1dEluZGV4XS5oYXNoO1xuICAgIGNvbnN0IHV0eG9IYXNoID0gbm9uV2l0bmVzc1V0eG9UeC5nZXRIYXNoKCk7XG4gICAgLy8gSWYgYSBub24td2l0bmVzcyBVVFhPIGlzIHByb3ZpZGVkLCBpdHMgaGFzaCBtdXN0IG1hdGNoIHRoZSBoYXNoIHNwZWNpZmllZCBpbiB0aGUgcHJldm91dFxuICAgIGlmICghcHJldm91dEhhc2guZXF1YWxzKHV0eG9IYXNoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTm9uLXdpdG5lc3MgVVRYTyBoYXNoIGZvciBpbnB1dCAjJHtpbnB1dEluZGV4fSBkb2Vzbid0IG1hdGNoIHRoZSBoYXNoIHNwZWNpZmllZCBpbiB0aGUgcHJldm91dGAsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBwcmV2b3V0SW5kZXggPSB1bnNpZ25lZFR4Lmluc1tpbnB1dEluZGV4XS5pbmRleDtcbiAgICBwcmV2b3V0ID0gbm9uV2l0bmVzc1V0eG9UeC5vdXRzW3ByZXZvdXRJbmRleF07XG4gIH0gZWxzZSBpZiAoaW5wdXQud2l0bmVzc1V0eG8pIHtcbiAgICBwcmV2b3V0ID0gaW5wdXQud2l0bmVzc1V0eG87XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGEgVXR4byBpbnB1dCBpdGVtIGZvciBzaWduaW5nJyk7XG4gIH1cbiAgY29uc3QgeyBtZWFuaW5nZnVsU2NyaXB0LCB0eXBlIH0gPSBnZXRNZWFuaW5nZnVsU2NyaXB0KFxuICAgIHByZXZvdXQuc2NyaXB0LFxuICAgIGlucHV0SW5kZXgsXG4gICAgJ2lucHV0JyxcbiAgICBpbnB1dC5yZWRlZW1TY3JpcHQsXG4gICAgaW5wdXQud2l0bmVzc1NjcmlwdCxcbiAgKTtcbiAgaWYgKFsncDJzaC1wMndzaCcsICdwMndzaCddLmluZGV4T2YodHlwZSkgPj0gMCkge1xuICAgIGhhc2ggPSB1bnNpZ25lZFR4Lmhhc2hGb3JXaXRuZXNzVjAoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgbWVhbmluZ2Z1bFNjcmlwdCxcbiAgICAgIHByZXZvdXQudmFsdWUsXG4gICAgICBzaWdoYXNoVHlwZSxcbiAgICApO1xuICB9IGVsc2UgaWYgKCgwLCBwc2J0dXRpbHNfMS5pc1AyV1BLSCkobWVhbmluZ2Z1bFNjcmlwdCkpIHtcbiAgICAvLyBQMldQS0ggdXNlcyB0aGUgUDJQS0ggdGVtcGxhdGUgZm9yIHByZXZvdXRTY3JpcHQgd2hlbiBzaWduaW5nXG4gICAgY29uc3Qgc2lnbmluZ1NjcmlwdCA9IHBheW1lbnRzLnAycGtoKHtcbiAgICAgIGhhc2g6IG1lYW5pbmdmdWxTY3JpcHQuc2xpY2UoMiksXG4gICAgfSkub3V0cHV0O1xuICAgIGhhc2ggPSB1bnNpZ25lZFR4Lmhhc2hGb3JXaXRuZXNzVjAoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgc2lnbmluZ1NjcmlwdCxcbiAgICAgIHByZXZvdXQudmFsdWUsXG4gICAgICBzaWdoYXNoVHlwZSxcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbi1zZWd3aXRcbiAgICBpZiAoXG4gICAgICBpbnB1dC5ub25XaXRuZXNzVXR4byA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBjYWNoZS5fX1VOU0FGRV9TSUdOX05PTlNFR1dJVCA9PT0gZmFsc2VcbiAgICApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnB1dCAjJHtpbnB1dEluZGV4fSBoYXMgd2l0bmVzc1V0eG8gYnV0IG5vbi1zZWd3aXQgc2NyaXB0OiBgICtcbiAgICAgICAgICBgJHttZWFuaW5nZnVsU2NyaXB0LnRvU3RyaW5nKCdoZXgnKX1gLFxuICAgICAgKTtcbiAgICBpZiAoIWZvclZhbGlkYXRlICYmIGNhY2hlLl9fVU5TQUZFX1NJR05fTk9OU0VHV0lUICE9PSBmYWxzZSlcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ1dhcm5pbmc6IFNpZ25pbmcgbm9uLXNlZ3dpdCBpbnB1dHMgd2l0aG91dCB0aGUgZnVsbCBwYXJlbnQgdHJhbnNhY3Rpb24gJyArXG4gICAgICAgICAgJ21lYW5zIHRoZXJlIGlzIGEgY2hhbmNlIHRoYXQgYSBtaW5lciBjb3VsZCBmZWVkIHlvdSBpbmNvcnJlY3QgaW5mb3JtYXRpb24gJyArXG4gICAgICAgICAgXCJ0byB0cmljayB5b3UgaW50byBwYXlpbmcgbGFyZ2UgZmVlcy4gVGhpcyBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBQc2J0J3MgcHJlZGVjZXNzb3IgXCIgK1xuICAgICAgICAgICcoVHJhbnNhY3Rpb25CdWlsZGVyIC0gbm93IHJlbW92ZWQpIHdoZW4gc2lnbmluZyBub24tc2Vnd2l0IHNjcmlwdHMuIFlvdSBhcmUgbm90ICcgK1xuICAgICAgICAgICdhYmxlIHRvIGV4cG9ydCB0aGlzIFBzYnQgd2l0aCB0b0J1ZmZlcnx0b0Jhc2U2NHx0b0hleCBzaW5jZSBpdCBpcyBub3QgJyArXG4gICAgICAgICAgJ0JJUDE3NCBjb21wbGlhbnQuXFxuKioqKioqKioqKioqKioqKioqKioqXFxuUFJPQ0VFRCBXSVRIIENBVVRJT04hXFxuJyArXG4gICAgICAgICAgJyoqKioqKioqKioqKioqKioqKioqKicsXG4gICAgICApO1xuICAgIGhhc2ggPSB1bnNpZ25lZFR4Lmhhc2hGb3JTaWduYXR1cmUoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgbWVhbmluZ2Z1bFNjcmlwdCxcbiAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JpcHQ6IG1lYW5pbmdmdWxTY3JpcHQsXG4gICAgc2lnaGFzaFR5cGUsXG4gICAgaGFzaCxcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFsbFRhcHJvb3RIYXNoZXNGb3JTaWcoaW5wdXRJbmRleCwgaW5wdXQsIGlucHV0cywgY2FjaGUpIHtcbiAgY29uc3QgYWxsUHVibGljS2V5cyA9IFtdO1xuICBpZiAoaW5wdXQudGFwSW50ZXJuYWxLZXkpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRQcmV2b3V0VGFwcm9vdEtleShpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIGFsbFB1YmxpY0tleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQudGFwU2NyaXB0U2lnKSB7XG4gICAgY29uc3QgdGFwU2NyaXB0UHVia2V5cyA9IGlucHV0LnRhcFNjcmlwdFNpZy5tYXAodHNzID0+IHRzcy5wdWJrZXkpO1xuICAgIGFsbFB1YmxpY0tleXMucHVzaCguLi50YXBTY3JpcHRQdWJrZXlzKTtcbiAgfVxuICBjb25zdCBhbGxIYXNoZXMgPSBhbGxQdWJsaWNLZXlzLm1hcChwdWJpY0tleSA9PlxuICAgIGdldFRhcHJvb3RIYXNoZXNGb3JTaWcoaW5wdXRJbmRleCwgaW5wdXQsIGlucHV0cywgcHViaWNLZXksIGNhY2hlKSxcbiAgKTtcbiAgcmV0dXJuIGFsbEhhc2hlcy5mbGF0KCk7XG59XG5mdW5jdGlvbiBnZXRQcmV2b3V0VGFwcm9vdEtleShpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpIHtcbiAgY29uc3QgeyBzY3JpcHQgfSA9IGdldFNjcmlwdEFuZEFtb3VudEZyb21VdHhvKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSk7XG4gIHJldHVybiAoMCwgcHNidHV0aWxzXzEuaXNQMlRSKShzY3JpcHQpID8gc2NyaXB0LnN1YmFycmF5KDIsIDM0KSA6IG51bGw7XG59XG5mdW5jdGlvbiB0cmltVGFwcm9vdFNpZyhzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHNpZ25hdHVyZS5sZW5ndGggPT09IDY0ID8gc2lnbmF0dXJlIDogc2lnbmF0dXJlLnN1YmFycmF5KDAsIDY0KTtcbn1cbmZ1bmN0aW9uIGdldFRhcHJvb3RIYXNoZXNGb3JTaWcoXG4gIGlucHV0SW5kZXgsXG4gIGlucHV0LFxuICBpbnB1dHMsXG4gIHB1YmtleSxcbiAgY2FjaGUsXG4gIHRhcExlYWZIYXNoVG9TaWduLFxuICBhbGxvd2VkU2lnaGFzaFR5cGVzLFxuKSB7XG4gIGNvbnN0IHVuc2lnbmVkVHggPSBjYWNoZS5fX1RYO1xuICBjb25zdCBzaWdoYXNoVHlwZSA9XG4gICAgaW5wdXQuc2lnaGFzaFR5cGUgfHwgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0RFRkFVTFQ7XG4gIGNoZWNrU2lnaGFzaFR5cGVBbGxvd2VkKHNpZ2hhc2hUeXBlLCBhbGxvd2VkU2lnaGFzaFR5cGVzKTtcbiAgY29uc3QgcHJldk91dHMgPSBpbnB1dHMubWFwKChpLCBpbmRleCkgPT5cbiAgICBnZXRTY3JpcHRBbmRBbW91bnRGcm9tVXR4byhpbmRleCwgaSwgY2FjaGUpLFxuICApO1xuICBjb25zdCBzaWduaW5nU2NyaXB0cyA9IHByZXZPdXRzLm1hcChvID0+IG8uc2NyaXB0KTtcbiAgY29uc3QgdmFsdWVzID0gcHJldk91dHMubWFwKG8gPT4gby52YWx1ZSk7XG4gIGNvbnN0IGhhc2hlcyA9IFtdO1xuICBpZiAoaW5wdXQudGFwSW50ZXJuYWxLZXkgJiYgIXRhcExlYWZIYXNoVG9TaWduKSB7XG4gICAgY29uc3Qgb3V0cHV0S2V5ID1cbiAgICAgIGdldFByZXZvdXRUYXByb290S2V5KGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSkgfHwgQnVmZmVyLmZyb20oW10pO1xuICAgIGlmICgoMCwgYmlwMzcxXzEudG9YT25seSkocHVia2V5KS5lcXVhbHMob3V0cHV0S2V5KSkge1xuICAgICAgY29uc3QgdGFwS2V5SGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMShcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgc2lnbmluZ1NjcmlwdHMsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgc2lnaGFzaFR5cGUsXG4gICAgICApO1xuICAgICAgaGFzaGVzLnB1c2goeyBwdWJrZXksIGhhc2g6IHRhcEtleUhhc2ggfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRhcExlYWZIYXNoZXMgPSAoaW5wdXQudGFwTGVhZlNjcmlwdCB8fCBbXSlcbiAgICAuZmlsdGVyKHRhcExlYWYgPT4gKDAsIHBzYnR1dGlsc18xLnB1YmtleUluU2NyaXB0KShwdWJrZXksIHRhcExlYWYuc2NyaXB0KSlcbiAgICAubWFwKHRhcExlYWYgPT4ge1xuICAgICAgY29uc3QgaGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgICAgICBvdXRwdXQ6IHRhcExlYWYuc2NyaXB0LFxuICAgICAgICB2ZXJzaW9uOiB0YXBMZWFmLmxlYWZWZXJzaW9uLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGhhc2ggfSwgdGFwTGVhZik7XG4gICAgfSlcbiAgICAuZmlsdGVyKFxuICAgICAgdGFwTGVhZiA9PiAhdGFwTGVhZkhhc2hUb1NpZ24gfHwgdGFwTGVhZkhhc2hUb1NpZ24uZXF1YWxzKHRhcExlYWYuaGFzaCksXG4gICAgKVxuICAgIC5tYXAodGFwTGVhZiA9PiB7XG4gICAgICBjb25zdCB0YXBTY3JpcHRIYXNoID0gdW5zaWduZWRUeC5oYXNoRm9yV2l0bmVzc1YxKFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBzaWduaW5nU2NyaXB0cyxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBzaWdoYXNoVHlwZSxcbiAgICAgICAgdGFwTGVhZi5oYXNoLFxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHB1YmtleSxcbiAgICAgICAgaGFzaDogdGFwU2NyaXB0SGFzaCxcbiAgICAgICAgbGVhZkhhc2g6IHRhcExlYWYuaGFzaCxcbiAgICAgIH07XG4gICAgfSk7XG4gIHJldHVybiBoYXNoZXMuY29uY2F0KHRhcExlYWZIYXNoZXMpO1xufVxuZnVuY3Rpb24gY2hlY2tTaWdoYXNoVHlwZUFsbG93ZWQoc2lnaGFzaFR5cGUsIHNpZ2hhc2hUeXBlcykge1xuICBpZiAoc2lnaGFzaFR5cGVzICYmIHNpZ2hhc2hUeXBlcy5pbmRleE9mKHNpZ2hhc2hUeXBlKSA8IDApIHtcbiAgICBjb25zdCBzdHIgPSBzaWdoYXNoVHlwZVRvU3RyaW5nKHNpZ2hhc2hUeXBlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgU2lnaGFzaCB0eXBlIGlzIG5vdCBhbGxvd2VkLiBSZXRyeSB0aGUgc2lnbiBtZXRob2QgcGFzc2luZyB0aGUgYCArXG4gICAgICAgIGBzaWdoYXNoVHlwZXMgYXJyYXkgb2Ygd2hpdGVsaXN0ZWQgdHlwZXMuIFNpZ2hhc2ggdHlwZTogJHtzdHJ9YCxcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQYXltZW50KHNjcmlwdCwgc2NyaXB0VHlwZSwgcGFydGlhbFNpZykge1xuICBsZXQgcGF5bWVudDtcbiAgc3dpdGNoIChzY3JpcHRUeXBlKSB7XG4gICAgY2FzZSAnbXVsdGlzaWcnOlxuICAgICAgY29uc3Qgc2lncyA9IGdldFNvcnRlZFNpZ3Moc2NyaXB0LCBwYXJ0aWFsU2lnKTtcbiAgICAgIHBheW1lbnQgPSBwYXltZW50cy5wMm1zKHtcbiAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgIHNpZ25hdHVyZXM6IHNpZ3MsXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3B1YmtleSc6XG4gICAgICBwYXltZW50ID0gcGF5bWVudHMucDJwayh7XG4gICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICBzaWduYXR1cmU6IHBhcnRpYWxTaWdbMF0uc2lnbmF0dXJlLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwdWJrZXloYXNoJzpcbiAgICAgIHBheW1lbnQgPSBwYXltZW50cy5wMnBraCh7XG4gICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICBwdWJrZXk6IHBhcnRpYWxTaWdbMF0ucHVia2V5LFxuICAgICAgICBzaWduYXR1cmU6IHBhcnRpYWxTaWdbMF0uc2lnbmF0dXJlLFxuICAgICAgfSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3aXRuZXNzcHVia2V5aGFzaCc6XG4gICAgICBwYXltZW50ID0gcGF5bWVudHMucDJ3cGtoKHtcbiAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgIHB1YmtleTogcGFydGlhbFNpZ1swXS5wdWJrZXksXG4gICAgICAgIHNpZ25hdHVyZTogcGFydGlhbFNpZ1swXS5zaWduYXR1cmUsXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBwYXltZW50O1xufVxuZnVuY3Rpb24gZ2V0U2NyaXB0RnJvbUlucHV0KGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSkge1xuICBjb25zdCB1bnNpZ25lZFR4ID0gY2FjaGUuX19UWDtcbiAgY29uc3QgcmVzID0ge1xuICAgIHNjcmlwdDogbnVsbCxcbiAgICBpc1NlZ3dpdDogZmFsc2UsXG4gICAgaXNQMlNIOiBmYWxzZSxcbiAgICBpc1AyV1NIOiBmYWxzZSxcbiAgfTtcbiAgcmVzLmlzUDJTSCA9ICEhaW5wdXQucmVkZWVtU2NyaXB0O1xuICByZXMuaXNQMldTSCA9ICEhaW5wdXQud2l0bmVzc1NjcmlwdDtcbiAgaWYgKGlucHV0LndpdG5lc3NTY3JpcHQpIHtcbiAgICByZXMuc2NyaXB0ID0gaW5wdXQud2l0bmVzc1NjcmlwdDtcbiAgfSBlbHNlIGlmIChpbnB1dC5yZWRlZW1TY3JpcHQpIHtcbiAgICByZXMuc2NyaXB0ID0gaW5wdXQucmVkZWVtU2NyaXB0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgY29uc3Qgbm9uV2l0bmVzc1V0eG9UeCA9IG5vbldpdG5lc3NVdHhvVHhGcm9tQ2FjaGUoXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICk7XG4gICAgICBjb25zdCBwcmV2b3V0SW5kZXggPSB1bnNpZ25lZFR4Lmluc1tpbnB1dEluZGV4XS5pbmRleDtcbiAgICAgIHJlcy5zY3JpcHQgPSBub25XaXRuZXNzVXR4b1R4Lm91dHNbcHJldm91dEluZGV4XS5zY3JpcHQ7XG4gICAgfSBlbHNlIGlmIChpbnB1dC53aXRuZXNzVXR4bykge1xuICAgICAgcmVzLnNjcmlwdCA9IGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdDtcbiAgICB9XG4gIH1cbiAgaWYgKGlucHV0LndpdG5lc3NTY3JpcHQgfHwgKDAsIHBzYnR1dGlsc18xLmlzUDJXUEtIKShyZXMuc2NyaXB0KSkge1xuICAgIHJlcy5pc1NlZ3dpdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdldFNpZ25lcnNGcm9tSEQoaW5wdXRJbmRleCwgaW5wdXRzLCBoZEtleVBhaXIpIHtcbiAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KShpbnB1dHMsIGlucHV0SW5kZXgpO1xuICBpZiAoIWlucHV0LmJpcDMyRGVyaXZhdGlvbiB8fCBpbnB1dC5iaXAzMkRlcml2YXRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIGJpcDMyRGVyaXZhdGlvbiB0byBzaWduIHdpdGggSEQnKTtcbiAgfVxuICBjb25zdCBteURlcml2YXRpb25zID0gaW5wdXQuYmlwMzJEZXJpdmF0aW9uXG4gICAgLm1hcChiaXBEdiA9PiB7XG4gICAgICBpZiAoYmlwRHYubWFzdGVyRmluZ2VycHJpbnQuZXF1YWxzKGhkS2V5UGFpci5maW5nZXJwcmludCkpIHtcbiAgICAgICAgcmV0dXJuIGJpcER2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcih2ID0+ICEhdik7XG4gIGlmIChteURlcml2YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdOZWVkIG9uZSBiaXAzMkRlcml2YXRpb24gbWFzdGVyRmluZ2VycHJpbnQgdG8gbWF0Y2ggdGhlIEhEU2lnbmVyIGZpbmdlcnByaW50JyxcbiAgICApO1xuICB9XG4gIGNvbnN0IHNpZ25lcnMgPSBteURlcml2YXRpb25zLm1hcChiaXBEdiA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGhkS2V5UGFpci5kZXJpdmVQYXRoKGJpcER2LnBhdGgpO1xuICAgIGlmICghYmlwRHYucHVia2V5LmVxdWFscyhub2RlLnB1YmxpY0tleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHVia2V5IGRpZCBub3QgbWF0Y2ggYmlwMzJEZXJpdmF0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9KTtcbiAgcmV0dXJuIHNpZ25lcnM7XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWRTaWdzKHNjcmlwdCwgcGFydGlhbFNpZykge1xuICBjb25zdCBwMm1zID0gcGF5bWVudHMucDJtcyh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAvLyBmb3IgZWFjaCBwdWJrZXkgaW4gb3JkZXIgb2YgcDJtcyBzY3JpcHRcbiAgcmV0dXJuIHAybXMucHVia2V5c1xuICAgIC5tYXAocGsgPT4ge1xuICAgICAgLy8gZmlsdGVyIHBhcnRpYWxTaWcgYXJyYXkgYnkgcHVia2V5IGJlaW5nIGVxdWFsXG4gICAgICByZXR1cm4gKFxuICAgICAgICBwYXJ0aWFsU2lnLmZpbHRlcihwcyA9PiB7XG4gICAgICAgICAgcmV0dXJuIHBzLnB1YmtleS5lcXVhbHMocGspO1xuICAgICAgICB9KVswXSB8fCB7fVxuICAgICAgKS5zaWduYXR1cmU7XG4gICAgICAvLyBBbnkgcHVia2V5IHdpdGhvdXQgYSBtYXRjaCB3aWxsIHJldHVybiB1bmRlZmluZWRcbiAgICAgIC8vIHRoaXMgbGFzdCBmaWx0ZXIgcmVtb3ZlcyBhbGwgdGhlIHVuZGVmaW5lZCBpdGVtcyBpbiB0aGUgYXJyYXkuXG4gICAgfSlcbiAgICAuZmlsdGVyKHYgPT4gISF2KTtcbn1cbmZ1bmN0aW9uIHNjcmlwdFdpdG5lc3NUb1dpdG5lc3NTdGFjayhidWZmZXIpIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZ1bmN0aW9uIHJlYWRTbGljZShuKSB7XG4gICAgb2Zmc2V0ICs9IG47XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZShvZmZzZXQgLSBuLCBvZmZzZXQpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRWYXJJbnQoKSB7XG4gICAgY29uc3QgdmkgPSB2YXJ1aW50LmRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IHZhcnVpbnQuZGVjb2RlLmJ5dGVzO1xuICAgIHJldHVybiB2aTtcbiAgfVxuICBmdW5jdGlvbiByZWFkVmFyU2xpY2UoKSB7XG4gICAgcmV0dXJuIHJlYWRTbGljZShyZWFkVmFySW50KCkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRWZWN0b3IoKSB7XG4gICAgY29uc3QgY291bnQgPSByZWFkVmFySW50KCk7XG4gICAgY29uc3QgdmVjdG9yID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB2ZWN0b3IucHVzaChyZWFkVmFyU2xpY2UoKSk7XG4gICAgcmV0dXJuIHZlY3RvcjtcbiAgfVxuICByZXR1cm4gcmVhZFZlY3RvcigpO1xufVxuZnVuY3Rpb24gc2lnaGFzaFR5cGVUb1N0cmluZyhzaWdoYXNoVHlwZSkge1xuICBsZXQgdGV4dCA9XG4gICAgc2lnaGFzaFR5cGUgJiB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZXG4gICAgICA/ICdTSUdIQVNIX0FOWU9ORUNBTlBBWSB8ICdcbiAgICAgIDogJyc7XG4gIGNvbnN0IHNpZ01vZCA9IHNpZ2hhc2hUeXBlICYgMHgxZjtcbiAgc3dpdGNoIChzaWdNb2QpIHtcbiAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw6XG4gICAgICB0ZXh0ICs9ICdTSUdIQVNIX0FMTCc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEU6XG4gICAgICB0ZXh0ICs9ICdTSUdIQVNIX1NJTkdMRSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FOlxuICAgICAgdGV4dCArPSAnU0lHSEFTSF9OT05FJztcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0ZXh0O1xufVxuZnVuY3Rpb24gYWRkTm9uV2l0bmVzc1R4Q2FjaGUoY2FjaGUsIGlucHV0LCBpbnB1dEluZGV4KSB7XG4gIGNhY2hlLl9fTk9OX1dJVE5FU1NfVVRYT19CVUZfQ0FDSEVbaW5wdXRJbmRleF0gPSBpbnB1dC5ub25XaXRuZXNzVXR4bztcbiAgY29uc3QgdHggPSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLmZyb21CdWZmZXIoaW5wdXQubm9uV2l0bmVzc1V0eG8pO1xuICBjYWNoZS5fX05PTl9XSVRORVNTX1VUWE9fVFhfQ0FDSEVbaW5wdXRJbmRleF0gPSB0eDtcbiAgY29uc3Qgc2VsZiA9IGNhY2hlO1xuICBjb25zdCBzZWxmSW5kZXggPSBpbnB1dEluZGV4O1xuICBkZWxldGUgaW5wdXQubm9uV2l0bmVzc1V0eG87XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnB1dCwgJ25vbldpdG5lc3NVdHhvJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgYnVmID0gc2VsZi5fX05PTl9XSVRORVNTX1VUWE9fQlVGX0NBQ0hFW3NlbGZJbmRleF07XG4gICAgICBjb25zdCB0eENhY2hlID0gc2VsZi5fX05PTl9XSVRORVNTX1VUWE9fVFhfQ0FDSEVbc2VsZkluZGV4XTtcbiAgICAgIGlmIChidWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV3QnVmID0gdHhDYWNoZS50b0J1ZmZlcigpO1xuICAgICAgICBzZWxmLl9fTk9OX1dJVE5FU1NfVVRYT19CVUZfQ0FDSEVbc2VsZkluZGV4XSA9IG5ld0J1ZjtcbiAgICAgICAgcmV0dXJuIG5ld0J1ZjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldChkYXRhKSB7XG4gICAgICBzZWxmLl9fTk9OX1dJVE5FU1NfVVRYT19CVUZfQ0FDSEVbc2VsZkluZGV4XSA9IGRhdGE7XG4gICAgfSxcbiAgfSk7XG59XG5mdW5jdGlvbiBpbnB1dEZpbmFsaXplR2V0QW10cyhpbnB1dHMsIHR4LCBjYWNoZSwgbXVzdEZpbmFsaXplKSB7XG4gIGxldCBpbnB1dEFtb3VudCA9IDA7XG4gIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaWR4KSA9PiB7XG4gICAgaWYgKG11c3RGaW5hbGl6ZSAmJiBpbnB1dC5maW5hbFNjcmlwdFNpZylcbiAgICAgIHR4Lmluc1tpZHhdLnNjcmlwdCA9IGlucHV0LmZpbmFsU2NyaXB0U2lnO1xuICAgIGlmIChtdXN0RmluYWxpemUgJiYgaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzKSB7XG4gICAgICB0eC5pbnNbaWR4XS53aXRuZXNzID0gc2NyaXB0V2l0bmVzc1RvV2l0bmVzc1N0YWNrKFxuICAgICAgICBpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MsXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQud2l0bmVzc1V0eG8pIHtcbiAgICAgIGlucHV0QW1vdW50ICs9IGlucHV0LndpdG5lc3NVdHhvLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQubm9uV2l0bmVzc1V0eG8pIHtcbiAgICAgIGNvbnN0IG53VHggPSBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKGNhY2hlLCBpbnB1dCwgaWR4KTtcbiAgICAgIGNvbnN0IHZvdXQgPSB0eC5pbnNbaWR4XS5pbmRleDtcbiAgICAgIGNvbnN0IG91dCA9IG53VHgub3V0c1t2b3V0XTtcbiAgICAgIGlucHV0QW1vdW50ICs9IG91dC52YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBvdXRwdXRBbW91bnQgPSB0eC5vdXRzLnJlZHVjZSgodG90YWwsIG8pID0+IHRvdGFsICsgby52YWx1ZSwgMCk7XG4gIGNvbnN0IGZlZSA9IGlucHV0QW1vdW50IC0gb3V0cHV0QW1vdW50O1xuICBpZiAoZmVlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT3V0cHV0cyBhcmUgc3BlbmRpbmcgbW9yZSB0aGFuIElucHV0cycpO1xuICB9XG4gIGNvbnN0IGJ5dGVzID0gdHgudmlydHVhbFNpemUoKTtcbiAgY2FjaGUuX19GRUUgPSBmZWU7XG4gIGNhY2hlLl9fRVhUUkFDVEVEX1RYID0gdHg7XG4gIGNhY2hlLl9fRkVFX1JBVEUgPSBNYXRoLmZsb29yKGZlZSAvIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIG5vbldpdG5lc3NVdHhvVHhGcm9tQ2FjaGUoY2FjaGUsIGlucHV0LCBpbnB1dEluZGV4KSB7XG4gIGNvbnN0IGMgPSBjYWNoZS5fX05PTl9XSVRORVNTX1VUWE9fVFhfQ0FDSEU7XG4gIGlmICghY1tpbnB1dEluZGV4XSkge1xuICAgIGFkZE5vbldpdG5lc3NUeENhY2hlKGNhY2hlLCBpbnB1dCwgaW5wdXRJbmRleCk7XG4gIH1cbiAgcmV0dXJuIGNbaW5wdXRJbmRleF07XG59XG5mdW5jdGlvbiBnZXRTY3JpcHRGcm9tVXR4byhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpIHtcbiAgY29uc3QgeyBzY3JpcHQgfSA9IGdldFNjcmlwdEFuZEFtb3VudEZyb21VdHhvKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSk7XG4gIHJldHVybiBzY3JpcHQ7XG59XG5mdW5jdGlvbiBnZXRTY3JpcHRBbmRBbW91bnRGcm9tVXR4byhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpIHtcbiAgaWYgKGlucHV0LndpdG5lc3NVdHhvICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NyaXB0OiBpbnB1dC53aXRuZXNzVXR4by5zY3JpcHQsXG4gICAgICB2YWx1ZTogaW5wdXQud2l0bmVzc1V0eG8udmFsdWUsXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgbm9uV2l0bmVzc1V0eG9UeCA9IG5vbldpdG5lc3NVdHhvVHhGcm9tQ2FjaGUoXG4gICAgICBjYWNoZSxcbiAgICAgIGlucHV0LFxuICAgICAgaW5wdXRJbmRleCxcbiAgICApO1xuICAgIGNvbnN0IG8gPSBub25XaXRuZXNzVXR4b1R4Lm91dHNbY2FjaGUuX19UWC5pbnNbaW5wdXRJbmRleF0uaW5kZXhdO1xuICAgIHJldHVybiB7IHNjcmlwdDogby5zY3JpcHQsIHZhbHVlOiBvLnZhbHVlIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBwdWJrZXkgaW4gaW5wdXQgd2l0aG91dCBVdHhvIGRhdGFcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1YmtleUluSW5wdXQocHVia2V5LCBpbnB1dCwgaW5wdXRJbmRleCwgY2FjaGUpIHtcbiAgY29uc3Qgc2NyaXB0ID0gZ2V0U2NyaXB0RnJvbVV0eG8oaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKTtcbiAgY29uc3QgeyBtZWFuaW5nZnVsU2NyaXB0IH0gPSBnZXRNZWFuaW5nZnVsU2NyaXB0KFxuICAgIHNjcmlwdCxcbiAgICBpbnB1dEluZGV4LFxuICAgICdpbnB1dCcsXG4gICAgaW5wdXQucmVkZWVtU2NyaXB0LFxuICAgIGlucHV0LndpdG5lc3NTY3JpcHQsXG4gICk7XG4gIHJldHVybiAoMCwgcHNidHV0aWxzXzEucHVia2V5SW5TY3JpcHQpKHB1YmtleSwgbWVhbmluZ2Z1bFNjcmlwdCk7XG59XG5mdW5jdGlvbiBwdWJrZXlJbk91dHB1dChwdWJrZXksIG91dHB1dCwgb3V0cHV0SW5kZXgsIGNhY2hlKSB7XG4gIGNvbnN0IHNjcmlwdCA9IGNhY2hlLl9fVFgub3V0c1tvdXRwdXRJbmRleF0uc2NyaXB0O1xuICBjb25zdCB7IG1lYW5pbmdmdWxTY3JpcHQgfSA9IGdldE1lYW5pbmdmdWxTY3JpcHQoXG4gICAgc2NyaXB0LFxuICAgIG91dHB1dEluZGV4LFxuICAgICdvdXRwdXQnLFxuICAgIG91dHB1dC5yZWRlZW1TY3JpcHQsXG4gICAgb3V0cHV0LndpdG5lc3NTY3JpcHQsXG4gICk7XG4gIHJldHVybiAoMCwgcHNidHV0aWxzXzEucHVia2V5SW5TY3JpcHQpKHB1YmtleSwgbWVhbmluZ2Z1bFNjcmlwdCk7XG59XG5mdW5jdGlvbiByZWRlZW1Gcm9tRmluYWxTY3JpcHRTaWcoZmluYWxTY3JpcHQpIHtcbiAgaWYgKCFmaW5hbFNjcmlwdCkgcmV0dXJuO1xuICBjb25zdCBkZWNvbXAgPSBic2NyaXB0LmRlY29tcGlsZShmaW5hbFNjcmlwdCk7XG4gIGlmICghZGVjb21wKSByZXR1cm47XG4gIGNvbnN0IGxhc3RJdGVtID0gZGVjb21wW2RlY29tcC5sZW5ndGggLSAxXTtcbiAgaWYgKFxuICAgICFCdWZmZXIuaXNCdWZmZXIobGFzdEl0ZW0pIHx8XG4gICAgaXNQdWJrZXlMaWtlKGxhc3RJdGVtKSB8fFxuICAgIGlzU2lnTGlrZShsYXN0SXRlbSlcbiAgKVxuICAgIHJldHVybjtcbiAgY29uc3Qgc0RlY29tcCA9IGJzY3JpcHQuZGVjb21waWxlKGxhc3RJdGVtKTtcbiAgaWYgKCFzRGVjb21wKSByZXR1cm47XG4gIHJldHVybiBsYXN0SXRlbTtcbn1cbmZ1bmN0aW9uIHJlZGVlbUZyb21GaW5hbFdpdG5lc3NTY3JpcHQoZmluYWxTY3JpcHQpIHtcbiAgaWYgKCFmaW5hbFNjcmlwdCkgcmV0dXJuO1xuICBjb25zdCBkZWNvbXAgPSBzY3JpcHRXaXRuZXNzVG9XaXRuZXNzU3RhY2soZmluYWxTY3JpcHQpO1xuICBjb25zdCBsYXN0SXRlbSA9IGRlY29tcFtkZWNvbXAubGVuZ3RoIC0gMV07XG4gIGlmIChpc1B1YmtleUxpa2UobGFzdEl0ZW0pKSByZXR1cm47XG4gIGNvbnN0IHNEZWNvbXAgPSBic2NyaXB0LmRlY29tcGlsZShsYXN0SXRlbSk7XG4gIGlmICghc0RlY29tcCkgcmV0dXJuO1xuICByZXR1cm4gbGFzdEl0ZW07XG59XG5mdW5jdGlvbiBjb21wcmVzc1B1YmtleShwdWJrZXkpIHtcbiAgaWYgKHB1YmtleS5sZW5ndGggPT09IDY1KSB7XG4gICAgY29uc3QgcGFyaXR5ID0gcHVia2V5WzY0XSAmIDE7XG4gICAgY29uc3QgbmV3S2V5ID0gcHVia2V5LnNsaWNlKDAsIDMzKTtcbiAgICBuZXdLZXlbMF0gPSAyIHwgcGFyaXR5O1xuICAgIHJldHVybiBuZXdLZXk7XG4gIH1cbiAgcmV0dXJuIHB1YmtleS5zbGljZSgpO1xufVxuZnVuY3Rpb24gaXNQdWJrZXlMaWtlKGJ1Zikge1xuICByZXR1cm4gYnVmLmxlbmd0aCA9PT0gMzMgJiYgYnNjcmlwdC5pc0Nhbm9uaWNhbFB1YktleShidWYpO1xufVxuZnVuY3Rpb24gaXNTaWdMaWtlKGJ1Zikge1xuICByZXR1cm4gYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZShidWYpO1xufVxuZnVuY3Rpb24gZ2V0TWVhbmluZ2Z1bFNjcmlwdChcbiAgc2NyaXB0LFxuICBpbmRleCxcbiAgaW9UeXBlLFxuICByZWRlZW1TY3JpcHQsXG4gIHdpdG5lc3NTY3JpcHQsXG4pIHtcbiAgY29uc3QgaXNQMlNIID0gKDAsIHBzYnR1dGlsc18xLmlzUDJTSFNjcmlwdCkoc2NyaXB0KTtcbiAgY29uc3QgaXNQMlNIUDJXU0ggPVxuICAgIGlzUDJTSCAmJiByZWRlZW1TY3JpcHQgJiYgKDAsIHBzYnR1dGlsc18xLmlzUDJXU0hTY3JpcHQpKHJlZGVlbVNjcmlwdCk7XG4gIGNvbnN0IGlzUDJXU0ggPSAoMCwgcHNidHV0aWxzXzEuaXNQMldTSFNjcmlwdCkoc2NyaXB0KTtcbiAgaWYgKGlzUDJTSCAmJiByZWRlZW1TY3JpcHQgPT09IHVuZGVmaW5lZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjcmlwdFB1YmtleSBpcyBQMlNIIGJ1dCByZWRlZW1TY3JpcHQgbWlzc2luZycpO1xuICBpZiAoKGlzUDJXU0ggfHwgaXNQMlNIUDJXU0gpICYmIHdpdG5lc3NTY3JpcHQgPT09IHVuZGVmaW5lZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnc2NyaXB0UHVia2V5IG9yIHJlZGVlbVNjcmlwdCBpcyBQMldTSCBidXQgd2l0bmVzc1NjcmlwdCBtaXNzaW5nJyxcbiAgICApO1xuICBsZXQgbWVhbmluZ2Z1bFNjcmlwdDtcbiAgaWYgKGlzUDJTSFAyV1NIKSB7XG4gICAgbWVhbmluZ2Z1bFNjcmlwdCA9IHdpdG5lc3NTY3JpcHQ7XG4gICAgY2hlY2tSZWRlZW1TY3JpcHQoaW5kZXgsIHNjcmlwdCwgcmVkZWVtU2NyaXB0LCBpb1R5cGUpO1xuICAgIGNoZWNrV2l0bmVzc1NjcmlwdChpbmRleCwgcmVkZWVtU2NyaXB0LCB3aXRuZXNzU2NyaXB0LCBpb1R5cGUpO1xuICAgIGNoZWNrSW52YWxpZFAyV1NIKG1lYW5pbmdmdWxTY3JpcHQpO1xuICB9IGVsc2UgaWYgKGlzUDJXU0gpIHtcbiAgICBtZWFuaW5nZnVsU2NyaXB0ID0gd2l0bmVzc1NjcmlwdDtcbiAgICBjaGVja1dpdG5lc3NTY3JpcHQoaW5kZXgsIHNjcmlwdCwgd2l0bmVzc1NjcmlwdCwgaW9UeXBlKTtcbiAgICBjaGVja0ludmFsaWRQMldTSChtZWFuaW5nZnVsU2NyaXB0KTtcbiAgfSBlbHNlIGlmIChpc1AyU0gpIHtcbiAgICBtZWFuaW5nZnVsU2NyaXB0ID0gcmVkZWVtU2NyaXB0O1xuICAgIGNoZWNrUmVkZWVtU2NyaXB0KGluZGV4LCBzY3JpcHQsIHJlZGVlbVNjcmlwdCwgaW9UeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBtZWFuaW5nZnVsU2NyaXB0ID0gc2NyaXB0O1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVhbmluZ2Z1bFNjcmlwdCxcbiAgICB0eXBlOiBpc1AyU0hQMldTSFxuICAgICAgPyAncDJzaC1wMndzaCdcbiAgICAgIDogaXNQMlNIXG4gICAgICA/ICdwMnNoJ1xuICAgICAgOiBpc1AyV1NIXG4gICAgICA/ICdwMndzaCdcbiAgICAgIDogJ3JhdycsXG4gIH07XG59XG5mdW5jdGlvbiBjaGVja0ludmFsaWRQMldTSChzY3JpcHQpIHtcbiAgaWYgKFxuICAgICgwLCBwc2J0dXRpbHNfMS5pc1AyV1BLSCkoc2NyaXB0KSB8fFxuICAgICgwLCBwc2J0dXRpbHNfMS5pc1AyU0hTY3JpcHQpKHNjcmlwdClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQMldQS0ggb3IgUDJTSCBjYW4gbm90IGJlIGNvbnRhaW5lZCB3aXRoaW4gUDJXU0gnKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xhc3NpZnlTY3JpcHQoc2NyaXB0KSB7XG4gIGlmICgoMCwgcHNidHV0aWxzXzEuaXNQMldQS0gpKHNjcmlwdCkpIHJldHVybiAnd2l0bmVzc3B1YmtleWhhc2gnO1xuICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJQS0gpKHNjcmlwdCkpIHJldHVybiAncHVia2V5aGFzaCc7XG4gIGlmICgoMCwgcHNidHV0aWxzXzEuaXNQMk1TKShzY3JpcHQpKSByZXR1cm4gJ211bHRpc2lnJztcbiAgaWYgKCgwLCBwc2J0dXRpbHNfMS5pc1AyUEspKHNjcmlwdCkpIHJldHVybiAncHVia2V5JztcbiAgcmV0dXJuICdub25zdGFuZGFyZCc7XG59XG5mdW5jdGlvbiByYW5nZShuKSB7XG4gIHJldHVybiBbLi4uQXJyYXkobikua2V5cygpXTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/bip371.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/bip371.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkTaprootInputForSigs =\n  exports.tapTreeFromList =\n  exports.tapTreeToList =\n  exports.tweakInternalPubKey =\n  exports.checkTaprootOutputFields =\n  exports.checkTaprootInputFields =\n  exports.isTaprootOutput =\n  exports.isTaprootInput =\n  exports.serializeTaprootSignature =\n  exports.tapScriptFinalizer =\n  exports.toXOnly =\n    void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js\");\nconst psbtutils_1 = __webpack_require__(/*! ./psbtutils */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/psbtutils.js\");\nconst bip341_1 = __webpack_require__(/*! ../payments/bip341 */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/bip341.js\");\nconst payments_1 = __webpack_require__(/*! ../payments */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js\");\nconst psbtutils_2 = __webpack_require__(/*! ./psbtutils */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/psbtutils.js\");\nconst toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));\nexports.toXOnly = toXOnly;\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nfunction tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return {\n      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),\n    };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\nexports.tapScriptFinalizer = tapScriptFinalizer;\nfunction serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Buffer.from([sighashType])\n    : Buffer.from([]);\n  return Buffer.concat([sig, sighashTypeByte]);\n}\nexports.serializeTaprootSignature = serializeTaprootSignature;\nfunction isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))\n    )\n  );\n}\nexports.isTaprootInput = isTaprootInput;\nfunction isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && (0, psbtutils_1.isP2TR)(script))\n    )\n  );\n}\nexports.isTaprootOutput = isTaprootOutput;\nfunction checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\nexports.checkTaprootInputFields = checkTaprootInputFields;\nfunction checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nexports.checkTaprootOutputFields = checkTaprootOutputFields;\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && !scriptPubkey.equals(script))\n      throw new Error('Error adding output. Script or address missmatch.');\n  }\n}\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = (0, payments_1.p2tr)({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\nfunction tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey &&\n    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        tapInternalKey && tapInternalKey.toString('hex')\n      }`,\n    );\n  return outputKey.x;\n}\nexports.tweakInternalPubKey = tweakInternalPubKey;\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nfunction tapTreeToList(tree) {\n  if (!(0, types_1.isTaptree)(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\nexports.tapTreeToList = tapTreeToList;\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nfunction tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\nexports.tapTreeFromList = tapTreeFromList;\nfunction checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),\n  );\n}\nexports.checkTaprootInputForSigs = checkTaprootInputForSigs;\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType:\n      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,\n  };\n}\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if ((0, types_1.isTapleaf)(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if ((0, types_1.isTapleaf)(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks if the tap leaf is part of the tap tree for the given input data.\n * Throws an error if the tap leaf is not part of the tap tree.\n * @param inputData - The original PsbtInput data.\n * @param newInputData - The new PsbtInput data.\n * @param action - The action being performed.\n * @throws {Error} - If the tap leaf is not part of the tap tree.\n */\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\n/**\n * Checks if a TapLeafScript is present in a Merkle tree.\n * @param tapLeaf The TapLeafScript to check.\n * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.\n * @returns A boolean indicating whether the TapLeafScript is present in the tree.\n */\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = (0, bip341_1.rootHashFromPath)(\n    tapLeaf.controlBlock,\n    leafHash,\n  );\n  return rootHash.equals(merkleRoot);\n}\n/**\n * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.\n *\n * @param input - The PsbtInput object.\n * @param tapLeaf - The TapLeafScript object.\n * @returns An array of sorted signatures as Buffers.\n */\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (input.tapScriptSig || [])\n    .filter(tss => tss.leafHash.equals(leafHash))\n    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n    .map(t => t.signature);\n}\n/**\n * Adds the position of a public key in a script to a TapScriptSig object.\n * @param script The script in which to find the position of the public key.\n * @param tss The TapScriptSig object to add the position to.\n * @returns A TapScriptSigWitPosition object with the added position.\n */\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(\n        tss.pubkey,\n        script,\n      ),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\n/**\n * Determines whether a TapLeafScript can be finalized.\n *\n * @param leaf - The TapLeafScript to check.\n * @param tapScriptSig - The array of TapScriptSig objects.\n * @param hash - The optional hash to compare with the leaf hash.\n * @returns A boolean indicating whether the TapLeafScript can be finalized.\n */\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || hash.equals(leafHash);\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined\n  );\n}\n/**\n * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.\n * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.\n * @param io The PsbtInput or PsbtOutput to check.\n * @returns A boolean indicating whether the given input or output has non-taproot fields.\n */\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC9iaXAzNzEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLEVBQUUsdUJBQXVCO0FBQ3pCLEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUUsMkJBQTJCO0FBQzdCLEVBQUUsZ0NBQWdDO0FBQ2xDLEVBQUUsK0JBQStCO0FBQ2pDLEVBQUUsdUJBQXVCO0FBQ3pCLEVBQUUsc0JBQXNCO0FBQ3hCLEVBQUUsaUNBQWlDO0FBQ25DLEVBQUUsMEJBQTBCO0FBQzVCLEVBQUUsZUFBZTtBQUNqQjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdHQUFVO0FBQ2xDLHNCQUFzQixtQkFBTyxDQUFDLG9IQUFnQjtBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxvSEFBYTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyw0SEFBb0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsb0hBQWE7QUFDeEMsb0JBQW9CLG1CQUFPLENBQUMsb0hBQWE7QUFDekM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVEQUF1RCxXQUFXLElBQUksSUFBSTtBQUMxRTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wc2J0L2JpcDM3MS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1RhcHJvb3RJbnB1dEZvclNpZ3MgPVxuICBleHBvcnRzLnRhcFRyZWVGcm9tTGlzdCA9XG4gIGV4cG9ydHMudGFwVHJlZVRvTGlzdCA9XG4gIGV4cG9ydHMudHdlYWtJbnRlcm5hbFB1YktleSA9XG4gIGV4cG9ydHMuY2hlY2tUYXByb290T3V0cHV0RmllbGRzID1cbiAgZXhwb3J0cy5jaGVja1RhcHJvb3RJbnB1dEZpZWxkcyA9XG4gIGV4cG9ydHMuaXNUYXByb290T3V0cHV0ID1cbiAgZXhwb3J0cy5pc1RhcHJvb3RJbnB1dCA9XG4gIGV4cG9ydHMuc2VyaWFsaXplVGFwcm9vdFNpZ25hdHVyZSA9XG4gIGV4cG9ydHMudGFwU2NyaXB0RmluYWxpemVyID1cbiAgZXhwb3J0cy50b1hPbmx5ID1cbiAgICB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKCcuLi90cmFuc2FjdGlvbicpO1xuY29uc3QgcHNidHV0aWxzXzEgPSByZXF1aXJlKCcuL3BzYnR1dGlscycpO1xuY29uc3QgYmlwMzQxXzEgPSByZXF1aXJlKCcuLi9wYXltZW50cy9iaXAzNDEnKTtcbmNvbnN0IHBheW1lbnRzXzEgPSByZXF1aXJlKCcuLi9wYXltZW50cycpO1xuY29uc3QgcHNidHV0aWxzXzIgPSByZXF1aXJlKCcuL3BzYnR1dGlscycpO1xuY29uc3QgdG9YT25seSA9IHB1YktleSA9PiAocHViS2V5Lmxlbmd0aCA9PT0gMzIgPyBwdWJLZXkgOiBwdWJLZXkuc2xpY2UoMSwgMzMpKTtcbmV4cG9ydHMudG9YT25seSA9IHRvWE9ubHk7XG4vKipcbiAqIERlZmF1bHQgdGFwc2NyaXB0IGZpbmFsaXplci4gSXQgc2VhcmNoZXMgZm9yIHRoZSBgdGFwTGVhZkhhc2hUb0ZpbmFsaXplYCBpZiBwcm92aWRlZC5cbiAqIE90aGVyd2lzZSBpdCB3aWxsIHNlYXJjaCBmb3IgdGhlIHRhcGxlYWYgdGhhdCBoYXMgYXQgbGVhc3Qgb25lIHNpZ25hdHVyZSBhbmQgaGFzIHRoZSBzaG9ydGVzdCBwYXRoLlxuICogQHBhcmFtIGlucHV0SW5kZXggdGhlIHBvc2l0aW9uIG9mIHRoZSBQU0JUIGlucHV0LlxuICogQHBhcmFtIGlucHV0IHRoZSBQU0JUIGlucHV0LlxuICogQHBhcmFtIHRhcExlYWZIYXNoVG9GaW5hbGl6ZSBvcHRpb25hbCwgaWYgcHJvdmlkZWQgdGhlIGZpbmFsaXplciB3aWxsIHNlYXJjaCBmb3IgYSB0YXBsZWFmIHRoYXQgaGFzIHRoaXMgaGFzaFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgd2lsbCB0cnkgdG8gYnVpbGQgdGhlIGZpbmFsU2NyaXB0V2l0bmVzcy5cbiAqIEByZXR1cm5zIHRoZSBmaW5hbFNjcmlwdFdpdG5lc3Mgb3IgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBubyB0YXBsZWFmIGZvdW5kLlxuICovXG5mdW5jdGlvbiB0YXBTY3JpcHRGaW5hbGl6ZXIoaW5wdXRJbmRleCwgaW5wdXQsIHRhcExlYWZIYXNoVG9GaW5hbGl6ZSkge1xuICBjb25zdCB0YXBMZWFmID0gZmluZFRhcExlYWZUb0ZpbmFsaXplKFxuICAgIGlucHV0LFxuICAgIGlucHV0SW5kZXgsXG4gICAgdGFwTGVhZkhhc2hUb0ZpbmFsaXplLFxuICApO1xuICB0cnkge1xuICAgIGNvbnN0IHNpZ3MgPSBzb3J0U2lnbmF0dXJlcyhpbnB1dCwgdGFwTGVhZik7XG4gICAgY29uc3Qgd2l0bmVzcyA9IHNpZ3MuY29uY2F0KHRhcExlYWYuc2NyaXB0KS5jb25jYXQodGFwTGVhZi5jb250cm9sQmxvY2spO1xuICAgIHJldHVybiB7XG4gICAgICBmaW5hbFNjcmlwdFdpdG5lc3M6ICgwLCBwc2J0dXRpbHNfMS53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MpKHdpdG5lc3MpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBmaW5hbGl6ZSB0YXByb290IGlucHV0ICMke2lucHV0SW5kZXh9OiAke2Vycn1gKTtcbiAgfVxufVxuZXhwb3J0cy50YXBTY3JpcHRGaW5hbGl6ZXIgPSB0YXBTY3JpcHRGaW5hbGl6ZXI7XG5mdW5jdGlvbiBzZXJpYWxpemVUYXByb290U2lnbmF0dXJlKHNpZywgc2lnaGFzaFR5cGUpIHtcbiAgY29uc3Qgc2lnaGFzaFR5cGVCeXRlID0gc2lnaGFzaFR5cGVcbiAgICA/IEJ1ZmZlci5mcm9tKFtzaWdoYXNoVHlwZV0pXG4gICAgOiBCdWZmZXIuZnJvbShbXSk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtzaWcsIHNpZ2hhc2hUeXBlQnl0ZV0pO1xufVxuZXhwb3J0cy5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlID0gc2VyaWFsaXplVGFwcm9vdFNpZ25hdHVyZTtcbmZ1bmN0aW9uIGlzVGFwcm9vdElucHV0KGlucHV0KSB7XG4gIHJldHVybiAoXG4gICAgaW5wdXQgJiZcbiAgICAhIShcbiAgICAgIGlucHV0LnRhcEludGVybmFsS2V5IHx8XG4gICAgICBpbnB1dC50YXBNZXJrbGVSb290IHx8XG4gICAgICAoaW5wdXQudGFwTGVhZlNjcmlwdCAmJiBpbnB1dC50YXBMZWFmU2NyaXB0Lmxlbmd0aCkgfHxcbiAgICAgIChpbnB1dC50YXBCaXAzMkRlcml2YXRpb24gJiYgaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uLmxlbmd0aCkgfHxcbiAgICAgIChpbnB1dC53aXRuZXNzVXR4byAmJiAoMCwgcHNidHV0aWxzXzEuaXNQMlRSKShpbnB1dC53aXRuZXNzVXR4by5zY3JpcHQpKVxuICAgIClcbiAgKTtcbn1cbmV4cG9ydHMuaXNUYXByb290SW5wdXQgPSBpc1RhcHJvb3RJbnB1dDtcbmZ1bmN0aW9uIGlzVGFwcm9vdE91dHB1dChvdXRwdXQsIHNjcmlwdCkge1xuICByZXR1cm4gKFxuICAgIG91dHB1dCAmJlxuICAgICEhKFxuICAgICAgb3V0cHV0LnRhcEludGVybmFsS2V5IHx8XG4gICAgICBvdXRwdXQudGFwVHJlZSB8fFxuICAgICAgKG91dHB1dC50YXBCaXAzMkRlcml2YXRpb24gJiYgb3V0cHV0LnRhcEJpcDMyRGVyaXZhdGlvbi5sZW5ndGgpIHx8XG4gICAgICAoc2NyaXB0ICYmICgwLCBwc2J0dXRpbHNfMS5pc1AyVFIpKHNjcmlwdCkpXG4gICAgKVxuICApO1xufVxuZXhwb3J0cy5pc1RhcHJvb3RPdXRwdXQgPSBpc1RhcHJvb3RPdXRwdXQ7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RJbnB1dEZpZWxkcyhpbnB1dERhdGEsIG5ld0lucHV0RGF0YSwgYWN0aW9uKSB7XG4gIGNoZWNrTWl4ZWRUYXByb290QW5kTm9uVGFwcm9vdElucHV0RmllbGRzKGlucHV0RGF0YSwgbmV3SW5wdXREYXRhLCBhY3Rpb24pO1xuICBjaGVja0lmVGFwTGVhZkluVHJlZShpbnB1dERhdGEsIG5ld0lucHV0RGF0YSwgYWN0aW9uKTtcbn1cbmV4cG9ydHMuY2hlY2tUYXByb290SW5wdXRGaWVsZHMgPSBjaGVja1RhcHJvb3RJbnB1dEZpZWxkcztcbmZ1bmN0aW9uIGNoZWNrVGFwcm9vdE91dHB1dEZpZWxkcyhvdXRwdXREYXRhLCBuZXdPdXRwdXREYXRhLCBhY3Rpb24pIHtcbiAgY2hlY2tNaXhlZFRhcHJvb3RBbmROb25UYXByb290T3V0cHV0RmllbGRzKG91dHB1dERhdGEsIG5ld091dHB1dERhdGEsIGFjdGlvbik7XG4gIGNoZWNrVGFwcm9vdFNjcmlwdFB1YmtleShvdXRwdXREYXRhLCBuZXdPdXRwdXREYXRhKTtcbn1cbmV4cG9ydHMuY2hlY2tUYXByb290T3V0cHV0RmllbGRzID0gY2hlY2tUYXByb290T3V0cHV0RmllbGRzO1xuZnVuY3Rpb24gY2hlY2tUYXByb290U2NyaXB0UHVia2V5KG91dHB1dERhdGEsIG5ld091dHB1dERhdGEpIHtcbiAgaWYgKCFuZXdPdXRwdXREYXRhLnRhcFRyZWUgJiYgIW5ld091dHB1dERhdGEudGFwSW50ZXJuYWxLZXkpIHJldHVybjtcbiAgY29uc3QgdGFwSW50ZXJuYWxLZXkgPVxuICAgIG5ld091dHB1dERhdGEudGFwSW50ZXJuYWxLZXkgfHwgb3V0cHV0RGF0YS50YXBJbnRlcm5hbEtleTtcbiAgY29uc3QgdGFwVHJlZSA9IG5ld091dHB1dERhdGEudGFwVHJlZSB8fCBvdXRwdXREYXRhLnRhcFRyZWU7XG4gIGlmICh0YXBJbnRlcm5hbEtleSkge1xuICAgIGNvbnN0IHsgc2NyaXB0OiBzY3JpcHRQdWJrZXkgfSA9IG91dHB1dERhdGE7XG4gICAgY29uc3Qgc2NyaXB0ID0gZ2V0VGFwcm9vdFNjcmlwUHVia2V5KHRhcEludGVybmFsS2V5LCB0YXBUcmVlKTtcbiAgICBpZiAoc2NyaXB0UHVia2V5ICYmICFzY3JpcHRQdWJrZXkuZXF1YWxzKHNjcmlwdCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFkZGluZyBvdXRwdXQuIFNjcmlwdCBvciBhZGRyZXNzIG1pc3NtYXRjaC4nKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VGFwcm9vdFNjcmlwUHVia2V5KHRhcEludGVybmFsS2V5LCB0YXBUcmVlKSB7XG4gIGNvbnN0IHNjcmlwdFRyZWUgPSB0YXBUcmVlICYmIHRhcFRyZWVGcm9tTGlzdCh0YXBUcmVlLmxlYXZlcyk7XG4gIGNvbnN0IHsgb3V0cHV0IH0gPSAoMCwgcGF5bWVudHNfMS5wMnRyKSh7XG4gICAgaW50ZXJuYWxQdWJrZXk6IHRhcEludGVybmFsS2V5LFxuICAgIHNjcmlwdFRyZWUsXG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gdHdlYWtJbnRlcm5hbFB1YktleShpbnB1dEluZGV4LCBpbnB1dCkge1xuICBjb25zdCB0YXBJbnRlcm5hbEtleSA9IGlucHV0LnRhcEludGVybmFsS2V5O1xuICBjb25zdCBvdXRwdXRLZXkgPVxuICAgIHRhcEludGVybmFsS2V5ICYmXG4gICAgKDAsIGJpcDM0MV8xLnR3ZWFrS2V5KSh0YXBJbnRlcm5hbEtleSwgaW5wdXQudGFwTWVya2xlUm9vdCk7XG4gIGlmICghb3V0cHV0S2V5KVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW5ub3QgdHdlYWsgdGFwIGludGVybmFsIGtleSBmb3IgaW5wdXQgIyR7aW5wdXRJbmRleH0uIFB1YmxpYyBrZXk6ICR7XG4gICAgICAgIHRhcEludGVybmFsS2V5ICYmIHRhcEludGVybmFsS2V5LnRvU3RyaW5nKCdoZXgnKVxuICAgICAgfWAsXG4gICAgKTtcbiAgcmV0dXJuIG91dHB1dEtleS54O1xufVxuZXhwb3J0cy50d2Vha0ludGVybmFsUHViS2V5ID0gdHdlYWtJbnRlcm5hbFB1YktleTtcbi8qKlxuICogQ29udmVydCBhIGJpbmFyeSB0cmVlIHRvIGEgQklQMzcxIHR5cGUgbGlzdC4gRWFjaCBlbGVtZW50IG9mIHRoZSBsaXN0IGlzIChhY2NvcmRpbmcgdG8gQklQMzcxKTpcbiAqIE9uZSBvciBtb3JlIHR1cGxlcyByZXByZXNlbnRpbmcgdGhlIGRlcHRoLCBsZWFmIHZlcnNpb24sIGFuZCBzY3JpcHQgZm9yIGEgbGVhZiBpbiB0aGUgVGFwcm9vdCB0cmVlLFxuICogYWxsb3dpbmcgdGhlIGVudGlyZSB0cmVlIHRvIGJlIHJlY29uc3RydWN0ZWQuIFRoZSB0dXBsZXMgbXVzdCBiZSBpbiBkZXB0aCBmaXJzdCBzZWFyY2ggb3JkZXIgc28gdGhhdFxuICogdGhlIHRyZWUgaXMgY29ycmVjdGx5IHJlY29uc3RydWN0ZWQuXG4gKiBAcGFyYW0gdHJlZSB0aGUgYmluYXJ5IHRhcCB0cmVlXG4gKiBAcmV0dXJucyBhIGxpc3Qgb2YgQklQIDM3MSB0YXBsZWF2ZXNcbiAqL1xuZnVuY3Rpb24gdGFwVHJlZVRvTGlzdCh0cmVlKSB7XG4gIGlmICghKDAsIHR5cGVzXzEuaXNUYXB0cmVlKSh0cmVlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IGNvbnZlcnQgdGFwdHJlZSB0byB0YXBsZWFmIGxpc3QuIEV4cGVjdGluZyBhIHRhcHJlZSBzdHJ1Y3R1cmUuJyxcbiAgICApO1xuICByZXR1cm4gX3RhcFRyZWVUb0xpc3QodHJlZSk7XG59XG5leHBvcnRzLnRhcFRyZWVUb0xpc3QgPSB0YXBUcmVlVG9MaXN0O1xuLyoqXG4gKiBDb252ZXJ0IGEgQklQMzcxIFRhcExlYWYgbGlzdCB0byBhIFRhcFRyZWUgKGJpbmFyeSkuXG4gKiBAcGFyYW0gbGVhdmVzIGEgbGlzdCBvZiB0YXBsZWF2ZXMgd2hlcmUgZWFjaCBlbGVtZW50IG9mIHRoZSBsaXN0IGlzIChhY2NvcmRpbmcgdG8gQklQMzcxKTpcbiAqIE9uZSBvciBtb3JlIHR1cGxlcyByZXByZXNlbnRpbmcgdGhlIGRlcHRoLCBsZWFmIHZlcnNpb24sIGFuZCBzY3JpcHQgZm9yIGEgbGVhZiBpbiB0aGUgVGFwcm9vdCB0cmVlLFxuICogYWxsb3dpbmcgdGhlIGVudGlyZSB0cmVlIHRvIGJlIHJlY29uc3RydWN0ZWQuIFRoZSB0dXBsZXMgbXVzdCBiZSBpbiBkZXB0aCBmaXJzdCBzZWFyY2ggb3JkZXIgc28gdGhhdFxuICogdGhlIHRyZWUgaXMgY29ycmVjdGx5IHJlY29uc3RydWN0ZWQuXG4gKiBAcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyB0YXB0cmVlLCBvciB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSB0cmVlIGNhbm5vdCBiZSByZWNvbnN0cnVjdGVkXG4gKi9cbmZ1bmN0aW9uIHRhcFRyZWVGcm9tTGlzdChsZWF2ZXMgPSBbXSkge1xuICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMSAmJiBsZWF2ZXNbMF0uZGVwdGggPT09IDApXG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogbGVhdmVzWzBdLnNjcmlwdCxcbiAgICAgIHZlcnNpb246IGxlYXZlc1swXS5sZWFmVmVyc2lvbixcbiAgICB9O1xuICByZXR1cm4gaW5zdGVydExlYXZlc0luVHJlZShsZWF2ZXMpO1xufVxuZXhwb3J0cy50YXBUcmVlRnJvbUxpc3QgPSB0YXBUcmVlRnJvbUxpc3Q7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RJbnB1dEZvclNpZ3MoaW5wdXQsIGFjdGlvbikge1xuICBjb25zdCBzaWdzID0gZXh0cmFjdFRhcHJvb3RTaWdzKGlucHV0KTtcbiAgcmV0dXJuIHNpZ3Muc29tZShzaWcgPT5cbiAgICAoMCwgcHNidHV0aWxzXzIuc2lnbmF0dXJlQmxvY2tzQWN0aW9uKShzaWcsIGRlY29kZVNjaG5vcnJTaWduYXR1cmUsIGFjdGlvbiksXG4gICk7XG59XG5leHBvcnRzLmNoZWNrVGFwcm9vdElucHV0Rm9yU2lncyA9IGNoZWNrVGFwcm9vdElucHV0Rm9yU2lncztcbmZ1bmN0aW9uIGRlY29kZVNjaG5vcnJTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlOiBzaWduYXR1cmUuc2xpY2UoMCwgNjQpLFxuICAgIGhhc2hUeXBlOlxuICAgICAgc2lnbmF0dXJlLnNsaWNlKDY0KVswXSB8fCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCxcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RUYXByb290U2lncyhpbnB1dCkge1xuICBjb25zdCBzaWdzID0gW107XG4gIGlmIChpbnB1dC50YXBLZXlTaWcpIHNpZ3MucHVzaChpbnB1dC50YXBLZXlTaWcpO1xuICBpZiAoaW5wdXQudGFwU2NyaXB0U2lnKVxuICAgIHNpZ3MucHVzaCguLi5pbnB1dC50YXBTY3JpcHRTaWcubWFwKHMgPT4gcy5zaWduYXR1cmUpKTtcbiAgaWYgKCFzaWdzLmxlbmd0aCkge1xuICAgIGNvbnN0IGZpbmFsVGFwS2V5U2lnID0gZ2V0VGFwS2V5U2lnRnJvbVdpdGhuZXNzKGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcyk7XG4gICAgaWYgKGZpbmFsVGFwS2V5U2lnKSBzaWdzLnB1c2goZmluYWxUYXBLZXlTaWcpO1xuICB9XG4gIHJldHVybiBzaWdzO1xufVxuZnVuY3Rpb24gZ2V0VGFwS2V5U2lnRnJvbVdpdGhuZXNzKGZpbmFsU2NyaXB0V2l0bmVzcykge1xuICBpZiAoIWZpbmFsU2NyaXB0V2l0bmVzcykgcmV0dXJuO1xuICBjb25zdCB3aXRuZXNzID0gZmluYWxTY3JpcHRXaXRuZXNzLnNsaWNlKDIpO1xuICAvLyB0b2RvOiBhZGQgc2Nobm9yciBzaWduYXR1cmUgdmFsaWRhdGlvblxuICBpZiAod2l0bmVzcy5sZW5ndGggPT09IDY0IHx8IHdpdG5lc3MubGVuZ3RoID09PSA2NSkgcmV0dXJuIHdpdG5lc3M7XG59XG5mdW5jdGlvbiBfdGFwVHJlZVRvTGlzdCh0cmVlLCBsZWF2ZXMgPSBbXSwgZGVwdGggPSAwKSB7XG4gIGlmIChkZXB0aCA+IGJpcDM0MV8xLk1BWF9UQVBUUkVFX0RFUFRIKVxuICAgIHRocm93IG5ldyBFcnJvcignTWF4IHRhcHRyZWUgZGVwdGggZXhjZWVkZWQuJyk7XG4gIGlmICghdHJlZSkgcmV0dXJuIFtdO1xuICBpZiAoKDAsIHR5cGVzXzEuaXNUYXBsZWFmKSh0cmVlKSkge1xuICAgIGxlYXZlcy5wdXNoKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbGVhZlZlcnNpb246IHRyZWUudmVyc2lvbiB8fCBiaXAzNDFfMS5MRUFGX1ZFUlNJT05fVEFQU0NSSVBULFxuICAgICAgc2NyaXB0OiB0cmVlLm91dHB1dCxcbiAgICB9KTtcbiAgICByZXR1cm4gbGVhdmVzO1xuICB9XG4gIGlmICh0cmVlWzBdKSBfdGFwVHJlZVRvTGlzdCh0cmVlWzBdLCBsZWF2ZXMsIGRlcHRoICsgMSk7XG4gIGlmICh0cmVlWzFdKSBfdGFwVHJlZVRvTGlzdCh0cmVlWzFdLCBsZWF2ZXMsIGRlcHRoICsgMSk7XG4gIHJldHVybiBsZWF2ZXM7XG59XG5mdW5jdGlvbiBpbnN0ZXJ0TGVhdmVzSW5UcmVlKGxlYXZlcykge1xuICBsZXQgdHJlZTtcbiAgZm9yIChjb25zdCBsZWFmIG9mIGxlYXZlcykge1xuICAgIHRyZWUgPSBpbnN0ZXJ0TGVhZkluVHJlZShsZWFmLCB0cmVlKTtcbiAgICBpZiAoIXRyZWUpIHRocm93IG5ldyBFcnJvcihgTm8gcm9vbSBsZWZ0IHRvIGluc2VydCB0YXBsZWFmIGluIHRyZWVgKTtcbiAgfVxuICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIGluc3RlcnRMZWFmSW5UcmVlKGxlYWYsIHRyZWUsIGRlcHRoID0gMCkge1xuICBpZiAoZGVwdGggPiBiaXAzNDFfMS5NQVhfVEFQVFJFRV9ERVBUSClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heCB0YXB0cmVlIGRlcHRoIGV4Y2VlZGVkLicpO1xuICBpZiAobGVhZi5kZXB0aCA9PT0gZGVwdGgpIHtcbiAgICBpZiAoIXRyZWUpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdXRwdXQ6IGxlYWYuc2NyaXB0LFxuICAgICAgICB2ZXJzaW9uOiBsZWFmLmxlYWZWZXJzaW9uLFxuICAgICAgfTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCgwLCB0eXBlc18xLmlzVGFwbGVhZikodHJlZSkpIHJldHVybjtcbiAgY29uc3QgbGVmdFNpZGUgPSBpbnN0ZXJ0TGVhZkluVHJlZShsZWFmLCB0cmVlICYmIHRyZWVbMF0sIGRlcHRoICsgMSk7XG4gIGlmIChsZWZ0U2lkZSkgcmV0dXJuIFtsZWZ0U2lkZSwgdHJlZSAmJiB0cmVlWzFdXTtcbiAgY29uc3QgcmlnaHRTaWRlID0gaW5zdGVydExlYWZJblRyZWUobGVhZiwgdHJlZSAmJiB0cmVlWzFdLCBkZXB0aCArIDEpO1xuICBpZiAocmlnaHRTaWRlKSByZXR1cm4gW3RyZWUgJiYgdHJlZVswXSwgcmlnaHRTaWRlXTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWl4ZWRUYXByb290QW5kTm9uVGFwcm9vdElucHV0RmllbGRzKFxuICBpbnB1dERhdGEsXG4gIG5ld0lucHV0RGF0YSxcbiAgYWN0aW9uLFxuKSB7XG4gIGNvbnN0IGlzQmFkVGFwcm9vdFVwZGF0ZSA9XG4gICAgaXNUYXByb290SW5wdXQoaW5wdXREYXRhKSAmJiBoYXNOb25UYXByb290RmllbGRzKG5ld0lucHV0RGF0YSk7XG4gIGNvbnN0IGlzQmFkTm9uVGFwcm9vdFVwZGF0ZSA9XG4gICAgaGFzTm9uVGFwcm9vdEZpZWxkcyhpbnB1dERhdGEpICYmIGlzVGFwcm9vdElucHV0KG5ld0lucHV0RGF0YSk7XG4gIGNvbnN0IGhhc01peGVkRmllbGRzID1cbiAgICBpbnB1dERhdGEgPT09IG5ld0lucHV0RGF0YSAmJlxuICAgIGlzVGFwcm9vdElucHV0KG5ld0lucHV0RGF0YSkgJiZcbiAgICBoYXNOb25UYXByb290RmllbGRzKG5ld0lucHV0RGF0YSk7IC8vIHRvZG86IGJhZD8gdXNlICE9PT1cbiAgaWYgKGlzQmFkVGFwcm9vdFVwZGF0ZSB8fCBpc0JhZE5vblRhcHJvb3RVcGRhdGUgfHwgaGFzTWl4ZWRGaWVsZHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LiR7YWN0aW9ufS4gYCArXG4gICAgICAgIGBDYW5ub3QgdXNlIGJvdGggdGFwcm9vdCBhbmQgbm9uLXRhcHJvb3QgZmllbGRzLmAsXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWl4ZWRUYXByb290QW5kTm9uVGFwcm9vdE91dHB1dEZpZWxkcyhcbiAgaW5wdXREYXRhLFxuICBuZXdJbnB1dERhdGEsXG4gIGFjdGlvbixcbikge1xuICBjb25zdCBpc0JhZFRhcHJvb3RVcGRhdGUgPVxuICAgIGlzVGFwcm9vdE91dHB1dChpbnB1dERhdGEpICYmIGhhc05vblRhcHJvb3RGaWVsZHMobmV3SW5wdXREYXRhKTtcbiAgY29uc3QgaXNCYWROb25UYXByb290VXBkYXRlID1cbiAgICBoYXNOb25UYXByb290RmllbGRzKGlucHV0RGF0YSkgJiYgaXNUYXByb290T3V0cHV0KG5ld0lucHV0RGF0YSk7XG4gIGNvbnN0IGhhc01peGVkRmllbGRzID1cbiAgICBpbnB1dERhdGEgPT09IG5ld0lucHV0RGF0YSAmJlxuICAgIGlzVGFwcm9vdE91dHB1dChuZXdJbnB1dERhdGEpICYmXG4gICAgaGFzTm9uVGFwcm9vdEZpZWxkcyhuZXdJbnB1dERhdGEpO1xuICBpZiAoaXNCYWRUYXByb290VXBkYXRlIHx8IGlzQmFkTm9uVGFwcm9vdFVwZGF0ZSB8fCBoYXNNaXhlZEZpZWxkcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBhcmd1bWVudHMgZm9yIFBzYnQuJHthY3Rpb259LiBgICtcbiAgICAgICAgYENhbm5vdCB1c2UgYm90aCB0YXByb290IGFuZCBub24tdGFwcm9vdCBmaWVsZHMuYCxcbiAgICApO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHRhcCBsZWFmIGlzIHBhcnQgb2YgdGhlIHRhcCB0cmVlIGZvciB0aGUgZ2l2ZW4gaW5wdXQgZGF0YS5cbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdGFwIGxlYWYgaXMgbm90IHBhcnQgb2YgdGhlIHRhcCB0cmVlLlxuICogQHBhcmFtIGlucHV0RGF0YSAtIFRoZSBvcmlnaW5hbCBQc2J0SW5wdXQgZGF0YS5cbiAqIEBwYXJhbSBuZXdJbnB1dERhdGEgLSBUaGUgbmV3IFBzYnRJbnB1dCBkYXRhLlxuICogQHBhcmFtIGFjdGlvbiAtIFRoZSBhY3Rpb24gYmVpbmcgcGVyZm9ybWVkLlxuICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIHRhcCBsZWFmIGlzIG5vdCBwYXJ0IG9mIHRoZSB0YXAgdHJlZS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tJZlRhcExlYWZJblRyZWUoaW5wdXREYXRhLCBuZXdJbnB1dERhdGEsIGFjdGlvbikge1xuICBpZiAobmV3SW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpIHtcbiAgICBjb25zdCBuZXdMZWFmc0luVHJlZSA9IChuZXdJbnB1dERhdGEudGFwTGVhZlNjcmlwdCB8fCBbXSkuZXZlcnkobCA9PlxuICAgICAgaXNUYXBMZWFmSW5UcmVlKGwsIG5ld0lucHV0RGF0YS50YXBNZXJrbGVSb290KSxcbiAgICApO1xuICAgIGNvbnN0IG9sZExlYWZzSW5UcmVlID0gKGlucHV0RGF0YS50YXBMZWFmU2NyaXB0IHx8IFtdKS5ldmVyeShsID0+XG4gICAgICBpc1RhcExlYWZJblRyZWUobCwgbmV3SW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpLFxuICAgICk7XG4gICAgaWYgKCFuZXdMZWFmc0luVHJlZSB8fCAhb2xkTGVhZnNJblRyZWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC4ke2FjdGlvbn0uIFRhcGxlYWYgbm90IHBhcnQgb2YgdGFwdHJlZS5gLFxuICAgICAgKTtcbiAgfSBlbHNlIGlmIChpbnB1dERhdGEudGFwTWVya2xlUm9vdCkge1xuICAgIGNvbnN0IG5ld0xlYWZzSW5UcmVlID0gKG5ld0lucHV0RGF0YS50YXBMZWFmU2NyaXB0IHx8IFtdKS5ldmVyeShsID0+XG4gICAgICBpc1RhcExlYWZJblRyZWUobCwgaW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpLFxuICAgICk7XG4gICAgaWYgKCFuZXdMZWFmc0luVHJlZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LiR7YWN0aW9ufS4gVGFwbGVhZiBub3QgcGFydCBvZiB0YXB0cmVlLmAsXG4gICAgICApO1xuICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIFRhcExlYWZTY3JpcHQgaXMgcHJlc2VudCBpbiBhIE1lcmtsZSB0cmVlLlxuICogQHBhcmFtIHRhcExlYWYgVGhlIFRhcExlYWZTY3JpcHQgdG8gY2hlY2suXG4gKiBAcGFyYW0gbWVya2xlUm9vdCBUaGUgTWVya2xlIHJvb3Qgb2YgdGhlIHRyZWUuIElmIG5vdCBwcm92aWRlZCwgdGhlIGZ1bmN0aW9uIGFzc3VtZXMgdGhlIFRhcExlYWZTY3JpcHQgaXMgcHJlc2VudC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFRhcExlYWZTY3JpcHQgaXMgcHJlc2VudCBpbiB0aGUgdHJlZS5cbiAqL1xuZnVuY3Rpb24gaXNUYXBMZWFmSW5UcmVlKHRhcExlYWYsIG1lcmtsZVJvb3QpIHtcbiAgaWYgKCFtZXJrbGVSb290KSByZXR1cm4gdHJ1ZTtcbiAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICBvdXRwdXQ6IHRhcExlYWYuc2NyaXB0LFxuICAgIHZlcnNpb246IHRhcExlYWYubGVhZlZlcnNpb24sXG4gIH0pO1xuICBjb25zdCByb290SGFzaCA9ICgwLCBiaXAzNDFfMS5yb290SGFzaEZyb21QYXRoKShcbiAgICB0YXBMZWFmLmNvbnRyb2xCbG9jayxcbiAgICBsZWFmSGFzaCxcbiAgKTtcbiAgcmV0dXJuIHJvb3RIYXNoLmVxdWFscyhtZXJrbGVSb290KTtcbn1cbi8qKlxuICogU29ydHMgdGhlIHNpZ25hdHVyZXMgaW4gdGhlIGlucHV0J3MgdGFwU2NyaXB0U2lnIGFycmF5IGJhc2VkIG9uIHRoZWlyIHBvc2l0aW9uIGluIHRoZSB0YXBMZWFmIHNjcmlwdC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgUHNidElucHV0IG9iamVjdC5cbiAqIEBwYXJhbSB0YXBMZWFmIC0gVGhlIFRhcExlYWZTY3JpcHQgb2JqZWN0LlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc29ydGVkIHNpZ25hdHVyZXMgYXMgQnVmZmVycy5cbiAqL1xuZnVuY3Rpb24gc29ydFNpZ25hdHVyZXMoaW5wdXQsIHRhcExlYWYpIHtcbiAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICBvdXRwdXQ6IHRhcExlYWYuc2NyaXB0LFxuICAgIHZlcnNpb246IHRhcExlYWYubGVhZlZlcnNpb24sXG4gIH0pO1xuICByZXR1cm4gKGlucHV0LnRhcFNjcmlwdFNpZyB8fCBbXSlcbiAgICAuZmlsdGVyKHRzcyA9PiB0c3MubGVhZkhhc2guZXF1YWxzKGxlYWZIYXNoKSlcbiAgICAubWFwKHRzcyA9PiBhZGRQdWJrZXlQb3NpdGlvbkluU2NyaXB0KHRhcExlYWYuc2NyaXB0LCB0c3MpKVxuICAgIC5zb3J0KCh0MSwgdDIpID0+IHQyLnBvc2l0aW9uSW5TY3JpcHQgLSB0MS5wb3NpdGlvbkluU2NyaXB0KVxuICAgIC5tYXAodCA9PiB0LnNpZ25hdHVyZSk7XG59XG4vKipcbiAqIEFkZHMgdGhlIHBvc2l0aW9uIG9mIGEgcHVibGljIGtleSBpbiBhIHNjcmlwdCB0byBhIFRhcFNjcmlwdFNpZyBvYmplY3QuXG4gKiBAcGFyYW0gc2NyaXB0IFRoZSBzY3JpcHQgaW4gd2hpY2ggdG8gZmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0gdHNzIFRoZSBUYXBTY3JpcHRTaWcgb2JqZWN0IHRvIGFkZCB0aGUgcG9zaXRpb24gdG8uXG4gKiBAcmV0dXJucyBBIFRhcFNjcmlwdFNpZ1dpdFBvc2l0aW9uIG9iamVjdCB3aXRoIHRoZSBhZGRlZCBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gYWRkUHVia2V5UG9zaXRpb25JblNjcmlwdChzY3JpcHQsIHRzcykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICB7XG4gICAgICBwb3NpdGlvbkluU2NyaXB0OiAoMCwgcHNidHV0aWxzXzEucHVia2V5UG9zaXRpb25JblNjcmlwdCkoXG4gICAgICAgIHRzcy5wdWJrZXksXG4gICAgICAgIHNjcmlwdCxcbiAgICAgICksXG4gICAgfSxcbiAgICB0c3MsXG4gICk7XG59XG4vKipcbiAqIEZpbmQgdGFwbGVhZiBieSBoYXNoLCBvciBnZXQgdGhlIHNpZ25lZCB0YXBsZWFmIHdpdGggdGhlIHNob3J0ZXN0IHBhdGguXG4gKi9cbmZ1bmN0aW9uIGZpbmRUYXBMZWFmVG9GaW5hbGl6ZShpbnB1dCwgaW5wdXRJbmRleCwgbGVhZkhhc2hUb0ZpbmFsaXplKSB7XG4gIGlmICghaW5wdXQudGFwU2NyaXB0U2lnIHx8ICFpbnB1dC50YXBTY3JpcHRTaWcubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW4gbm90IGZpbmFsaXplIHRhcHJvb3QgaW5wdXQgIyR7aW5wdXRJbmRleH0uIE5vIHRhcGxlYWYgc2NyaXB0IHNpZ25hdHVyZSBwcm92aWRlZC5gLFxuICAgICk7XG4gIGNvbnN0IHRhcExlYWYgPSAoaW5wdXQudGFwTGVhZlNjcmlwdCB8fCBbXSlcbiAgICAuc29ydCgoYSwgYikgPT4gYS5jb250cm9sQmxvY2subGVuZ3RoIC0gYi5jb250cm9sQmxvY2subGVuZ3RoKVxuICAgIC5maW5kKGxlYWYgPT5cbiAgICAgIGNhbkZpbmFsaXplTGVhZihsZWFmLCBpbnB1dC50YXBTY3JpcHRTaWcsIGxlYWZIYXNoVG9GaW5hbGl6ZSksXG4gICAgKTtcbiAgaWYgKCF0YXBMZWFmKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW4gbm90IGZpbmFsaXplIHRhcHJvb3QgaW5wdXQgIyR7aW5wdXRJbmRleH0uIFNpZ25hdHVyZSBmb3IgdGFwbGVhZiBzY3JpcHQgbm90IGZvdW5kLmAsXG4gICAgKTtcbiAgcmV0dXJuIHRhcExlYWY7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIFRhcExlYWZTY3JpcHQgY2FuIGJlIGZpbmFsaXplZC5cbiAqXG4gKiBAcGFyYW0gbGVhZiAtIFRoZSBUYXBMZWFmU2NyaXB0IHRvIGNoZWNrLlxuICogQHBhcmFtIHRhcFNjcmlwdFNpZyAtIFRoZSBhcnJheSBvZiBUYXBTY3JpcHRTaWcgb2JqZWN0cy5cbiAqIEBwYXJhbSBoYXNoIC0gVGhlIG9wdGlvbmFsIGhhc2ggdG8gY29tcGFyZSB3aXRoIHRoZSBsZWFmIGhhc2guXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBUYXBMZWFmU2NyaXB0IGNhbiBiZSBmaW5hbGl6ZWQuXG4gKi9cbmZ1bmN0aW9uIGNhbkZpbmFsaXplTGVhZihsZWFmLCB0YXBTY3JpcHRTaWcsIGhhc2gpIHtcbiAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICBvdXRwdXQ6IGxlYWYuc2NyaXB0LFxuICAgIHZlcnNpb246IGxlYWYubGVhZlZlcnNpb24sXG4gIH0pO1xuICBjb25zdCB3aGl0ZUxpc3RlZEhhc2ggPSAhaGFzaCB8fCBoYXNoLmVxdWFscyhsZWFmSGFzaCk7XG4gIHJldHVybiAoXG4gICAgd2hpdGVMaXN0ZWRIYXNoICYmXG4gICAgdGFwU2NyaXB0U2lnLmZpbmQodHNzID0+IHRzcy5sZWFmSGFzaC5lcXVhbHMobGVhZkhhc2gpKSAhPT0gdW5kZWZpbmVkXG4gICk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gUHNidElucHV0IG9yIFBzYnRPdXRwdXQgaGFzIG5vbi10YXByb290IGZpZWxkcy5cbiAqIE5vbi10YXByb290IGZpZWxkcyBpbmNsdWRlIHJlZGVlbVNjcmlwdCwgd2l0bmVzc1NjcmlwdCwgYW5kIGJpcDMyRGVyaXZhdGlvbi5cbiAqIEBwYXJhbSBpbyBUaGUgUHNidElucHV0IG9yIFBzYnRPdXRwdXQgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBnaXZlbiBpbnB1dCBvciBvdXRwdXQgaGFzIG5vbi10YXByb290IGZpZWxkcy5cbiAqL1xuZnVuY3Rpb24gaGFzTm9uVGFwcm9vdEZpZWxkcyhpbykge1xuICByZXR1cm4gKFxuICAgIGlvICYmXG4gICAgISEoXG4gICAgICBpby5yZWRlZW1TY3JpcHQgfHxcbiAgICAgIGlvLndpdG5lc3NTY3JpcHQgfHxcbiAgICAgIChpby5iaXAzMkRlcml2YXRpb24gJiYgaW8uYmlwMzJEZXJpdmF0aW9uLmxlbmd0aClcbiAgICApXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/bip371.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/psbtutils.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/psbtutils.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.signatureBlocksAction =\n  exports.checkInputForSig =\n  exports.pubkeyInScript =\n  exports.pubkeyPositionInScript =\n  exports.witnessStackToScriptWitness =\n  exports.isP2TR =\n  exports.isP2SHScript =\n  exports.isP2WSHScript =\n  exports.isP2WPKH =\n  exports.isP2PKH =\n  exports.isP2PK =\n  exports.isP2MS =\n    void 0;\nconst varuint = __webpack_require__(/*! bip174/src/lib/converter/varint */ \"(ssr)/./node_modules/.pnpm/bip174@2.1.1/node_modules/bip174/src/lib/converter/varint.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nconst payments = __webpack_require__(/*! ../payments */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/payments/index.js\");\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nexports.isP2MS = isPaymentFactory(payments.p2ms);\nexports.isP2PK = isPaymentFactory(payments.p2pk);\nexports.isP2PKH = isPaymentFactory(payments.p2pkh);\nexports.isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexports.isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexports.isP2SHScript = isPaymentFactory(payments.p2sh);\nexports.isP2TR = isPaymentFactory(payments.p2tr);\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The script witness as a Buffer.\n */\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The converted script witness.\n */\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nexports.witnessStackToScriptWitness = witnessStackToScriptWitness;\n/**\n * Finds the position of a public key in a script.\n * @param pubkey The public key to search for.\n * @param script The script to search in.\n * @returns The index of the public key in the script, or -1 if not found.\n * @throws {Error} If there is an unknown script error.\n */\nfunction pubkeyPositionInScript(pubkey, script) {\n  const pubkeyHash = (0, crypto_1.hash160)(pubkey);\n  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.findIndex(element => {\n    if (typeof element === 'number') return false;\n    return (\n      element.equals(pubkey) ||\n      element.equals(pubkeyHash) ||\n      element.equals(pubkeyXOnly)\n    );\n  });\n}\nexports.pubkeyPositionInScript = pubkeyPositionInScript;\n/**\n * Checks if a public key is present in a script.\n * @param pubkey The public key to check.\n * @param script The script to search in.\n * @returns A boolean indicating whether the public key is present in the script.\n */\nfunction pubkeyInScript(pubkey, script) {\n  return pubkeyPositionInScript(pubkey, script) !== -1;\n}\nexports.pubkeyInScript = pubkeyInScript;\n/**\n * Checks if an input contains a signature for a specific action.\n * @param input - The input to check.\n * @param action - The action to check for.\n * @returns A boolean indicating whether the input contains a signature for the specified action.\n */\nfunction checkInputForSig(input, action) {\n  const pSigs = extractPartialSigs(input);\n  return pSigs.some(pSig =>\n    signatureBlocksAction(pSig, bscript.signature.decode, action),\n  );\n}\nexports.checkInputForSig = checkInputForSig;\n/**\n * Determines if a given action is allowed for a signature block.\n * @param signature - The signature block.\n * @param signatureDecodeFn - The function used to decode the signature.\n * @param action - The action to be checked.\n * @returns True if the action is allowed, false otherwise.\n */\nfunction signatureBlocksAction(signature, signatureDecodeFn, action) {\n  const { hashType } = signatureDecodeFn(signature);\n  const whitelist = [];\n  const isAnyoneCanPay =\n    hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n  if (isAnyoneCanPay) whitelist.push('addInput');\n  const hashMod = hashType & 0x1f;\n  switch (hashMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n    case transaction_1.Transaction.SIGHASH_NONE:\n      whitelist.push('addOutput');\n      whitelist.push('setInputSequence');\n      break;\n  }\n  if (whitelist.indexOf(action) === -1) {\n    return true;\n  }\n  return false;\n}\nexports.signatureBlocksAction = signatureBlocksAction;\n/**\n * Extracts the signatures from a PsbtInput object.\n * If the input has partial signatures, it returns an array of the signatures.\n * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.\n * If it does, it extracts the signatures from the final scripts and returns them.\n * If none of the above conditions are met, it returns an empty array.\n *\n * @param input - The PsbtInput object from which to extract the signatures.\n * @returns An array of signatures extracted from the PsbtInput object.\n */\nfunction extractPartialSigs(input) {\n  let pSigs = [];\n  if ((input.partialSig || []).length === 0) {\n    if (!input.finalScriptSig && !input.finalScriptWitness) return [];\n    pSigs = getPsigsFromInputFinalScripts(input);\n  } else {\n    pSigs = input.partialSig;\n  }\n  return pSigs.map(p => p.signature);\n}\n/**\n * Retrieves the partial signatures (Psigs) from the input's final scripts.\n * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.\n * Only canonical script signatures are considered.\n *\n * @param input - The PsbtInput object representing the input.\n * @returns An array of PartialSig objects containing the extracted Psigs.\n */\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC9wc2J0dXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLEVBQUUsd0JBQXdCO0FBQzFCLEVBQUUsc0JBQXNCO0FBQ3hCLEVBQUUsOEJBQThCO0FBQ2hDLEVBQUUsbUNBQW1DO0FBQ3JDLEVBQUUsY0FBYztBQUNoQixFQUFFLG9CQUFvQjtBQUN0QixFQUFFLHFCQUFxQjtBQUN2QixFQUFFLGdCQUFnQjtBQUNsQixFQUFFLGVBQWU7QUFDakIsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsY0FBYztBQUNoQjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdJQUFpQztBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQywwR0FBVztBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyxvSEFBZ0I7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsMEdBQVc7QUFDcEMsaUJBQWlCLG1CQUFPLENBQUMsb0hBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLGdCQUFnQjtBQUNuQyIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BzYnQvcHNidHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNpZ25hdHVyZUJsb2Nrc0FjdGlvbiA9XG4gIGV4cG9ydHMuY2hlY2tJbnB1dEZvclNpZyA9XG4gIGV4cG9ydHMucHVia2V5SW5TY3JpcHQgPVxuICBleHBvcnRzLnB1YmtleVBvc2l0aW9uSW5TY3JpcHQgPVxuICBleHBvcnRzLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcyA9XG4gIGV4cG9ydHMuaXNQMlRSID1cbiAgZXhwb3J0cy5pc1AyU0hTY3JpcHQgPVxuICBleHBvcnRzLmlzUDJXU0hTY3JpcHQgPVxuICBleHBvcnRzLmlzUDJXUEtIID1cbiAgZXhwb3J0cy5pc1AyUEtIID1cbiAgZXhwb3J0cy5pc1AyUEsgPVxuICBleHBvcnRzLmlzUDJNUyA9XG4gICAgdm9pZCAwO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJ2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci92YXJpbnQnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKCcuLi90cmFuc2FjdGlvbicpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKCcuLi9jcnlwdG8nKTtcbmNvbnN0IHBheW1lbnRzID0gcmVxdWlyZSgnLi4vcGF5bWVudHMnKTtcbmZ1bmN0aW9uIGlzUGF5bWVudEZhY3RvcnkocGF5bWVudCkge1xuICByZXR1cm4gc2NyaXB0ID0+IHtcbiAgICB0cnkge1xuICAgICAgcGF5bWVudCh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuZXhwb3J0cy5pc1AyTVMgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAybXMpO1xuZXhwb3J0cy5pc1AyUEsgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAycGspO1xuZXhwb3J0cy5pc1AyUEtIID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMnBraCk7XG5leHBvcnRzLmlzUDJXUEtIID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMndwa2gpO1xuZXhwb3J0cy5pc1AyV1NIU2NyaXB0ID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMndzaCk7XG5leHBvcnRzLmlzUDJTSFNjcmlwdCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJzaCk7XG5leHBvcnRzLmlzUDJUUiA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJ0cik7XG4vKipcbiAqIENvbnZlcnRzIGEgd2l0bmVzcyBzdGFjayB0byBhIHNjcmlwdCB3aXRuZXNzLlxuICogQHBhcmFtIHdpdG5lc3MgVGhlIHdpdG5lc3Mgc3RhY2sgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBzY3JpcHQgd2l0bmVzcyBhcyBhIEJ1ZmZlci5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0cyBhIHdpdG5lc3Mgc3RhY2sgdG8gYSBzY3JpcHQgd2l0bmVzcy5cbiAqIEBwYXJhbSB3aXRuZXNzIFRoZSB3aXRuZXNzIHN0YWNrIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHNjcmlwdCB3aXRuZXNzLlxuICovXG5mdW5jdGlvbiB3aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3Mod2l0bmVzcykge1xuICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICBmdW5jdGlvbiB3cml0ZVNsaWNlKHNsaWNlKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBCdWZmZXIuZnJvbShzbGljZSldKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZhckludChpKSB7XG4gICAgY29uc3QgY3VycmVudExlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY29uc3QgdmFyaW50TGVuID0gdmFydWludC5lbmNvZGluZ0xlbmd0aChpKTtcbiAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIEJ1ZmZlci5hbGxvY1Vuc2FmZSh2YXJpbnRMZW4pXSk7XG4gICAgdmFydWludC5lbmNvZGUoaSwgYnVmZmVyLCBjdXJyZW50TGVuKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZhclNsaWNlKHNsaWNlKSB7XG4gICAgd3JpdGVWYXJJbnQoc2xpY2UubGVuZ3RoKTtcbiAgICB3cml0ZVNsaWNlKHNsaWNlKTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVZlY3Rvcih2ZWN0b3IpIHtcbiAgICB3cml0ZVZhckludCh2ZWN0b3IubGVuZ3RoKTtcbiAgICB2ZWN0b3IuZm9yRWFjaCh3cml0ZVZhclNsaWNlKTtcbiAgfVxuICB3cml0ZVZlY3Rvcih3aXRuZXNzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMud2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzID0gd2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzO1xuLyoqXG4gKiBGaW5kcyB0aGUgcG9zaXRpb24gb2YgYSBwdWJsaWMga2V5IGluIGEgc2NyaXB0LlxuICogQHBhcmFtIHB1YmtleSBUaGUgcHVibGljIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHNjcmlwdCBUaGUgc2NyaXB0IHRvIHNlYXJjaCBpbi5cbiAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgcHVibGljIGtleSBpbiB0aGUgc2NyaXB0LCBvciAtMSBpZiBub3QgZm91bmQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYW4gdW5rbm93biBzY3JpcHQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIHB1YmtleVBvc2l0aW9uSW5TY3JpcHQocHVia2V5LCBzY3JpcHQpIHtcbiAgY29uc3QgcHVia2V5SGFzaCA9ICgwLCBjcnlwdG9fMS5oYXNoMTYwKShwdWJrZXkpO1xuICBjb25zdCBwdWJrZXlYT25seSA9IHB1YmtleS5zbGljZSgxLCAzMyk7IC8vIHNsaWNlIGJlZm9yZSBjYWxsaW5nP1xuICBjb25zdCBkZWNvbXBpbGVkID0gYnNjcmlwdC5kZWNvbXBpbGUoc2NyaXB0KTtcbiAgaWYgKGRlY29tcGlsZWQgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBzY3JpcHQgZXJyb3InKTtcbiAgcmV0dXJuIGRlY29tcGlsZWQuZmluZEluZGV4KGVsZW1lbnQgPT4ge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKFxuICAgICAgZWxlbWVudC5lcXVhbHMocHVia2V5KSB8fFxuICAgICAgZWxlbWVudC5lcXVhbHMocHVia2V5SGFzaCkgfHxcbiAgICAgIGVsZW1lbnQuZXF1YWxzKHB1YmtleVhPbmx5KVxuICAgICk7XG4gIH0pO1xufVxuZXhwb3J0cy5wdWJrZXlQb3NpdGlvbkluU2NyaXB0ID0gcHVia2V5UG9zaXRpb25JblNjcmlwdDtcbi8qKlxuICogQ2hlY2tzIGlmIGEgcHVibGljIGtleSBpcyBwcmVzZW50IGluIGEgc2NyaXB0LlxuICogQHBhcmFtIHB1YmtleSBUaGUgcHVibGljIGtleSB0byBjaGVjay5cbiAqIEBwYXJhbSBzY3JpcHQgVGhlIHNjcmlwdCB0byBzZWFyY2ggaW4uXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwdWJsaWMga2V5IGlzIHByZXNlbnQgaW4gdGhlIHNjcmlwdC5cbiAqL1xuZnVuY3Rpb24gcHVia2V5SW5TY3JpcHQocHVia2V5LCBzY3JpcHQpIHtcbiAgcmV0dXJuIHB1YmtleVBvc2l0aW9uSW5TY3JpcHQocHVia2V5LCBzY3JpcHQpICE9PSAtMTtcbn1cbmV4cG9ydHMucHVia2V5SW5TY3JpcHQgPSBwdWJrZXlJblNjcmlwdDtcbi8qKlxuICogQ2hlY2tzIGlmIGFuIGlucHV0IGNvbnRhaW5zIGEgc2lnbmF0dXJlIGZvciBhIHNwZWNpZmljIGFjdGlvbi5cbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBpbnB1dCB0byBjaGVjay5cbiAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgYWN0aW9uIHRvIGNoZWNrIGZvci5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGlucHV0IGNvbnRhaW5zIGEgc2lnbmF0dXJlIGZvciB0aGUgc3BlY2lmaWVkIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2hlY2tJbnB1dEZvclNpZyhpbnB1dCwgYWN0aW9uKSB7XG4gIGNvbnN0IHBTaWdzID0gZXh0cmFjdFBhcnRpYWxTaWdzKGlucHV0KTtcbiAgcmV0dXJuIHBTaWdzLnNvbWUocFNpZyA9PlxuICAgIHNpZ25hdHVyZUJsb2Nrc0FjdGlvbihwU2lnLCBic2NyaXB0LnNpZ25hdHVyZS5kZWNvZGUsIGFjdGlvbiksXG4gICk7XG59XG5leHBvcnRzLmNoZWNrSW5wdXRGb3JTaWcgPSBjaGVja0lucHV0Rm9yU2lnO1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gYWN0aW9uIGlzIGFsbG93ZWQgZm9yIGEgc2lnbmF0dXJlIGJsb2NrLlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgYmxvY2suXG4gKiBAcGFyYW0gc2lnbmF0dXJlRGVjb2RlRm4gLSBUaGUgZnVuY3Rpb24gdXNlZCB0byBkZWNvZGUgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgYWN0aW9uIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBhY3Rpb24gaXMgYWxsb3dlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBzaWduYXR1cmVCbG9ja3NBY3Rpb24oc2lnbmF0dXJlLCBzaWduYXR1cmVEZWNvZGVGbiwgYWN0aW9uKSB7XG4gIGNvbnN0IHsgaGFzaFR5cGUgfSA9IHNpZ25hdHVyZURlY29kZUZuKHNpZ25hdHVyZSk7XG4gIGNvbnN0IHdoaXRlbGlzdCA9IFtdO1xuICBjb25zdCBpc0FueW9uZUNhblBheSA9XG4gICAgaGFzaFR5cGUgJiB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZO1xuICBpZiAoaXNBbnlvbmVDYW5QYXkpIHdoaXRlbGlzdC5wdXNoKCdhZGRJbnB1dCcpO1xuICBjb25zdCBoYXNoTW9kID0gaGFzaFR5cGUgJiAweDFmO1xuICBzd2l0Y2ggKGhhc2hNb2QpIHtcbiAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw6XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEU6XG4gICAgY2FzZSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORTpcbiAgICAgIHdoaXRlbGlzdC5wdXNoKCdhZGRPdXRwdXQnKTtcbiAgICAgIHdoaXRlbGlzdC5wdXNoKCdzZXRJbnB1dFNlcXVlbmNlJyk7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAod2hpdGVsaXN0LmluZGV4T2YoYWN0aW9uKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLnNpZ25hdHVyZUJsb2Nrc0FjdGlvbiA9IHNpZ25hdHVyZUJsb2Nrc0FjdGlvbjtcbi8qKlxuICogRXh0cmFjdHMgdGhlIHNpZ25hdHVyZXMgZnJvbSBhIFBzYnRJbnB1dCBvYmplY3QuXG4gKiBJZiB0aGUgaW5wdXQgaGFzIHBhcnRpYWwgc2lnbmF0dXJlcywgaXQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgc2lnbmF0dXJlcy5cbiAqIElmIHRoZSBpbnB1dCBkb2VzIG5vdCBoYXZlIHBhcnRpYWwgc2lnbmF0dXJlcywgaXQgY2hlY2tzIGlmIGl0IGhhcyBhIGZpbmFsU2NyaXB0U2lnIG9yIGZpbmFsU2NyaXB0V2l0bmVzcy5cbiAqIElmIGl0IGRvZXMsIGl0IGV4dHJhY3RzIHRoZSBzaWduYXR1cmVzIGZyb20gdGhlIGZpbmFsIHNjcmlwdHMgYW5kIHJldHVybnMgdGhlbS5cbiAqIElmIG5vbmUgb2YgdGhlIGFib3ZlIGNvbmRpdGlvbnMgYXJlIG1ldCwgaXQgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgUHNidElucHV0IG9iamVjdCBmcm9tIHdoaWNoIHRvIGV4dHJhY3QgdGhlIHNpZ25hdHVyZXMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzaWduYXR1cmVzIGV4dHJhY3RlZCBmcm9tIHRoZSBQc2J0SW5wdXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBleHRyYWN0UGFydGlhbFNpZ3MoaW5wdXQpIHtcbiAgbGV0IHBTaWdzID0gW107XG4gIGlmICgoaW5wdXQucGFydGlhbFNpZyB8fCBbXSkubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKCFpbnB1dC5maW5hbFNjcmlwdFNpZyAmJiAhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzKSByZXR1cm4gW107XG4gICAgcFNpZ3MgPSBnZXRQc2lnc0Zyb21JbnB1dEZpbmFsU2NyaXB0cyhpbnB1dCk7XG4gIH0gZWxzZSB7XG4gICAgcFNpZ3MgPSBpbnB1dC5wYXJ0aWFsU2lnO1xuICB9XG4gIHJldHVybiBwU2lncy5tYXAocCA9PiBwLnNpZ25hdHVyZSk7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgcGFydGlhbCBzaWduYXR1cmVzIChQc2lncykgZnJvbSB0aGUgaW5wdXQncyBmaW5hbCBzY3JpcHRzLlxuICogUHNpZ3MgYXJlIGV4dHJhY3RlZCBmcm9tIGJvdGggdGhlIGZpbmFsIHNjcmlwdFNpZyBhbmQgZmluYWwgc2NyaXB0V2l0bmVzcyBvZiB0aGUgaW5wdXQuXG4gKiBPbmx5IGNhbm9uaWNhbCBzY3JpcHQgc2lnbmF0dXJlcyBhcmUgY29uc2lkZXJlZC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgUHNidElucHV0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGlucHV0LlxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgUGFydGlhbFNpZyBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGV4dHJhY3RlZCBQc2lncy5cbiAqL1xuZnVuY3Rpb24gZ2V0UHNpZ3NGcm9tSW5wdXRGaW5hbFNjcmlwdHMoaW5wdXQpIHtcbiAgY29uc3Qgc2NyaXB0SXRlbXMgPSAhaW5wdXQuZmluYWxTY3JpcHRTaWdcbiAgICA/IFtdXG4gICAgOiBic2NyaXB0LmRlY29tcGlsZShpbnB1dC5maW5hbFNjcmlwdFNpZykgfHwgW107XG4gIGNvbnN0IHdpdG5lc3NJdGVtcyA9ICFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3NcbiAgICA/IFtdXG4gICAgOiBic2NyaXB0LmRlY29tcGlsZShpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MpIHx8IFtdO1xuICByZXR1cm4gc2NyaXB0SXRlbXNcbiAgICAuY29uY2F0KHdpdG5lc3NJdGVtcylcbiAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihpdGVtKSAmJiBic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGl0ZW0pO1xuICAgIH0pXG4gICAgLm1hcChzaWcgPT4gKHsgc2lnbmF0dXJlOiBzaWcgfSkpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/psbt/psbtutils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/push_data.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/push_data.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = exports.encodingLength = void 0;\nconst ops_1 = __webpack_require__(/*! ./ops */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ops.js\");\n/**\n * Calculates the encoding length of a number used for push data in Bitcoin transactions.\n * @param i The number to calculate the encoding length for.\n * @returns The encoding length of the number.\n */\nfunction encodingLength(i) {\n  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\nexports.encodingLength = encodingLength;\n/**\n * Encodes a number into a buffer using a variable-length encoding scheme.\n * The encoded buffer is written starting at the specified offset.\n * Returns the size of the encoded buffer.\n *\n * @param buffer - The buffer to write the encoded data into.\n * @param num - The number to encode.\n * @param offset - The offset at which to start writing the encoded buffer.\n * @returns The size of the encoded buffer.\n */\nfunction encode(buffer, num, offset) {\n  const size = encodingLength(num);\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(num, offset);\n    // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);\n    buffer.writeUInt8(num, offset + 1);\n    // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);\n    buffer.writeUInt16LE(num, offset + 1);\n    // 32 bit\n  } else {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);\n    buffer.writeUInt32LE(num, offset + 1);\n  }\n  return size;\n}\nexports.encode = encode;\n/**\n * Decodes a buffer and returns information about the opcode, number, and size.\n * @param buffer - The buffer to decode.\n * @param offset - The offset within the buffer to start decoding.\n * @returns An object containing the opcode, number, and size, or null if decoding fails.\n */\nfunction decode(buffer, offset) {\n  const opcode = buffer.readUInt8(offset);\n  let num;\n  let size;\n  // ~6 bit\n  if (opcode < ops_1.OPS.OP_PUSHDATA1) {\n    num = opcode;\n    size = 1;\n    // 8 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null;\n    num = buffer.readUInt8(offset + 1);\n    size = 2;\n    // 16 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null;\n    num = buffer.readUInt16LE(offset + 1);\n    size = 3;\n    // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null;\n    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');\n    num = buffer.readUInt32LE(offset + 1);\n    size = 5;\n  }\n  return {\n    opcode,\n    number: num,\n    size,\n  };\n}\nexports.decode = decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHVzaF9kYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjLEdBQUcsc0JBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyxtR0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wdXNoX2RhdGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLmVuY29kaW5nTGVuZ3RoID0gdm9pZCAwO1xuY29uc3Qgb3BzXzEgPSByZXF1aXJlKCcuL29wcycpO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBlbmNvZGluZyBsZW5ndGggb2YgYSBudW1iZXIgdXNlZCBmb3IgcHVzaCBkYXRhIGluIEJpdGNvaW4gdHJhbnNhY3Rpb25zLlxuICogQHBhcmFtIGkgVGhlIG51bWJlciB0byBjYWxjdWxhdGUgdGhlIGVuY29kaW5nIGxlbmd0aCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RpbmcgbGVuZ3RoIG9mIHRoZSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoKGkpIHtcbiAgcmV0dXJuIGkgPCBvcHNfMS5PUFMuT1BfUFVTSERBVEExID8gMSA6IGkgPD0gMHhmZiA/IDIgOiBpIDw9IDB4ZmZmZiA/IDMgOiA1O1xufVxuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoO1xuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIGludG8gYSBidWZmZXIgdXNpbmcgYSB2YXJpYWJsZS1sZW5ndGggZW5jb2Rpbmcgc2NoZW1lLlxuICogVGhlIGVuY29kZWQgYnVmZmVyIGlzIHdyaXR0ZW4gc3RhcnRpbmcgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBlbmNvZGVkIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB0byB3cml0ZSB0aGUgZW5jb2RlZCBkYXRhIGludG8uXG4gKiBAcGFyYW0gbnVtIC0gVGhlIG51bWJlciB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nIHRoZSBlbmNvZGVkIGJ1ZmZlci5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSBlbmNvZGVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgbnVtLCBvZmZzZXQpIHtcbiAgY29uc3Qgc2l6ZSA9IGVuY29kaW5nTGVuZ3RoKG51bSk7XG4gIC8vIH42IGJpdFxuICBpZiAoc2l6ZSA9PT0gMSkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG51bSwgb2Zmc2V0KTtcbiAgICAvLyA4IGJpdFxuICB9IGVsc2UgaWYgKHNpemUgPT09IDIpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChvcHNfMS5PUFMuT1BfUFVTSERBVEExLCBvZmZzZXQpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG51bSwgb2Zmc2V0ICsgMSk7XG4gICAgLy8gMTYgYml0XG4gIH0gZWxzZSBpZiAoc2l6ZSA9PT0gMykge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG9wc18xLk9QUy5PUF9QVVNIREFUQTIsIG9mZnNldCk7XG4gICAgYnVmZmVyLndyaXRlVUludDE2TEUobnVtLCBvZmZzZXQgKyAxKTtcbiAgICAvLyAzMiBiaXRcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChvcHNfMS5PUFMuT1BfUFVTSERBVEE0LCBvZmZzZXQpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKG51bSwgb2Zmc2V0ICsgMSk7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogRGVjb2RlcyBhIGJ1ZmZlciBhbmQgcmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3Bjb2RlLCBudW1iZXIsIGFuZCBzaXplLlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgd2l0aGluIHRoZSBidWZmZXIgdG8gc3RhcnQgZGVjb2RpbmcuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb3Bjb2RlLCBudW1iZXIsIGFuZCBzaXplLCBvciBudWxsIGlmIGRlY29kaW5nIGZhaWxzLlxuICovXG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3Qgb3Bjb2RlID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBsZXQgbnVtO1xuICBsZXQgc2l6ZTtcbiAgLy8gfjYgYml0XG4gIGlmIChvcGNvZGUgPCBvcHNfMS5PUFMuT1BfUFVTSERBVEExKSB7XG4gICAgbnVtID0gb3Bjb2RlO1xuICAgIHNpemUgPSAxO1xuICAgIC8vIDggYml0XG4gIH0gZWxzZSBpZiAob3Bjb2RlID09PSBvcHNfMS5PUFMuT1BfUFVTSERBVEExKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPiBidWZmZXIubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBudW0gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCArIDEpO1xuICAgIHNpemUgPSAyO1xuICAgIC8vIDE2IGJpdFxuICB9IGVsc2UgaWYgKG9wY29kZSA9PT0gb3BzXzEuT1BTLk9QX1BVU0hEQVRBMikge1xuICAgIGlmIChvZmZzZXQgKyAzID4gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgbnVtID0gYnVmZmVyLnJlYWRVSW50MTZMRShvZmZzZXQgKyAxKTtcbiAgICBzaXplID0gMztcbiAgICAvLyAzMiBiaXRcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgNSA+IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIGlmIChvcGNvZGUgIT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTQpIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBvcGNvZGUnKTtcbiAgICBudW0gPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpO1xuICAgIHNpemUgPSA1O1xuICB9XG4gIHJldHVybiB7XG4gICAgb3Bjb2RlLFxuICAgIG51bWJlcjogbnVtLFxuICAgIHNpemUsXG4gIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/push_data.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.signature =\n  exports.number =\n  exports.isCanonicalScriptSignature =\n  exports.isDefinedHashType =\n  exports.isCanonicalPubKey =\n  exports.toStack =\n  exports.fromASM =\n  exports.toASM =\n  exports.decompile =\n  exports.compile =\n  exports.countNonPushOnlyOPs =\n  exports.isPushOnly =\n  exports.OPS =\n    void 0;\n/**\n * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature\n * @packageDocumentation\n */\nconst bip66 = __webpack_require__(/*! ./bip66 */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bip66.js\");\nconst ops_1 = __webpack_require__(/*! ./ops */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/ops.js\");\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n}));\nconst pushdata = __webpack_require__(/*! ./push_data */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/push_data.js\");\nconst scriptNumber = __webpack_require__(/*! ./script_number */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_number.js\");\nconst scriptSignature = __webpack_require__(/*! ./script_signature */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_signature.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === ops_1.OPS.OP_0 ||\n      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||\n      value === ops_1.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nexports.countNonPushOnlyOPs = countNonPushOnlyOPs;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return ops_1.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n/**\n * Compiles an array of chunks into a Buffer.\n *\n * @param chunks - The array of chunks to compile.\n * @returns The compiled Buffer.\n * @throws Error if the compilation fails.\n */\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\n/**\n * Converts the given chunks into an ASM (Assembly) string representation.\n * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.\n * @param chunks - The chunks to convert into ASM.\n * @returns The ASM string representation of the chunks.\n */\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  if (!chunks) {\n    throw new Error('Could not convert invalid chunks to ASM');\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return ops_1.REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\n/**\n * Converts an ASM string to a Buffer.\n * @param asm The ASM string to convert.\n * @returns The converted Buffer.\n */\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\n/**\n * Converts the given chunks into a stack of buffers.\n *\n * @param chunks - The chunks to convert.\n * @returns The stack of buffers.\n */\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvc2NyaXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixFQUFFLGNBQWM7QUFDaEIsRUFBRSxrQ0FBa0M7QUFDcEMsRUFBRSx5QkFBeUI7QUFDM0IsRUFBRSx5QkFBeUI7QUFDM0IsRUFBRSxlQUFlO0FBQ2pCLEVBQUUsZUFBZTtBQUNqQixFQUFFLGFBQWE7QUFDZixFQUFFLGlCQUFpQjtBQUNuQixFQUFFLGVBQWU7QUFDakIsRUFBRSwyQkFBMkI7QUFDN0IsRUFBRSxrQkFBa0I7QUFDcEIsRUFBRSxXQUFXO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyx1R0FBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsbUdBQU87QUFDN0IsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRixpQkFBaUIsbUJBQU8sQ0FBQywrR0FBYTtBQUN0QyxxQkFBcUIsbUJBQU8sQ0FBQyx1SEFBaUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsNkhBQW9CO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQyx1R0FBUztBQUMvQixRQUFRLFlBQVk7QUFDcEIsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsY0FBYztBQUNkLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3NjcmlwdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaWduYXR1cmUgPVxuICBleHBvcnRzLm51bWJlciA9XG4gIGV4cG9ydHMuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUgPVxuICBleHBvcnRzLmlzRGVmaW5lZEhhc2hUeXBlID1cbiAgZXhwb3J0cy5pc0Nhbm9uaWNhbFB1YktleSA9XG4gIGV4cG9ydHMudG9TdGFjayA9XG4gIGV4cG9ydHMuZnJvbUFTTSA9XG4gIGV4cG9ydHMudG9BU00gPVxuICBleHBvcnRzLmRlY29tcGlsZSA9XG4gIGV4cG9ydHMuY29tcGlsZSA9XG4gIGV4cG9ydHMuY291bnROb25QdXNoT25seU9QcyA9XG4gIGV4cG9ydHMuaXNQdXNoT25seSA9XG4gIGV4cG9ydHMuT1BTID1cbiAgICB2b2lkIDA7XG4vKipcbiAqIFNjcmlwdCB0b29scywgaW5jbHVkaW5nIGRlY29tcGlsZSwgY29tcGlsZSwgdG9BU00sIGZyb21BU00sIHRvU3RhY2ssIGlzQ2Fub25pY2FsUHViS2V5LCBpc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZVxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbmNvbnN0IGJpcDY2ID0gcmVxdWlyZSgnLi9iaXA2NicpO1xuY29uc3Qgb3BzXzEgPSByZXF1aXJlKCcuL29wcycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdPUFMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvcHNfMS5PUFM7XG4gIH0sXG59KTtcbmNvbnN0IHB1c2hkYXRhID0gcmVxdWlyZSgnLi9wdXNoX2RhdGEnKTtcbmNvbnN0IHNjcmlwdE51bWJlciA9IHJlcXVpcmUoJy4vc2NyaXB0X251bWJlcicpO1xuY29uc3Qgc2NyaXB0U2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zY3JpcHRfc2lnbmF0dXJlJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHsgdHlwZWZvcmNlIH0gPSB0eXBlcztcbmNvbnN0IE9QX0lOVF9CQVNFID0gb3BzXzEuT1BTLk9QX1JFU0VSVkVEOyAvLyBPUF8xIC0gMVxuZnVuY3Rpb24gaXNPUEludCh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVzLk51bWJlcih2YWx1ZSkgJiZcbiAgICAodmFsdWUgPT09IG9wc18xLk9QUy5PUF8wIHx8XG4gICAgICAodmFsdWUgPj0gb3BzXzEuT1BTLk9QXzEgJiYgdmFsdWUgPD0gb3BzXzEuT1BTLk9QXzE2KSB8fFxuICAgICAgdmFsdWUgPT09IG9wc18xLk9QUy5PUF8xTkVHQVRFKVxuICApO1xufVxuZnVuY3Rpb24gaXNQdXNoT25seUNodW5rKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlcy5CdWZmZXIodmFsdWUpIHx8IGlzT1BJbnQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNQdXNoT25seSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZXMuQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGlzUHVzaE9ubHlDaHVuayk7XG59XG5leHBvcnRzLmlzUHVzaE9ubHkgPSBpc1B1c2hPbmx5O1xuZnVuY3Rpb24gY291bnROb25QdXNoT25seU9Qcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubGVuZ3RoIC0gdmFsdWUuZmlsdGVyKGlzUHVzaE9ubHlDaHVuaykubGVuZ3RoO1xufVxuZXhwb3J0cy5jb3VudE5vblB1c2hPbmx5T1BzID0gY291bnROb25QdXNoT25seU9QcztcbmZ1bmN0aW9uIGFzTWluaW1hbE9QKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG9wc18xLk9QUy5PUF8wO1xuICBpZiAoYnVmZmVyLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xuICBpZiAoYnVmZmVyWzBdID49IDEgJiYgYnVmZmVyWzBdIDw9IDE2KSByZXR1cm4gT1BfSU5UX0JBU0UgKyBidWZmZXJbMF07XG4gIGlmIChidWZmZXJbMF0gPT09IDB4ODEpIHJldHVybiBvcHNfMS5PUFMuT1BfMU5FR0FURTtcbn1cbmZ1bmN0aW9uIGNodW5rc0lzQnVmZmVyKGJ1Zikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGJ1Zik7XG59XG5mdW5jdGlvbiBjaHVua3NJc0FycmF5KGJ1Zikge1xuICByZXR1cm4gdHlwZXMuQXJyYXkoYnVmKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZUNodW5rSXNCdWZmZXIoYnVmKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYnVmKTtcbn1cbi8qKlxuICogQ29tcGlsZXMgYW4gYXJyYXkgb2YgY2h1bmtzIGludG8gYSBCdWZmZXIuXG4gKlxuICogQHBhcmFtIGNodW5rcyAtIFRoZSBhcnJheSBvZiBjaHVua3MgdG8gY29tcGlsZS5cbiAqIEByZXR1cm5zIFRoZSBjb21waWxlZCBCdWZmZXIuXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjb21waWxhdGlvbiBmYWlscy5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShjaHVua3MpIHtcbiAgLy8gVE9ETzogcmVtb3ZlIG1lXG4gIGlmIChjaHVua3NJc0J1ZmZlcihjaHVua3MpKSByZXR1cm4gY2h1bmtzO1xuICB0eXBlZm9yY2UodHlwZXMuQXJyYXksIGNodW5rcyk7XG4gIGNvbnN0IGJ1ZmZlclNpemUgPSBjaHVua3MucmVkdWNlKChhY2N1bSwgY2h1bmspID0+IHtcbiAgICAvLyBkYXRhIGNodW5rXG4gICAgaWYgKHNpbmdsZUNodW5rSXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAvLyBhZGhlcmUgdG8gQklQNjIuMywgbWluaW1hbCBwdXNoIHBvbGljeVxuICAgICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMSAmJiBhc01pbmltYWxPUChjaHVuaykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYWNjdW0gKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtICsgcHVzaGRhdGEuZW5jb2RpbmdMZW5ndGgoY2h1bmsubGVuZ3RoKSArIGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gb3Bjb2RlXG4gICAgcmV0dXJuIGFjY3VtICsgMTtcbiAgfSwgMC4wKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZmZlclNpemUpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY2h1bmtzLmZvckVhY2goY2h1bmsgPT4ge1xuICAgIC8vIGRhdGEgY2h1bmtcbiAgICBpZiAoc2luZ2xlQ2h1bmtJc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIC8vIGFkaGVyZSB0byBCSVA2Mi4zLCBtaW5pbWFsIHB1c2ggcG9saWN5XG4gICAgICBjb25zdCBvcGNvZGUgPSBhc01pbmltYWxPUChjaHVuayk7XG4gICAgICBpZiAob3Bjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgob3Bjb2RlLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ICs9IHB1c2hkYXRhLmVuY29kZShidWZmZXIsIGNodW5rLmxlbmd0aCwgb2Zmc2V0KTtcbiAgICAgIGNodW5rLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIC8vIG9wY29kZVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIud3JpdGVVSW50OChjaHVuaywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgfSk7XG4gIGlmIChvZmZzZXQgIT09IGJ1ZmZlci5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlY29kZSBjaHVua3MnKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG5mdW5jdGlvbiBkZWNvbXBpbGUoYnVmZmVyKSB7XG4gIC8vIFRPRE86IHJlbW92ZSBtZVxuICBpZiAoY2h1bmtzSXNBcnJheShidWZmZXIpKSByZXR1cm4gYnVmZmVyO1xuICB0eXBlZm9yY2UodHlwZXMuQnVmZmVyLCBidWZmZXIpO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBjb25zdCBvcGNvZGUgPSBidWZmZXJbaV07XG4gICAgLy8gZGF0YSBjaHVua1xuICAgIGlmIChvcGNvZGUgPiBvcHNfMS5PUFMuT1BfMCAmJiBvcGNvZGUgPD0gb3BzXzEuT1BTLk9QX1BVU0hEQVRBNCkge1xuICAgICAgY29uc3QgZCA9IHB1c2hkYXRhLmRlY29kZShidWZmZXIsIGkpO1xuICAgICAgLy8gZGlkIHJlYWRpbmcgYSBwdXNoRGF0YUludCBmYWlsP1xuICAgICAgaWYgKGQgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgaSArPSBkLnNpemU7XG4gICAgICAvLyBhdHRlbXB0IHRvIHJlYWQgdG9vIG11Y2ggZGF0YT9cbiAgICAgIGlmIChpICsgZC5udW1iZXIgPiBidWZmZXIubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuc2xpY2UoaSwgaSArIGQubnVtYmVyKTtcbiAgICAgIGkgKz0gZC5udW1iZXI7XG4gICAgICAvLyBkZWNvbXBpbGUgbWluaW1hbGx5XG4gICAgICBjb25zdCBvcCA9IGFzTWluaW1hbE9QKGRhdGEpO1xuICAgICAgaWYgKG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2h1bmtzLnB1c2gob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmtzLnB1c2goZGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBvcGNvZGVcbiAgICB9IGVsc2Uge1xuICAgICAgY2h1bmtzLnB1c2gob3Bjb2RlKTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNodW5rcztcbn1cbmV4cG9ydHMuZGVjb21waWxlID0gZGVjb21waWxlO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gY2h1bmtzIGludG8gYW4gQVNNIChBc3NlbWJseSkgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICogSWYgdGhlIGNodW5rcyBwYXJhbWV0ZXIgaXMgYSBCdWZmZXIsIGl0IHdpbGwgYmUgZGVjb21waWxlZCBpbnRvIGEgU3RhY2sgYmVmb3JlIGNvbnZlcnNpb24uXG4gKiBAcGFyYW0gY2h1bmtzIC0gVGhlIGNodW5rcyB0byBjb252ZXJ0IGludG8gQVNNLlxuICogQHJldHVybnMgVGhlIEFTTSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNodW5rcy5cbiAqL1xuZnVuY3Rpb24gdG9BU00oY2h1bmtzKSB7XG4gIGlmIChjaHVua3NJc0J1ZmZlcihjaHVua3MpKSB7XG4gICAgY2h1bmtzID0gZGVjb21waWxlKGNodW5rcyk7XG4gIH1cbiAgaWYgKCFjaHVua3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGludmFsaWQgY2h1bmtzIHRvIEFTTScpO1xuICB9XG4gIHJldHVybiBjaHVua3NcbiAgICAubWFwKGNodW5rID0+IHtcbiAgICAgIC8vIGRhdGE/XG4gICAgICBpZiAoc2luZ2xlQ2h1bmtJc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgICAgY29uc3Qgb3AgPSBhc01pbmltYWxPUChjaHVuayk7XG4gICAgICAgIGlmIChvcCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY2h1bmsudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICBjaHVuayA9IG9wO1xuICAgICAgfVxuICAgICAgLy8gb3Bjb2RlIVxuICAgICAgcmV0dXJuIG9wc18xLlJFVkVSU0VfT1BTW2NodW5rXTtcbiAgICB9KVxuICAgIC5qb2luKCcgJyk7XG59XG5leHBvcnRzLnRvQVNNID0gdG9BU007XG4vKipcbiAqIENvbnZlcnRzIGFuIEFTTSBzdHJpbmcgdG8gYSBCdWZmZXIuXG4gKiBAcGFyYW0gYXNtIFRoZSBBU00gc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIEJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gZnJvbUFTTShhc20pIHtcbiAgdHlwZWZvcmNlKHR5cGVzLlN0cmluZywgYXNtKTtcbiAgcmV0dXJuIGNvbXBpbGUoXG4gICAgYXNtLnNwbGl0KCcgJykubWFwKGNodW5rU3RyID0+IHtcbiAgICAgIC8vIG9wY29kZT9cbiAgICAgIGlmIChvcHNfMS5PUFNbY2h1bmtTdHJdICE9PSB1bmRlZmluZWQpIHJldHVybiBvcHNfMS5PUFNbY2h1bmtTdHJdO1xuICAgICAgdHlwZWZvcmNlKHR5cGVzLkhleCwgY2h1bmtTdHIpO1xuICAgICAgLy8gZGF0YSFcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShjaHVua1N0ciwgJ2hleCcpO1xuICAgIH0pLFxuICApO1xufVxuZXhwb3J0cy5mcm9tQVNNID0gZnJvbUFTTTtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGNodW5rcyBpbnRvIGEgc3RhY2sgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0gY2h1bmtzIC0gVGhlIGNodW5rcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHN0YWNrIG9mIGJ1ZmZlcnMuXG4gKi9cbmZ1bmN0aW9uIHRvU3RhY2soY2h1bmtzKSB7XG4gIGNodW5rcyA9IGRlY29tcGlsZShjaHVua3MpO1xuICB0eXBlZm9yY2UoaXNQdXNoT25seSwgY2h1bmtzKTtcbiAgcmV0dXJuIGNodW5rcy5tYXAob3AgPT4ge1xuICAgIGlmIChzaW5nbGVDaHVua0lzQnVmZmVyKG9wKSkgcmV0dXJuIG9wO1xuICAgIGlmIChvcCA9PT0gb3BzXzEuT1BTLk9QXzApIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgcmV0dXJuIHNjcmlwdE51bWJlci5lbmNvZGUob3AgLSBPUF9JTlRfQkFTRSk7XG4gIH0pO1xufVxuZXhwb3J0cy50b1N0YWNrID0gdG9TdGFjaztcbmZ1bmN0aW9uIGlzQ2Fub25pY2FsUHViS2V5KGJ1ZmZlcikge1xuICByZXR1cm4gdHlwZXMuaXNQb2ludChidWZmZXIpO1xufVxuZXhwb3J0cy5pc0Nhbm9uaWNhbFB1YktleSA9IGlzQ2Fub25pY2FsUHViS2V5O1xuZnVuY3Rpb24gaXNEZWZpbmVkSGFzaFR5cGUoaGFzaFR5cGUpIHtcbiAgY29uc3QgaGFzaFR5cGVNb2QgPSBoYXNoVHlwZSAmIH4weDgwO1xuICAvLyByZXR1cm4gaGFzaFR5cGVNb2QgPiBTSUdIQVNIX0FMTCAmJiBoYXNoVHlwZU1vZCA8IFNJR0hBU0hfU0lOR0xFXG4gIHJldHVybiBoYXNoVHlwZU1vZCA+IDB4MDAgJiYgaGFzaFR5cGVNb2QgPCAweDA0O1xufVxuZXhwb3J0cy5pc0RlZmluZWRIYXNoVHlwZSA9IGlzRGVmaW5lZEhhc2hUeXBlO1xuZnVuY3Rpb24gaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoYnVmZmVyKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc0RlZmluZWRIYXNoVHlwZShidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYmlwNjYuY2hlY2soYnVmZmVyLnNsaWNlKDAsIC0xKSk7XG59XG5leHBvcnRzLmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlID0gaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmU7XG5leHBvcnRzLm51bWJlciA9IHNjcmlwdE51bWJlcjtcbmV4cG9ydHMuc2lnbmF0dXJlID0gc2NyaXB0U2lnbmF0dXJlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_number.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_number.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = void 0;\n/**\n * Decodes a script number from a buffer.\n *\n * @param buffer - The buffer containing the script number.\n * @param maxLength - The maximum length of the script number. Defaults to 4.\n * @param minimal - Whether the script number should be minimal. Defaults to true.\n * @returns The decoded script number.\n * @throws {TypeError} If the script number overflows the maximum length.\n * @throws {Error} If the script number is not minimally encoded when minimal is true.\n */\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\n/**\n * Encodes a number into a Buffer using a specific format.\n *\n * @param _number - The number to encode.\n * @returns The encoded number as a Buffer.\n */\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvc2NyaXB0X251bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9zY3JpcHRfbnVtYmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuLyoqXG4gKiBEZWNvZGVzIGEgc2NyaXB0IG51bWJlciBmcm9tIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIHNjcmlwdCBudW1iZXIuXG4gKiBAcGFyYW0gbWF4TGVuZ3RoIC0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBzY3JpcHQgbnVtYmVyLiBEZWZhdWx0cyB0byA0LlxuICogQHBhcmFtIG1pbmltYWwgLSBXaGV0aGVyIHRoZSBzY3JpcHQgbnVtYmVyIHNob3VsZCBiZSBtaW5pbWFsLiBEZWZhdWx0cyB0byB0cnVlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc2NyaXB0IG51bWJlci5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHNjcmlwdCBudW1iZXIgb3ZlcmZsb3dzIHRoZSBtYXhpbXVtIGxlbmd0aC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NyaXB0IG51bWJlciBpcyBub3QgbWluaW1hbGx5IGVuY29kZWQgd2hlbiBtaW5pbWFsIGlzIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShidWZmZXIsIG1heExlbmd0aCwgbWluaW1hbCkge1xuICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgNDtcbiAgbWluaW1hbCA9IG1pbmltYWwgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBtaW5pbWFsO1xuICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgaWYgKGxlbmd0aCA+IG1heExlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU2NyaXB0IG51bWJlciBvdmVyZmxvdycpO1xuICBpZiAobWluaW1hbCkge1xuICAgIGlmICgoYnVmZmVyW2xlbmd0aCAtIDFdICYgMHg3ZikgPT09IDApIHtcbiAgICAgIGlmIChsZW5ndGggPD0gMSB8fCAoYnVmZmVyW2xlbmd0aCAtIDJdICYgMHg4MCkgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLW1pbmltYWxseSBlbmNvZGVkIHNjcmlwdCBudW1iZXInKTtcbiAgICB9XG4gIH1cbiAgLy8gNDAtYml0XG4gIGlmIChsZW5ndGggPT09IDUpIHtcbiAgICBjb25zdCBhID0gYnVmZmVyLnJlYWRVSW50MzJMRSgwKTtcbiAgICBjb25zdCBiID0gYnVmZmVyLnJlYWRVSW50OCg0KTtcbiAgICBpZiAoYiAmIDB4ODApIHJldHVybiAtKChiICYgfjB4ODApICogMHgxMDAwMDAwMDAgKyBhKTtcbiAgICByZXR1cm4gYiAqIDB4MTAwMDAwMDAwICsgYTtcbiAgfVxuICAvLyAzMi1iaXQgLyAyNC1iaXQgLyAxNi1iaXQgLyA4LWJpdFxuICBsZXQgcmVzdWx0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdCB8PSBidWZmZXJbaV0gPDwgKDggKiBpKTtcbiAgfVxuICBpZiAoYnVmZmVyW2xlbmd0aCAtIDFdICYgMHg4MClcbiAgICByZXR1cm4gLShyZXN1bHQgJiB+KDB4ODAgPDwgKDggKiAobGVuZ3RoIC0gMSkpKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIHNjcmlwdE51bVNpemUoaSkge1xuICByZXR1cm4gaSA+IDB4N2ZmZmZmZmZcbiAgICA/IDVcbiAgICA6IGkgPiAweDdmZmZmZlxuICAgID8gNFxuICAgIDogaSA+IDB4N2ZmZlxuICAgID8gM1xuICAgIDogaSA+IDB4N2ZcbiAgICA/IDJcbiAgICA6IGkgPiAweDAwXG4gICAgPyAxXG4gICAgOiAwO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIGludG8gYSBCdWZmZXIgdXNpbmcgYSBzcGVjaWZpYyBmb3JtYXQuXG4gKlxuICogQHBhcmFtIF9udW1iZXIgLSBUaGUgbnVtYmVyIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIG51bWJlciBhcyBhIEJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKF9udW1iZXIpIHtcbiAgbGV0IHZhbHVlID0gTWF0aC5hYnMoX251bWJlcik7XG4gIGNvbnN0IHNpemUgPSBzY3JpcHROdW1TaXplKHZhbHVlKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICBjb25zdCBuZWdhdGl2ZSA9IF9udW1iZXIgPCAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlICYgMHhmZiwgaSk7XG4gICAgdmFsdWUgPj49IDg7XG4gIH1cbiAgaWYgKGJ1ZmZlcltzaXplIC0gMV0gJiAweDgwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgobmVnYXRpdmUgPyAweDgwIDogMHgwMCwgc2l6ZSAtIDEpO1xuICB9IGVsc2UgaWYgKG5lZ2F0aXZlKSB7XG4gICAgYnVmZmVyW3NpemUgLSAxXSB8PSAweDgwO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_signature.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_signature.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = void 0;\nconst bip66 = __webpack_require__(/*! ./bip66 */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bip66.js\");\nconst script_1 = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nconst ZERO = Buffer.alloc(1, 0);\n/**\n * Converts a buffer to a DER-encoded buffer.\n * @param x - The buffer to be converted.\n * @returns The DER-encoded buffer.\n */\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\n/**\n * Converts a DER-encoded signature to a buffer.\n * If the first byte of the input buffer is 0x00, it is skipped.\n * The resulting buffer is 32 bytes long, filled with zeros if necessary.\n * @param x - The DER-encoded signature.\n * @returns The converted buffer.\n */\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n/**\n * Decodes a buffer into a ScriptSignature object.\n * @param buffer - The buffer to decode.\n * @returns The decoded ScriptSignature object.\n * @throws Error if the hashType is invalid.\n */\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\n/**\n * Encodes a signature and hash type into a buffer.\n * @param signature - The signature to encode.\n * @param hashType - The hash type to encode.\n * @returns The encoded buffer.\n * @throws Error if the hashType is invalid.\n */\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvc2NyaXB0X3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYztBQUMvQixjQUFjLG1CQUFPLENBQUMsdUdBQVM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMseUdBQVU7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLHVHQUFTO0FBQy9CLFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNLHFCQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9iaXRjb2luanMtbGliQDYuMS43L25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9zY3JpcHRfc2lnbmF0dXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuY29uc3QgYmlwNjYgPSByZXF1aXJlKCcuL2JpcDY2Jyk7XG5jb25zdCBzY3JpcHRfMSA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHsgdHlwZWZvcmNlIH0gPSB0eXBlcztcbmNvbnN0IFpFUk8gPSBCdWZmZXIuYWxsb2MoMSwgMCk7XG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGEgREVSLWVuY29kZWQgYnVmZmVyLlxuICogQHBhcmFtIHggLSBUaGUgYnVmZmVyIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIFRoZSBERVItZW5jb2RlZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIHRvREVSKHgpIHtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoeFtpXSA9PT0gMCkgKytpO1xuICBpZiAoaSA9PT0geC5sZW5ndGgpIHJldHVybiBaRVJPO1xuICB4ID0geC5zbGljZShpKTtcbiAgaWYgKHhbMF0gJiAweDgwKSByZXR1cm4gQnVmZmVyLmNvbmNhdChbWkVSTywgeF0sIDEgKyB4Lmxlbmd0aCk7XG4gIHJldHVybiB4O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIGJ1ZmZlci5cbiAqIElmIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBpbnB1dCBidWZmZXIgaXMgMHgwMCwgaXQgaXMgc2tpcHBlZC5cbiAqIFRoZSByZXN1bHRpbmcgYnVmZmVyIGlzIDMyIGJ5dGVzIGxvbmcsIGZpbGxlZCB3aXRoIHplcm9zIGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSB4IC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBmcm9tREVSKHgpIHtcbiAgaWYgKHhbMF0gPT09IDB4MDApIHggPSB4LnNsaWNlKDEpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICBjb25zdCBic3RhcnQgPSBNYXRoLm1heCgwLCAzMiAtIHgubGVuZ3RoKTtcbiAgeC5jb3B5KGJ1ZmZlciwgYnN0YXJ0KTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8vIEJJUDYyOiAxIGJ5dGUgaGFzaFR5cGUgZmxhZyAob25seSAweDAxLCAweDAyLCAweDAzLCAweDgxLCAweDgyIGFuZCAweDgzIGFyZSBhbGxvd2VkKVxuLyoqXG4gKiBEZWNvZGVzIGEgYnVmZmVyIGludG8gYSBTY3JpcHRTaWduYXR1cmUgb2JqZWN0LlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgU2NyaXB0U2lnbmF0dXJlIG9iamVjdC5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhhc2hUeXBlIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgY29uc3QgaGFzaFR5cGUgPSBidWZmZXIucmVhZFVJbnQ4KGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgaWYgKCEoMCwgc2NyaXB0XzEuaXNEZWZpbmVkSGFzaFR5cGUpKGhhc2hUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoYXNoVHlwZSAnICsgaGFzaFR5cGUpO1xuICB9XG4gIGNvbnN0IGRlY29kZWQgPSBiaXA2Ni5kZWNvZGUoYnVmZmVyLnNsaWNlKDAsIC0xKSk7XG4gIGNvbnN0IHIgPSBmcm9tREVSKGRlY29kZWQucik7XG4gIGNvbnN0IHMgPSBmcm9tREVSKGRlY29kZWQucyk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW3IsIHNdLCA2NCk7XG4gIHJldHVybiB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqXG4gKiBFbmNvZGVzIGEgc2lnbmF0dXJlIGFuZCBoYXNoIHR5cGUgaW50byBhIGJ1ZmZlci5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBoYXNoVHlwZSAtIFRoZSBoYXNoIHR5cGUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgYnVmZmVyLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgaGFzaFR5cGUgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHNpZ25hdHVyZSwgaGFzaFR5cGUpIHtcbiAgdHlwZWZvcmNlKFxuICAgIHtcbiAgICAgIHNpZ25hdHVyZTogdHlwZXMuQnVmZmVyTig2NCksXG4gICAgICBoYXNoVHlwZTogdHlwZXMuVUludDgsXG4gICAgfSxcbiAgICB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfSxcbiAgKTtcbiAgaWYgKCEoMCwgc2NyaXB0XzEuaXNEZWZpbmVkSGFzaFR5cGUpKGhhc2hUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoYXNoVHlwZSAnICsgaGFzaFR5cGUpO1xuICB9XG4gIGNvbnN0IGhhc2hUeXBlQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDEpO1xuICBoYXNoVHlwZUJ1ZmZlci53cml0ZVVJbnQ4KGhhc2hUeXBlLCAwKTtcbiAgY29uc3QgciA9IHRvREVSKHNpZ25hdHVyZS5zbGljZSgwLCAzMikpO1xuICBjb25zdCBzID0gdG9ERVIoc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbYmlwNjYuZW5jb2RlKHIsIHMpLCBoYXNoVHlwZUJ1ZmZlcl0pO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script_signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = void 0;\nconst bufferutils_1 = __webpack_require__(/*! ./bufferutils */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/bufferutils.js\");\nconst bcrypto = __webpack_require__(/*! ./crypto */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/crypto.js\");\nconst bscript = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst script_1 = __webpack_require__(/*! ./script */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/script.js\");\nconst types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return bufferutils_1.varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    bufferutils_1.varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n/**\n * Represents a Bitcoin transaction.\n */\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  stripWitnesses() {\n    this.ins.forEach(input => {\n      input.witness = EMPTY_WITNESS; // Set witness data to an empty array\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      bufferutils_1.varuint.encodingLength(this.ins.length) +\n      bufferutils_1.varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    typeforce(\n      types.tuple(\n        types.UInt32,\n        typeforce.arrayOf(types.Buffer),\n        typeforce.arrayOf(types.Satoshi),\n        types.UInt32,\n      ),\n      arguments,\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        36 * this.ins.length,\n      );\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 * this.ins.length,\n      );\n      values.forEach(value => bufferWriter.writeUInt64(value));\n      hashAmounts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        4 * this.ins.length,\n      );\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = bcrypto.sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeUInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        varSliceSize(annex),\n      );\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(\n      'hex',\n    );\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nexports.Transaction = Transaction;\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_DEFAULT = 0x00;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_OUTPUT_MASK = 0x03;\nTransaction.SIGHASH_INPUT_MASK = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLHNCQUFzQixtQkFBTyxDQUFDLG1IQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFVO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFVO0FBQ2xDLGlCQUFpQixtQkFBTyxDQUFDLHlHQUFVO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyx1R0FBUztBQUMvQixRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnRjL21pZGwteC1iaXRjb2luLXN1bW1pdC1oYWNrYXRob24tMjAyNS91dHhvLXBzYnQtZGVtby9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdHJhbnNhY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBidWZmZXJ1dGlsc18xID0gcmVxdWlyZSgnLi9idWZmZXJ1dGlscycpO1xuY29uc3QgYmNyeXB0byA9IHJlcXVpcmUoJy4vY3J5cHRvJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmNvbnN0IHNjcmlwdF8xID0gcmVxdWlyZSgnLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgeyB0eXBlZm9yY2UgfSA9IHR5cGVzO1xuZnVuY3Rpb24gdmFyU2xpY2VTaXplKHNvbWVTY3JpcHQpIHtcbiAgY29uc3QgbGVuZ3RoID0gc29tZVNjcmlwdC5sZW5ndGg7XG4gIHJldHVybiBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgobGVuZ3RoKSArIGxlbmd0aDtcbn1cbmZ1bmN0aW9uIHZlY3RvclNpemUoc29tZVZlY3Rvcikge1xuICBjb25zdCBsZW5ndGggPSBzb21lVmVjdG9yLmxlbmd0aDtcbiAgcmV0dXJuIChcbiAgICBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgobGVuZ3RoKSArXG4gICAgc29tZVZlY3Rvci5yZWR1Y2UoKHN1bSwgd2l0bmVzcykgPT4ge1xuICAgICAgcmV0dXJuIHN1bSArIHZhclNsaWNlU2l6ZSh3aXRuZXNzKTtcbiAgICB9LCAwKVxuICApO1xufVxuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuY29uc3QgRU1QVFlfV0lUTkVTUyA9IFtdO1xuY29uc3QgWkVSTyA9IEJ1ZmZlci5mcm9tKFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICdoZXgnLFxuKTtcbmNvbnN0IE9ORSA9IEJ1ZmZlci5mcm9tKFxuICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gICdoZXgnLFxuKTtcbmNvbnN0IFZBTFVFX1VJTlQ2NF9NQVggPSBCdWZmZXIuZnJvbSgnZmZmZmZmZmZmZmZmZmZmZicsICdoZXgnKTtcbmNvbnN0IEJMQU5LX09VVFBVVCA9IHtcbiAgc2NyaXB0OiBFTVBUWV9CVUZGRVIsXG4gIHZhbHVlQnVmZmVyOiBWQUxVRV9VSU5UNjRfTUFYLFxufTtcbmZ1bmN0aW9uIGlzT3V0cHV0KG91dCkge1xuICByZXR1cm4gb3V0LnZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBCaXRjb2luIHRyYW5zYWN0aW9uLlxuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5sb2NrdGltZSA9IDA7XG4gICAgdGhpcy5pbnMgPSBbXTtcbiAgICB0aGlzLm91dHMgPSBbXTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIF9OT19TVFJJQ1QpIHtcbiAgICBjb25zdCBidWZmZXJSZWFkZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJSZWFkZXIoYnVmZmVyKTtcbiAgICBjb25zdCB0eCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHR4LnZlcnNpb24gPSBidWZmZXJSZWFkZXIucmVhZEludDMyKCk7XG4gICAgY29uc3QgbWFya2VyID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50OCgpO1xuICAgIGNvbnN0IGZsYWcgPSBidWZmZXJSZWFkZXIucmVhZFVJbnQ4KCk7XG4gICAgbGV0IGhhc1dpdG5lc3NlcyA9IGZhbHNlO1xuICAgIGlmIChcbiAgICAgIG1hcmtlciA9PT0gVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fTUFSS0VSICYmXG4gICAgICBmbGFnID09PSBUcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9GTEFHXG4gICAgKSB7XG4gICAgICBoYXNXaXRuZXNzZXMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJSZWFkZXIub2Zmc2V0IC09IDI7XG4gICAgfVxuICAgIGNvbnN0IHZpbkxlbiA9IGJ1ZmZlclJlYWRlci5yZWFkVmFySW50KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aW5MZW47ICsraSkge1xuICAgICAgdHguaW5zLnB1c2goe1xuICAgICAgICBoYXNoOiBidWZmZXJSZWFkZXIucmVhZFNsaWNlKDMyKSxcbiAgICAgICAgaW5kZXg6IGJ1ZmZlclJlYWRlci5yZWFkVUludDMyKCksXG4gICAgICAgIHNjcmlwdDogYnVmZmVyUmVhZGVyLnJlYWRWYXJTbGljZSgpLFxuICAgICAgICBzZXF1ZW5jZTogYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKSxcbiAgICAgICAgd2l0bmVzczogRU1QVFlfV0lUTkVTUyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB2b3V0TGVuID0gYnVmZmVyUmVhZGVyLnJlYWRWYXJJbnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZvdXRMZW47ICsraSkge1xuICAgICAgdHgub3V0cy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGJ1ZmZlclJlYWRlci5yZWFkVUludDY0KCksXG4gICAgICAgIHNjcmlwdDogYnVmZmVyUmVhZGVyLnJlYWRWYXJTbGljZSgpLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChoYXNXaXRuZXNzZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmluTGVuOyArK2kpIHtcbiAgICAgICAgdHguaW5zW2ldLndpdG5lc3MgPSBidWZmZXJSZWFkZXIucmVhZFZlY3RvcigpO1xuICAgICAgfVxuICAgICAgLy8gd2FzIHRoaXMgcG9pbnRsZXNzP1xuICAgICAgaWYgKCF0eC5oYXNXaXRuZXNzZXMoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBoYXMgc3VwZXJmbHVvdXMgd2l0bmVzcyBkYXRhJyk7XG4gICAgfVxuICAgIHR4LmxvY2t0aW1lID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKTtcbiAgICBpZiAoX05PX1NUUklDVCkgcmV0dXJuIHR4O1xuICAgIGlmIChidWZmZXJSZWFkZXIub2Zmc2V0ICE9PSBidWZmZXIubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc2FjdGlvbiBoYXMgdW5leHBlY3RlZCBkYXRhJyk7XG4gICAgcmV0dXJuIHR4O1xuICB9XG4gIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvbi5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpLCBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGlzQ29pbmJhc2VIYXNoKGJ1ZmZlcikge1xuICAgIHR5cGVmb3JjZSh0eXBlcy5IYXNoMjU2Yml0LCBidWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgICAgaWYgKGJ1ZmZlcltpXSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpc0NvaW5iYXNlKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlucy5sZW5ndGggPT09IDEgJiYgVHJhbnNhY3Rpb24uaXNDb2luYmFzZUhhc2godGhpcy5pbnNbMF0uaGFzaClcbiAgICApO1xuICB9XG4gIGFkZElucHV0KGhhc2gsIGluZGV4LCBzZXF1ZW5jZSwgc2NyaXB0U2lnKSB7XG4gICAgdHlwZWZvcmNlKFxuICAgICAgdHlwZXMudHVwbGUoXG4gICAgICAgIHR5cGVzLkhhc2gyNTZiaXQsXG4gICAgICAgIHR5cGVzLlVJbnQzMixcbiAgICAgICAgdHlwZXMubWF5YmUodHlwZXMuVUludDMyKSxcbiAgICAgICAgdHlwZXMubWF5YmUodHlwZXMuQnVmZmVyKSxcbiAgICAgICksXG4gICAgICBhcmd1bWVudHMsXG4gICAgKTtcbiAgICBpZiAodHlwZXMuTnVsbChzZXF1ZW5jZSkpIHtcbiAgICAgIHNlcXVlbmNlID0gVHJhbnNhY3Rpb24uREVGQVVMVF9TRVFVRU5DRTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBpbnB1dCdzIGluZGV4XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuaW5zLnB1c2goe1xuICAgICAgICBoYXNoLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc2NyaXB0OiBzY3JpcHRTaWcgfHwgRU1QVFlfQlVGRkVSLFxuICAgICAgICBzZXF1ZW5jZTogc2VxdWVuY2UsXG4gICAgICAgIHdpdG5lc3M6IEVNUFRZX1dJVE5FU1MsXG4gICAgICB9KSAtIDFcbiAgICApO1xuICB9XG4gIGFkZE91dHB1dChzY3JpcHRQdWJLZXksIHZhbHVlKSB7XG4gICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLkJ1ZmZlciwgdHlwZXMuU2F0b3NoaSksIGFyZ3VtZW50cyk7XG4gICAgLy8gQWRkIHRoZSBvdXRwdXQgYW5kIHJldHVybiB0aGUgb3V0cHV0J3MgaW5kZXhcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5vdXRzLnB1c2goe1xuICAgICAgICBzY3JpcHQ6IHNjcmlwdFB1YktleSxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9KSAtIDFcbiAgICApO1xuICB9XG4gIGhhc1dpdG5lc3NlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnMuc29tZSh4ID0+IHtcbiAgICAgIHJldHVybiB4LndpdG5lc3MubGVuZ3RoICE9PSAwO1xuICAgIH0pO1xuICB9XG4gIHN0cmlwV2l0bmVzc2VzKCkge1xuICAgIHRoaXMuaW5zLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgaW5wdXQud2l0bmVzcyA9IEVNUFRZX1dJVE5FU1M7IC8vIFNldCB3aXRuZXNzIGRhdGEgdG8gYW4gZW1wdHkgYXJyYXlcbiAgICB9KTtcbiAgfVxuICB3ZWlnaHQoKSB7XG4gICAgY29uc3QgYmFzZSA9IHRoaXMuYnl0ZUxlbmd0aChmYWxzZSk7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLmJ5dGVMZW5ndGgodHJ1ZSk7XG4gICAgcmV0dXJuIGJhc2UgKiAzICsgdG90YWw7XG4gIH1cbiAgdmlydHVhbFNpemUoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLndlaWdodCgpIC8gNCk7XG4gIH1cbiAgYnl0ZUxlbmd0aChfQUxMT1dfV0lUTkVTUyA9IHRydWUpIHtcbiAgICBjb25zdCBoYXNXaXRuZXNzZXMgPSBfQUxMT1dfV0lUTkVTUyAmJiB0aGlzLmhhc1dpdG5lc3NlcygpO1xuICAgIHJldHVybiAoXG4gICAgICAoaGFzV2l0bmVzc2VzID8gMTAgOiA4KSArXG4gICAgICBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgodGhpcy5pbnMubGVuZ3RoKSArXG4gICAgICBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RpbmdMZW5ndGgodGhpcy5vdXRzLmxlbmd0aCkgK1xuICAgICAgdGhpcy5pbnMucmVkdWNlKChzdW0sIGlucHV0KSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyA0MCArIHZhclNsaWNlU2l6ZShpbnB1dC5zY3JpcHQpO1xuICAgICAgfSwgMCkgK1xuICAgICAgdGhpcy5vdXRzLnJlZHVjZSgoc3VtLCBvdXRwdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCk7XG4gICAgICB9LCAwKSArXG4gICAgICAoaGFzV2l0bmVzc2VzXG4gICAgICAgID8gdGhpcy5pbnMucmVkdWNlKChzdW0sIGlucHV0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VtICsgdmVjdG9yU2l6ZShpbnB1dC53aXRuZXNzKTtcbiAgICAgICAgICB9LCAwKVxuICAgICAgICA6IDApXG4gICAgKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBuZXdUeCA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIG5ld1R4LnZlcnNpb24gPSB0aGlzLnZlcnNpb247XG4gICAgbmV3VHgubG9ja3RpbWUgPSB0aGlzLmxvY2t0aW1lO1xuICAgIG5ld1R4LmlucyA9IHRoaXMuaW5zLm1hcCh0eEluID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc2g6IHR4SW4uaGFzaCxcbiAgICAgICAgaW5kZXg6IHR4SW4uaW5kZXgsXG4gICAgICAgIHNjcmlwdDogdHhJbi5zY3JpcHQsXG4gICAgICAgIHNlcXVlbmNlOiB0eEluLnNlcXVlbmNlLFxuICAgICAgICB3aXRuZXNzOiB0eEluLndpdG5lc3MsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIG5ld1R4Lm91dHMgPSB0aGlzLm91dHMubWFwKHR4T3V0ID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmlwdDogdHhPdXQuc2NyaXB0LFxuICAgICAgICB2YWx1ZTogdHhPdXQudmFsdWUsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdUeDtcbiAgfVxuICAvKipcbiAgICogSGFzaCB0cmFuc2FjdGlvbiBmb3Igc2lnbmluZyBhIHNwZWNpZmljIGlucHV0LlxuICAgKlxuICAgKiBCaXRjb2luIHVzZXMgYSBkaWZmZXJlbnQgaGFzaCBmb3IgZWFjaCBzaWduZWQgdHJhbnNhY3Rpb24gaW5wdXQuXG4gICAqIFRoaXMgbWV0aG9kIGNvcGllcyB0aGUgdHJhbnNhY3Rpb24sIG1ha2VzIHRoZSBuZWNlc3NhcnkgY2hhbmdlcyBiYXNlZCBvbiB0aGVcbiAgICogaGFzaFR5cGUsIGFuZCB0aGVuIGhhc2hlcyB0aGUgcmVzdWx0LlxuICAgKiBUaGlzIGhhc2ggY2FuIHRoZW4gYmUgdXNlZCB0byBzaWduIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbiBpbnB1dC5cbiAgICovXG4gIGhhc2hGb3JTaWduYXR1cmUoaW5JbmRleCwgcHJldk91dFNjcmlwdCwgaGFzaFR5cGUpIHtcbiAgICB0eXBlZm9yY2UoXG4gICAgICB0eXBlcy50dXBsZSh0eXBlcy5VSW50MzIsIHR5cGVzLkJ1ZmZlciwgLyogdHlwZXMuVUludDggKi8gdHlwZXMuTnVtYmVyKSxcbiAgICAgIGFyZ3VtZW50cyxcbiAgICApO1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpdGNvaW4vYmxvYi9tYXN0ZXIvc3JjL3Rlc3Qvc2lnaGFzaF90ZXN0cy5jcHAjTDI5XG4gICAgaWYgKGluSW5kZXggPj0gdGhpcy5pbnMubGVuZ3RoKSByZXR1cm4gT05FO1xuICAgIC8vIGlnbm9yZSBPUF9DT0RFU0VQQVJBVE9SXG4gICAgY29uc3Qgb3VyU2NyaXB0ID0gYnNjcmlwdC5jb21waWxlKFxuICAgICAgYnNjcmlwdC5kZWNvbXBpbGUocHJldk91dFNjcmlwdCkuZmlsdGVyKHggPT4ge1xuICAgICAgICByZXR1cm4geCAhPT0gc2NyaXB0XzEuT1BTLk9QX0NPREVTRVBBUkFUT1I7XG4gICAgICB9KSxcbiAgICApO1xuICAgIGNvbnN0IHR4VG1wID0gdGhpcy5jbG9uZSgpO1xuICAgIC8vIFNJR0hBU0hfTk9ORTogaWdub3JlIGFsbCBvdXRwdXRzPyAod2lsZGNhcmQgcGF5ZWUpXG4gICAgaWYgKChoYXNoVHlwZSAmIDB4MWYpID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX05PTkUpIHtcbiAgICAgIHR4VG1wLm91dHMgPSBbXTtcbiAgICAgIC8vIGlnbm9yZSBzZXF1ZW5jZSBudW1iZXJzIChleGNlcHQgYXQgaW5JbmRleClcbiAgICAgIHR4VG1wLmlucy5mb3JFYWNoKChpbnB1dCwgaSkgPT4ge1xuICAgICAgICBpZiAoaSA9PT0gaW5JbmRleCkgcmV0dXJuO1xuICAgICAgICBpbnB1dC5zZXF1ZW5jZSA9IDA7XG4gICAgICB9KTtcbiAgICAgIC8vIFNJR0hBU0hfU0lOR0xFOiBpZ25vcmUgYWxsIG91dHB1dHMsIGV4Y2VwdCBhdCB0aGUgc2FtZSBpbmRleD9cbiAgICB9IGVsc2UgaWYgKChoYXNoVHlwZSAmIDB4MWYpID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYml0Y29pbi9ibG9iL21hc3Rlci9zcmMvdGVzdC9zaWdoYXNoX3Rlc3RzLmNwcCNMNjBcbiAgICAgIGlmIChpbkluZGV4ID49IHRoaXMub3V0cy5sZW5ndGgpIHJldHVybiBPTkU7XG4gICAgICAvLyB0cnVuY2F0ZSBvdXRwdXRzIGFmdGVyXG4gICAgICB0eFRtcC5vdXRzLmxlbmd0aCA9IGluSW5kZXggKyAxO1xuICAgICAgLy8gXCJibGFua1wiIG91dHB1dHMgYmVmb3JlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluSW5kZXg7IGkrKykge1xuICAgICAgICB0eFRtcC5vdXRzW2ldID0gQkxBTktfT1VUUFVUO1xuICAgICAgfVxuICAgICAgLy8gaWdub3JlIHNlcXVlbmNlIG51bWJlcnMgKGV4Y2VwdCBhdCBpbkluZGV4KVxuICAgICAgdHhUbXAuaW5zLmZvckVhY2goKGlucHV0LCB5KSA9PiB7XG4gICAgICAgIGlmICh5ID09PSBpbkluZGV4KSByZXR1cm47XG4gICAgICAgIGlucHV0LnNlcXVlbmNlID0gMDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTSUdIQVNIX0FOWU9ORUNBTlBBWTogaWdub3JlIGlucHV0cyBlbnRpcmVseT9cbiAgICBpZiAoaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSkge1xuICAgICAgdHhUbXAuaW5zID0gW3R4VG1wLmluc1tpbkluZGV4XV07XG4gICAgICB0eFRtcC5pbnNbMF0uc2NyaXB0ID0gb3VyU2NyaXB0O1xuICAgICAgLy8gU0lHSEFTSF9BTEw6IG9ubHkgaWdub3JlIGlucHV0IHNjcmlwdHNcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXCJibGFua1wiIG90aGVycyBpbnB1dCBzY3JpcHRzXG4gICAgICB0eFRtcC5pbnMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgIGlucHV0LnNjcmlwdCA9IEVNUFRZX0JVRkZFUjtcbiAgICAgIH0pO1xuICAgICAgdHhUbXAuaW5zW2luSW5kZXhdLnNjcmlwdCA9IG91clNjcmlwdDtcbiAgICB9XG4gICAgLy8gc2VyaWFsaXplIGFuZCBoYXNoXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHR4VG1wLmJ5dGVMZW5ndGgoZmFsc2UpICsgNCk7XG4gICAgYnVmZmVyLndyaXRlSW50MzJMRShoYXNoVHlwZSwgYnVmZmVyLmxlbmd0aCAtIDQpO1xuICAgIHR4VG1wLl9fdG9CdWZmZXIoYnVmZmVyLCAwLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJjcnlwdG8uaGFzaDI1NihidWZmZXIpO1xuICB9XG4gIGhhc2hGb3JXaXRuZXNzVjEoaW5JbmRleCwgcHJldk91dFNjcmlwdHMsIHZhbHVlcywgaGFzaFR5cGUsIGxlYWZIYXNoLCBhbm5leCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDEubWVkaWF3aWtpI2NvbW1vbi1zaWduYXR1cmUtbWVzc2FnZVxuICAgIHR5cGVmb3JjZShcbiAgICAgIHR5cGVzLnR1cGxlKFxuICAgICAgICB0eXBlcy5VSW50MzIsXG4gICAgICAgIHR5cGVmb3JjZS5hcnJheU9mKHR5cGVzLkJ1ZmZlciksXG4gICAgICAgIHR5cGVmb3JjZS5hcnJheU9mKHR5cGVzLlNhdG9zaGkpLFxuICAgICAgICB0eXBlcy5VSW50MzIsXG4gICAgICApLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gICAgaWYgKFxuICAgICAgdmFsdWVzLmxlbmd0aCAhPT0gdGhpcy5pbnMubGVuZ3RoIHx8XG4gICAgICBwcmV2T3V0U2NyaXB0cy5sZW5ndGggIT09IHRoaXMuaW5zLmxlbmd0aFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHN1cHBseSBwcmV2b3V0IHNjcmlwdCBhbmQgdmFsdWUgZm9yIGFsbCBpbnB1dHMnKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0cHV0VHlwZSA9XG4gICAgICBoYXNoVHlwZSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUXG4gICAgICAgID8gVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExcbiAgICAgICAgOiBoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfT1VUUFVUX01BU0s7XG4gICAgY29uc3QgaW5wdXRUeXBlID0gaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX0lOUFVUX01BU0s7XG4gICAgY29uc3QgaXNBbnlvbmVDYW5QYXkgPSBpbnB1dFR5cGUgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZO1xuICAgIGNvbnN0IGlzTm9uZSA9IG91dHB1dFR5cGUgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORTtcbiAgICBjb25zdCBpc1NpbmdsZSA9IG91dHB1dFR5cGUgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFO1xuICAgIGxldCBoYXNoUHJldm91dHMgPSBFTVBUWV9CVUZGRVI7XG4gICAgbGV0IGhhc2hBbW91bnRzID0gRU1QVFlfQlVGRkVSO1xuICAgIGxldCBoYXNoU2NyaXB0UHViS2V5cyA9IEVNUFRZX0JVRkZFUjtcbiAgICBsZXQgaGFzaFNlcXVlbmNlcyA9IEVNUFRZX0JVRkZFUjtcbiAgICBsZXQgaGFzaE91dHB1dHMgPSBFTVBUWV9CVUZGRVI7XG4gICAgaWYgKCFpc0FueW9uZUNhblBheSkge1xuICAgICAgbGV0IGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eShcbiAgICAgICAgMzYgKiB0aGlzLmlucy5sZW5ndGgsXG4gICAgICApO1xuICAgICAgdGhpcy5pbnMuZm9yRWFjaCh0eEluID0+IHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UodHhJbi5oYXNoKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uaW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBoYXNoUHJldm91dHMgPSBiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpO1xuICAgICAgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KFxuICAgICAgICA4ICogdGhpcy5pbnMubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NCh2YWx1ZSkpO1xuICAgICAgaGFzaEFtb3VudHMgPSBiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpO1xuICAgICAgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KFxuICAgICAgICBwcmV2T3V0U2NyaXB0cy5tYXAodmFyU2xpY2VTaXplKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSxcbiAgICAgICk7XG4gICAgICBwcmV2T3V0U2NyaXB0cy5mb3JFYWNoKHByZXZPdXRTY3JpcHQgPT5cbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UocHJldk91dFNjcmlwdCksXG4gICAgICApO1xuICAgICAgaGFzaFNjcmlwdFB1YktleXMgPSBiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpO1xuICAgICAgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KFxuICAgICAgICA0ICogdGhpcy5pbnMubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodHhJbi5zZXF1ZW5jZSkpO1xuICAgICAgaGFzaFNlcXVlbmNlcyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgfVxuICAgIGlmICghKGlzTm9uZSB8fCBpc1NpbmdsZSkpIHtcbiAgICAgIGNvbnN0IHR4T3V0c1NpemUgPSB0aGlzLm91dHNcbiAgICAgICAgLm1hcChvdXRwdXQgPT4gOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KSlcbiAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpO1xuICAgICAgY29uc3QgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KHR4T3V0c1NpemUpO1xuICAgICAgdGhpcy5vdXRzLmZvckVhY2gob3V0ID0+IHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KG91dC52YWx1ZSk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKG91dC5zY3JpcHQpO1xuICAgICAgfSk7XG4gICAgICBoYXNoT3V0cHV0cyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgfSBlbHNlIGlmIChpc1NpbmdsZSAmJiBpbkluZGV4IDwgdGhpcy5vdXRzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5vdXRzW2luSW5kZXhdO1xuICAgICAgY29uc3QgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KFxuICAgICAgICA4ICsgdmFyU2xpY2VTaXplKG91dHB1dC5zY3JpcHQpLFxuICAgICAgKTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NChvdXRwdXQudmFsdWUpO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2Uob3V0cHV0LnNjcmlwdCk7XG4gICAgICBoYXNoT3V0cHV0cyA9IGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHNwZW5kVHlwZSA9IChsZWFmSGFzaCA/IDIgOiAwKSArIChhbm5leCA/IDEgOiAwKTtcbiAgICAvLyBMZW5ndGggY2FsY3VsYXRpb24gZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQxLm1lZGlhd2lraSNjaXRlX25vdGUtMTRcbiAgICAvLyBXaXRoIGV4dGVuc2lvbiBmcm9tOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDIubWVkaWF3aWtpI3NpZ25hdHVyZS12YWxpZGF0aW9uXG4gICAgY29uc3Qgc2lnTXNnU2l6ZSA9XG4gICAgICAxNzQgLVxuICAgICAgKGlzQW55b25lQ2FuUGF5ID8gNDkgOiAwKSAtXG4gICAgICAoaXNOb25lID8gMzIgOiAwKSArXG4gICAgICAoYW5uZXggPyAzMiA6IDApICtcbiAgICAgIChsZWFmSGFzaCA/IDM3IDogMCk7XG4gICAgY29uc3Qgc2lnTXNnV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KHNpZ01zZ1NpemUpO1xuICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQ4KGhhc2hUeXBlKTtcbiAgICAvLyBUcmFuc2FjdGlvblxuICAgIHNpZ01zZ1dyaXRlci53cml0ZUludDMyKHRoaXMudmVyc2lvbik7XG4gICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDMyKHRoaXMubG9ja3RpbWUpO1xuICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hQcmV2b3V0cyk7XG4gICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoaGFzaEFtb3VudHMpO1xuICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hTY3JpcHRQdWJLZXlzKTtcbiAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShoYXNoU2VxdWVuY2VzKTtcbiAgICBpZiAoIShpc05vbmUgfHwgaXNTaW5nbGUpKSB7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShoYXNoT3V0cHV0cyk7XG4gICAgfVxuICAgIC8vIElucHV0XG4gICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDgoc3BlbmRUeXBlKTtcbiAgICBpZiAoaXNBbnlvbmVDYW5QYXkpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnNbaW5JbmRleF07XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShpbnB1dC5oYXNoKTtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQzMihpbnB1dC5pbmRleCk7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50NjQodmFsdWVzW2luSW5kZXhdKTtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVZhclNsaWNlKHByZXZPdXRTY3JpcHRzW2luSW5kZXhdKTtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQzMihpbnB1dC5zZXF1ZW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQzMihpbkluZGV4KTtcbiAgICB9XG4gICAgaWYgKGFubmV4KSB7XG4gICAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoXG4gICAgICAgIHZhclNsaWNlU2l6ZShhbm5leCksXG4gICAgICApO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UoYW5uZXgpO1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKSk7XG4gICAgfVxuICAgIC8vIE91dHB1dFxuICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoaGFzaE91dHB1dHMpO1xuICAgIH1cbiAgICAvLyBCSVAzNDIgZXh0ZW5zaW9uXG4gICAgaWYgKGxlYWZIYXNoKSB7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShsZWFmSGFzaCk7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50OCgwKTtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQzMigweGZmZmZmZmZmKTtcbiAgICB9XG4gICAgLy8gRXh0cmEgemVybyBieXRlIGJlY2F1c2U6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MS5tZWRpYXdpa2kjY2l0ZV9ub3RlLTE5XG4gICAgcmV0dXJuIGJjcnlwdG8udGFnZ2VkSGFzaChcbiAgICAgICdUYXBTaWdoYXNoJyxcbiAgICAgIEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFsweDAwXSksIHNpZ01zZ1dyaXRlci5lbmQoKV0pLFxuICAgICk7XG4gIH1cbiAgaGFzaEZvcldpdG5lc3NWMChpbkluZGV4LCBwcmV2T3V0U2NyaXB0LCB2YWx1ZSwgaGFzaFR5cGUpIHtcbiAgICB0eXBlZm9yY2UoXG4gICAgICB0eXBlcy50dXBsZSh0eXBlcy5VSW50MzIsIHR5cGVzLkJ1ZmZlciwgdHlwZXMuU2F0b3NoaSwgdHlwZXMuVUludDMyKSxcbiAgICAgIGFyZ3VtZW50cyxcbiAgICApO1xuICAgIGxldCB0YnVmZmVyID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGxldCBidWZmZXJXcml0ZXI7XG4gICAgbGV0IGhhc2hPdXRwdXRzID0gWkVSTztcbiAgICBsZXQgaGFzaFByZXZvdXRzID0gWkVSTztcbiAgICBsZXQgaGFzaFNlcXVlbmNlID0gWkVSTztcbiAgICBpZiAoIShoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSkge1xuICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzNiAqIHRoaXMuaW5zLmxlbmd0aCk7XG4gICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4ge1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0eEluLmhhc2gpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodHhJbi5pbmRleCk7XG4gICAgICB9KTtcbiAgICAgIGhhc2hQcmV2b3V0cyA9IGJjcnlwdG8uaGFzaDI1Nih0YnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIShoYXNoVHlwZSAmIFRyYW5zYWN0aW9uLlNJR0hBU0hfQU5ZT05FQ0FOUEFZKSAmJlxuICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFICYmXG4gICAgICAoaGFzaFR5cGUgJiAweDFmKSAhPT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FXG4gICAgKSB7XG4gICAgICB0YnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQgKiB0aGlzLmlucy5sZW5ndGgpO1xuICAgICAgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKHRidWZmZXIsIDApO1xuICAgICAgdGhpcy5pbnMuZm9yRWFjaCh0eEluID0+IHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uc2VxdWVuY2UpO1xuICAgICAgfSk7XG4gICAgICBoYXNoU2VxdWVuY2UgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSAmJlxuICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORVxuICAgICkge1xuICAgICAgY29uc3QgdHhPdXRzU2l6ZSA9IHRoaXMub3V0cy5yZWR1Y2UoKHN1bSwgb3V0cHV0KSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyA4ICsgdmFyU2xpY2VTaXplKG91dHB1dC5zY3JpcHQpO1xuICAgICAgfSwgMCk7XG4gICAgICB0YnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHR4T3V0c1NpemUpO1xuICAgICAgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKHRidWZmZXIsIDApO1xuICAgICAgdGhpcy5vdXRzLmZvckVhY2gob3V0ID0+IHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KG91dC52YWx1ZSk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKG91dC5zY3JpcHQpO1xuICAgICAgfSk7XG4gICAgICBoYXNoT3V0cHV0cyA9IGJjcnlwdG8uaGFzaDI1Nih0YnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKGhhc2hUeXBlICYgMHgxZikgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFICYmXG4gICAgICBpbkluZGV4IDwgdGhpcy5vdXRzLmxlbmd0aFxuICAgICkge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5vdXRzW2luSW5kZXhdO1xuICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg4ICsgdmFyU2xpY2VTaXplKG91dHB1dC5zY3JpcHQpKTtcbiAgICAgIGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcih0YnVmZmVyLCAwKTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NChvdXRwdXQudmFsdWUpO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2Uob3V0cHV0LnNjcmlwdCk7XG4gICAgICBoYXNoT3V0cHV0cyA9IGJjcnlwdG8uaGFzaDI1Nih0YnVmZmVyKTtcbiAgICB9XG4gICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxNTYgKyB2YXJTbGljZVNpemUocHJldk91dFNjcmlwdCkpO1xuICAgIGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcih0YnVmZmVyLCAwKTtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5zW2luSW5kZXhdO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZUludDMyKHRoaXMudmVyc2lvbik7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UoaGFzaFByZXZvdXRzKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZShoYXNoU2VxdWVuY2UpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKGlucHV0Lmhhc2gpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMihpbnB1dC5pbmRleCk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UocHJldk91dFNjcmlwdCk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDY0KHZhbHVlKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIoaW5wdXQuc2VxdWVuY2UpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKGhhc2hPdXRwdXRzKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodGhpcy5sb2NrdGltZSk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKGhhc2hUeXBlKTtcbiAgICByZXR1cm4gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICB9XG4gIGdldEhhc2goZm9yV2l0bmVzcykge1xuICAgIC8vIHd0eGlkIGZvciBjb2luYmFzZSBpcyBhbHdheXMgMzIgYnl0ZXMgb2YgMHgwMFxuICAgIGlmIChmb3JXaXRuZXNzICYmIHRoaXMuaXNDb2luYmFzZSgpKSByZXR1cm4gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgICByZXR1cm4gYmNyeXB0by5oYXNoMjU2KHRoaXMuX190b0J1ZmZlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgZm9yV2l0bmVzcykpO1xuICB9XG4gIGdldElkKCkge1xuICAgIC8vIHRyYW5zYWN0aW9uIGhhc2gncyBhcmUgZGlzcGxheWVkIGluIHJldmVyc2Ugb3JkZXJcbiAgICByZXR1cm4gKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikodGhpcy5nZXRIYXNoKGZhbHNlKSkudG9TdHJpbmcoXG4gICAgICAnaGV4JyxcbiAgICApO1xuICB9XG4gIHRvQnVmZmVyKGJ1ZmZlciwgaW5pdGlhbE9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9CdWZmZXIoYnVmZmVyLCBpbml0aWFsT2Zmc2V0LCB0cnVlKTtcbiAgfVxuICB0b0hleCgpIHtcbiAgICByZXR1cm4gdGhpcy50b0J1ZmZlcih1bmRlZmluZWQsIHVuZGVmaW5lZCkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG4gIHNldElucHV0U2NyaXB0KGluZGV4LCBzY3JpcHRTaWcpIHtcbiAgICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuTnVtYmVyLCB0eXBlcy5CdWZmZXIpLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5zW2luZGV4XS5zY3JpcHQgPSBzY3JpcHRTaWc7XG4gIH1cbiAgc2V0V2l0bmVzcyhpbmRleCwgd2l0bmVzcykge1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5OdW1iZXIsIFt0eXBlcy5CdWZmZXJdKSwgYXJndW1lbnRzKTtcbiAgICB0aGlzLmluc1tpbmRleF0ud2l0bmVzcyA9IHdpdG5lc3M7XG4gIH1cbiAgX190b0J1ZmZlcihidWZmZXIsIGluaXRpYWxPZmZzZXQsIF9BTExPV19XSVRORVNTID0gZmFsc2UpIHtcbiAgICBpZiAoIWJ1ZmZlcikgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuYnl0ZUxlbmd0aChfQUxMT1dfV0lUTkVTUykpO1xuICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcihcbiAgICAgIGJ1ZmZlcixcbiAgICAgIGluaXRpYWxPZmZzZXQgfHwgMCxcbiAgICApO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZUludDMyKHRoaXMudmVyc2lvbik7XG4gICAgY29uc3QgaGFzV2l0bmVzc2VzID0gX0FMTE9XX1dJVE5FU1MgJiYgdGhpcy5oYXNXaXRuZXNzZXMoKTtcbiAgICBpZiAoaGFzV2l0bmVzc2VzKSB7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50OChUcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9NQVJLRVIpO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDgoVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fRkxBRyk7XG4gICAgfVxuICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhckludCh0aGlzLmlucy5sZW5ndGgpO1xuICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0eEluLmhhc2gpO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uaW5kZXgpO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UodHhJbi5zY3JpcHQpO1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uc2VxdWVuY2UpO1xuICAgIH0pO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhckludCh0aGlzLm91dHMubGVuZ3RoKTtcbiAgICB0aGlzLm91dHMuZm9yRWFjaCh0eE91dCA9PiB7XG4gICAgICBpZiAoaXNPdXRwdXQodHhPdXQpKSB7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NCh0eE91dC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZSh0eE91dC52YWx1ZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZSh0eE91dC5zY3JpcHQpO1xuICAgIH0pO1xuICAgIGlmIChoYXNXaXRuZXNzZXMpIHtcbiAgICAgIHRoaXMuaW5zLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVWZWN0b3IoaW5wdXQud2l0bmVzcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHRoaXMubG9ja3RpbWUpO1xuICAgIC8vIGF2b2lkIHNsaWNpbmcgdW5sZXNzIG5lY2Vzc2FyeVxuICAgIGlmIChpbml0aWFsT2Zmc2V0ICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKGluaXRpYWxPZmZzZXQsIGJ1ZmZlcldyaXRlci5vZmZzZXQpO1xuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbn1cbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcblRyYW5zYWN0aW9uLkRFRkFVTFRfU0VRVUVOQ0UgPSAweGZmZmZmZmZmO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUID0gMHgwMDtcblRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMID0gMHgwMTtcblRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORSA9IDB4MDI7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSA9IDB4MDM7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSA9IDB4ODA7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX09VVFBVVF9NQVNLID0gMHgwMztcblRyYW5zYWN0aW9uLlNJR0hBU0hfSU5QVVRfTUFTSyA9IDB4ODA7XG5UcmFuc2FjdGlvbi5BRFZBTkNFRF9UUkFOU0FDVElPTl9NQVJLRVIgPSAweDAwO1xuVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fRkxBRyA9IDB4MDE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.oneOf =\n  exports.Null =\n  exports.BufferN =\n  exports.Function =\n  exports.UInt32 =\n  exports.UInt8 =\n  exports.tuple =\n  exports.maybe =\n  exports.Hex =\n  exports.Buffer =\n  exports.String =\n  exports.Boolean =\n  exports.Array =\n  exports.Number =\n  exports.Hash256bit =\n  exports.Hash160bit =\n  exports.Buffer256bit =\n  exports.isTaptree =\n  exports.isTapleaf =\n  exports.TAPLEAF_VERSION_MASK =\n  exports.Satoshi =\n  exports.isPoint =\n  exports.stacksEqual =\n  exports.typeforce =\n    void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"buffer\");\nexports.typeforce = __webpack_require__(/*! typeforce */ \"(ssr)/./node_modules/.pnpm/typeforce@1.18.0/node_modules/typeforce/index.js\");\nconst ZERO32 = buffer_1.Buffer.alloc(32, 0);\nconst EC_P = buffer_1.Buffer.from(\n  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',\n  'hex',\n);\n/**\n * Checks if two arrays of Buffers are equal.\n * @param a - The first array of Buffers.\n * @param b - The second array of Buffers.\n * @returns True if the arrays are equal, false otherwise.\n */\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nexports.stacksEqual = stacksEqual;\n/**\n * Checks if the given value is a valid elliptic curve point.\n * @param p - The value to check.\n * @returns True if the value is a valid elliptic curve point, false otherwise.\n */\nfunction isPoint(p) {\n  if (!buffer_1.Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    return true;\n  }\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nexports.isPoint = isPoint;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\nexports.TAPLEAF_VERSION_MASK = 0xfe;\nfunction isTapleaf(o) {\n  if (!o || !('output' in o)) return false;\n  if (!buffer_1.Buffer.isBuffer(o.output)) return false;\n  if (o.version !== undefined)\n    return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;\n  return true;\n}\nexports.isTapleaf = isTapleaf;\nfunction isTaptree(scriptTree) {\n  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);\n  if (scriptTree.length !== 2) return false;\n  return scriptTree.every(t => isTaptree(t));\n}\nexports.isTaptree = isTaptree;\nexports.Buffer256bit = exports.typeforce.BufferN(32);\nexports.Hash160bit = exports.typeforce.BufferN(20);\nexports.Hash256bit = exports.typeforce.BufferN(32);\nexports.Number = exports.typeforce.Number;\nexports.Array = exports.typeforce.Array;\nexports.Boolean = exports.typeforce.Boolean;\nexports.String = exports.typeforce.String;\nexports.Buffer = exports.typeforce.Buffer;\nexports.Hex = exports.typeforce.Hex;\nexports.maybe = exports.typeforce.maybe;\nexports.tuple = exports.typeforce.tuple;\nexports.UInt8 = exports.typeforce.UInt8;\nexports.UInt32 = exports.typeforce.UInt32;\nexports.Function = exports.typeforce.Function;\nexports.BufferN = exports.typeforce.BufferN;\nexports.Null = exports.typeforce.Null;\nexports.oneOf = exports.typeforce.oneOf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYml0Y29pbmpzLWxpYkA2LjEuNy9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLEVBQUUsWUFBWTtBQUNkLEVBQUUsZUFBZTtBQUNqQixFQUFFLGdCQUFnQjtBQUNsQixFQUFFLGNBQWM7QUFDaEIsRUFBRSxhQUFhO0FBQ2YsRUFBRSxhQUFhO0FBQ2YsRUFBRSxhQUFhO0FBQ2YsRUFBRSxXQUFXO0FBQ2IsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsY0FBYztBQUNoQixFQUFFLGVBQWU7QUFDakIsRUFBRSxhQUFhO0FBQ2YsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsb0JBQW9CO0FBQ3RCLEVBQUUsaUJBQWlCO0FBQ25CLEVBQUUsaUJBQWlCO0FBQ25CLEVBQUUsNEJBQTRCO0FBQzlCLEVBQUUsZUFBZTtBQUNqQixFQUFFLGVBQWU7QUFDakIsRUFBRSxtQkFBbUI7QUFDckIsRUFBRSxpQkFBaUI7QUFDbkI7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyx1SUFBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsYUFBYTtBQUNiLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLFdBQVc7QUFDWCxhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixZQUFZO0FBQ1osYUFBYSIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL2JpdGNvaW5qcy1saWJANi4xLjcvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9uZU9mID1cbiAgZXhwb3J0cy5OdWxsID1cbiAgZXhwb3J0cy5CdWZmZXJOID1cbiAgZXhwb3J0cy5GdW5jdGlvbiA9XG4gIGV4cG9ydHMuVUludDMyID1cbiAgZXhwb3J0cy5VSW50OCA9XG4gIGV4cG9ydHMudHVwbGUgPVxuICBleHBvcnRzLm1heWJlID1cbiAgZXhwb3J0cy5IZXggPVxuICBleHBvcnRzLkJ1ZmZlciA9XG4gIGV4cG9ydHMuU3RyaW5nID1cbiAgZXhwb3J0cy5Cb29sZWFuID1cbiAgZXhwb3J0cy5BcnJheSA9XG4gIGV4cG9ydHMuTnVtYmVyID1cbiAgZXhwb3J0cy5IYXNoMjU2Yml0ID1cbiAgZXhwb3J0cy5IYXNoMTYwYml0ID1cbiAgZXhwb3J0cy5CdWZmZXIyNTZiaXQgPVxuICBleHBvcnRzLmlzVGFwdHJlZSA9XG4gIGV4cG9ydHMuaXNUYXBsZWFmID1cbiAgZXhwb3J0cy5UQVBMRUFGX1ZFUlNJT05fTUFTSyA9XG4gIGV4cG9ydHMuU2F0b3NoaSA9XG4gIGV4cG9ydHMuaXNQb2ludCA9XG4gIGV4cG9ydHMuc3RhY2tzRXF1YWwgPVxuICBleHBvcnRzLnR5cGVmb3JjZSA9XG4gICAgdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKCdidWZmZXInKTtcbmV4cG9ydHMudHlwZWZvcmNlID0gcmVxdWlyZSgndHlwZWZvcmNlJyk7XG5jb25zdCBaRVJPMzIgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMzIsIDApO1xuY29uc3QgRUNfUCA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFxuICAnZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicsXG4gICdoZXgnLFxuKTtcbi8qKlxuICogQ2hlY2tzIGlmIHR3byBhcnJheXMgb2YgQnVmZmVycyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0gYSAtIFRoZSBmaXJzdCBhcnJheSBvZiBCdWZmZXJzLlxuICogQHBhcmFtIGIgLSBUaGUgc2Vjb25kIGFycmF5IG9mIEJ1ZmZlcnMuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBhcnJheXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrc0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYS5ldmVyeSgoeCwgaSkgPT4ge1xuICAgIHJldHVybiB4LmVxdWFscyhiW2ldKTtcbiAgfSk7XG59XG5leHBvcnRzLnN0YWNrc0VxdWFsID0gc3RhY2tzRXF1YWw7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEBwYXJhbSBwIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSB2YWxpZCBlbGxpcHRpYyBjdXJ2ZSBwb2ludCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1BvaW50KHApIHtcbiAgaWYgKCFidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIocCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKHAubGVuZ3RoIDwgMzMpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdCA9IHBbMF07XG4gIGNvbnN0IHggPSBwLnNsaWNlKDEsIDMzKTtcbiAgaWYgKHguY29tcGFyZShaRVJPMzIpID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh4LmNvbXBhcmUoRUNfUCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoKHQgPT09IDB4MDIgfHwgdCA9PT0gMHgwMykgJiYgcC5sZW5ndGggPT09IDMzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgeSA9IHAuc2xpY2UoMzMpO1xuICBpZiAoeS5jb21wYXJlKFpFUk8zMikgPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKHkuY29tcGFyZShFQ19QKSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0ID09PSAweDA0ICYmIHAubGVuZ3RoID09PSA2NSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNQb2ludCA9IGlzUG9pbnQ7XG5jb25zdCBTQVRPU0hJX01BWCA9IDIxICogMWUxNDtcbmZ1bmN0aW9uIFNhdG9zaGkodmFsdWUpIHtcbiAgcmV0dXJuIGV4cG9ydHMudHlwZWZvcmNlLlVJbnQ1Myh2YWx1ZSkgJiYgdmFsdWUgPD0gU0FUT1NISV9NQVg7XG59XG5leHBvcnRzLlNhdG9zaGkgPSBTYXRvc2hpO1xuZXhwb3J0cy5UQVBMRUFGX1ZFUlNJT05fTUFTSyA9IDB4ZmU7XG5mdW5jdGlvbiBpc1RhcGxlYWYobykge1xuICBpZiAoIW8gfHwgISgnb3V0cHV0JyBpbiBvKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWJ1ZmZlcl8xLkJ1ZmZlci5pc0J1ZmZlcihvLm91dHB1dCkpIHJldHVybiBmYWxzZTtcbiAgaWYgKG8udmVyc2lvbiAhPT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAoby52ZXJzaW9uICYgZXhwb3J0cy5UQVBMRUFGX1ZFUlNJT05fTUFTSykgPT09IG8udmVyc2lvbjtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVGFwbGVhZiA9IGlzVGFwbGVhZjtcbmZ1bmN0aW9uIGlzVGFwdHJlZShzY3JpcHRUcmVlKSB7XG4gIGlmICghKDAsIGV4cG9ydHMuQXJyYXkpKHNjcmlwdFRyZWUpKSByZXR1cm4gaXNUYXBsZWFmKHNjcmlwdFRyZWUpO1xuICBpZiAoc2NyaXB0VHJlZS5sZW5ndGggIT09IDIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHNjcmlwdFRyZWUuZXZlcnkodCA9PiBpc1RhcHRyZWUodCkpO1xufVxuZXhwb3J0cy5pc1RhcHRyZWUgPSBpc1RhcHRyZWU7XG5leHBvcnRzLkJ1ZmZlcjI1NmJpdCA9IGV4cG9ydHMudHlwZWZvcmNlLkJ1ZmZlck4oMzIpO1xuZXhwb3J0cy5IYXNoMTYwYml0ID0gZXhwb3J0cy50eXBlZm9yY2UuQnVmZmVyTigyMCk7XG5leHBvcnRzLkhhc2gyNTZiaXQgPSBleHBvcnRzLnR5cGVmb3JjZS5CdWZmZXJOKDMyKTtcbmV4cG9ydHMuTnVtYmVyID0gZXhwb3J0cy50eXBlZm9yY2UuTnVtYmVyO1xuZXhwb3J0cy5BcnJheSA9IGV4cG9ydHMudHlwZWZvcmNlLkFycmF5O1xuZXhwb3J0cy5Cb29sZWFuID0gZXhwb3J0cy50eXBlZm9yY2UuQm9vbGVhbjtcbmV4cG9ydHMuU3RyaW5nID0gZXhwb3J0cy50eXBlZm9yY2UuU3RyaW5nO1xuZXhwb3J0cy5CdWZmZXIgPSBleHBvcnRzLnR5cGVmb3JjZS5CdWZmZXI7XG5leHBvcnRzLkhleCA9IGV4cG9ydHMudHlwZWZvcmNlLkhleDtcbmV4cG9ydHMubWF5YmUgPSBleHBvcnRzLnR5cGVmb3JjZS5tYXliZTtcbmV4cG9ydHMudHVwbGUgPSBleHBvcnRzLnR5cGVmb3JjZS50dXBsZTtcbmV4cG9ydHMuVUludDggPSBleHBvcnRzLnR5cGVmb3JjZS5VSW50ODtcbmV4cG9ydHMuVUludDMyID0gZXhwb3J0cy50eXBlZm9yY2UuVUludDMyO1xuZXhwb3J0cy5GdW5jdGlvbiA9IGV4cG9ydHMudHlwZWZvcmNlLkZ1bmN0aW9uO1xuZXhwb3J0cy5CdWZmZXJOID0gZXhwb3J0cy50eXBlZm9yY2UuQnVmZmVyTjtcbmV4cG9ydHMuTnVsbCA9IGV4cG9ydHMudHlwZWZvcmNlLk51bGw7XG5leHBvcnRzLm9uZU9mID0gZXhwb3J0cy50eXBlZm9yY2Uub25lT2Y7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/types.js\n");

/***/ })

};
;