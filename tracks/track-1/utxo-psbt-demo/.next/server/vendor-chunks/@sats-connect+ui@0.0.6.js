"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sats-connect+ui@0.0.6";
exports.ids = ["vendor-chunks/@sats-connect+ui@0.0.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@sats-connect+ui@0.0.6/node_modules/@sats-connect/ui/dist/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sats-connect+ui@0.0.6/node_modules/@sats-connect/ui/dist/index.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanup: () => (/* binding */ zn),\n/* harmony export */   close: () => (/* binding */ Mn),\n/* harmony export */   elementId: () => (/* binding */ Ee),\n/* harmony export */   elementName: () => (/* binding */ ge),\n/* harmony export */   getWalletProviderSelectorElement: () => (/* binding */ He),\n/* harmony export */   hasInstallPrompt: () => (/* binding */ ke),\n/* harmony export */   isInstalled: () => (/* binding */ jn),\n/* harmony export */   loadSelector: () => (/* binding */ Nn),\n/* harmony export */   selectWalletProvider: () => (/* binding */ Rn),\n/* harmony export */   walletClose: () => (/* binding */ Fn),\n/* harmony export */   walletOpen: () => (/* binding */ In)\n/* harmony export */ });\nfunction st(e) {\n  return Object.keys(e).reduce((n, i) => {\n    const r = e[i];\n    return n[i] = Object.assign({}, r), ze(r.value) && !ut(r.value) && !Array.isArray(r.value) && (n[i].value = Object.assign({}, r.value)), Array.isArray(r.value) && (n[i].value = r.value.slice(0)), n;\n  }, {});\n}\nfunction ot(e) {\n  return e ? Object.keys(e).reduce((n, i) => {\n    const r = e[i];\n    return n[i] = ze(r) && \"value\" in r ? r : {\n      value: r\n    }, n[i].attribute || (n[i].attribute = ct(i)), n[i].parse = \"parse\" in n[i] ? n[i].parse : typeof n[i].value != \"string\", n;\n  }, {}) : {};\n}\nfunction lt(e) {\n  return Object.keys(e).reduce((n, i) => (n[i] = e[i].value, n), {});\n}\nfunction at(e, t) {\n  const n = st(t);\n  return Object.keys(t).forEach((r) => {\n    const s = n[r], l = e.getAttribute(s.attribute), o = e[r];\n    l && (s.value = s.parse ? Ne(l) : l), o != null && (s.value = Array.isArray(o) ? o.slice(0) : o), s.reflect && $e(e, s.attribute, s.value), Object.defineProperty(e, r, {\n      get() {\n        return s.value;\n      },\n      set(c) {\n        const f = s.value;\n        s.value = c, s.reflect && $e(this, s.attribute, s.value);\n        for (let a = 0, u = this.__propertyChangedCallbacks.length; a < u; a++)\n          this.__propertyChangedCallbacks[a](r, c, f);\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n  }), n;\n}\nfunction Ne(e) {\n  if (e)\n    try {\n      return JSON.parse(e);\n    } catch {\n      return e;\n    }\n}\nfunction $e(e, t, n) {\n  if (n == null || n === !1)\n    return e.removeAttribute(t);\n  let i = JSON.stringify(n);\n  e.__updating[t] = !0, i === \"true\" && (i = \"\"), e.setAttribute(t, i), Promise.resolve().then(() => delete e.__updating[t]);\n}\nfunction ct(e) {\n  return e.replace(/\\.?([A-Z]+)/g, (t, n) => \"-\" + n.toLowerCase()).replace(\"_\", \"-\").replace(/^-/, \"\");\n}\nfunction ze(e) {\n  return e != null && (typeof e == \"object\" || typeof e == \"function\");\n}\nfunction ut(e) {\n  return Object.prototype.toString.call(e) === \"[object Function]\";\n}\nfunction dt(e) {\n  return typeof e == \"function\" && e.toString().indexOf(\"class\") === 0;\n}\nlet ue;\nfunction ft(e, t) {\n  const n = Object.keys(t);\n  return class extends e {\n    static get observedAttributes() {\n      return n.map((r) => t[r].attribute);\n    }\n    constructor() {\n      super(), this.__initialized = !1, this.__released = !1, this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = {};\n    }\n    connectedCallback() {\n      if (this.__initialized)\n        return;\n      this.__releaseCallbacks = [], this.__propertyChangedCallbacks = [], this.__updating = {}, this.props = at(this, t);\n      const r = lt(this.props), s = this.Component, l = ue;\n      try {\n        ue = this, this.__initialized = !0, dt(s) ? new s(r, {\n          element: this\n        }) : s(r, {\n          element: this\n        });\n      } finally {\n        ue = l;\n      }\n    }\n    async disconnectedCallback() {\n      if (await Promise.resolve(), this.isConnected)\n        return;\n      this.__propertyChangedCallbacks.length = 0;\n      let r = null;\n      for (; r = this.__releaseCallbacks.pop(); )\n        r(this);\n      delete this.__initialized, this.__released = !0;\n    }\n    attributeChangedCallback(r, s, l) {\n      if (this.__initialized && !this.__updating[r] && (r = this.lookupProp(r), r in t)) {\n        if (l == null && !this[r])\n          return;\n        this[r] = t[r].parse ? Ne(l) : l;\n      }\n    }\n    lookupProp(r) {\n      if (t)\n        return n.find((s) => r === s || r === t[s].attribute);\n    }\n    get renderRoot() {\n      return this.shadowRoot || this.attachShadow({\n        mode: \"open\"\n      });\n    }\n    addReleaseCallback(r) {\n      this.__releaseCallbacks.push(r);\n    }\n    addPropertyChangedCallback(r) {\n      this.__propertyChangedCallbacks.push(r);\n    }\n  };\n}\nfunction ht(e, t = {}, n = {}) {\n  const {\n    BaseElement: i = HTMLElement,\n    extension: r\n  } = n;\n  return (s) => {\n    if (!e)\n      throw new Error(\"tag is required to register a Component\");\n    let l = customElements.get(e);\n    return l ? (l.prototype.Component = s, l) : (l = ft(i, ot(t)), l.prototype.Component = s, l.prototype.registeredTag = e, customElements.define(e, l, r), l);\n  };\n}\nconst pt = (e, t) => e === t, me = Symbol(\"solid-proxy\"), yt = Symbol(\"solid-track\"), J = {\n  equals: pt\n};\nlet Re = De;\nconst M = 1, Q = 2, Ie = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nvar w = null;\nlet de = null, gt = null, m = null, S = null, I = null, ne = 0;\nfunction Z(e, t) {\n  const n = m, i = w, r = e.length === 0, s = t === void 0 ? i : t, l = r ? Ie : {\n    owned: null,\n    cleanups: null,\n    context: s ? s.context : null,\n    owner: s\n  }, o = r ? e : () => e(() => T(() => ie(l)));\n  w = l, m = null;\n  try {\n    return V(o, !0);\n  } finally {\n    m = n, w = i;\n  }\n}\nfunction j(e, t) {\n  t = t ? Object.assign({}, J, t) : J;\n  const n = {\n    value: e,\n    observers: null,\n    observerSlots: null,\n    comparator: t.equals || void 0\n  }, i = (r) => (typeof r == \"function\" && (r = r(n.value)), Be(n, r));\n  return [Ke.bind(n), i];\n}\nfunction A(e, t, n) {\n  const i = _e(e, t, !1, M);\n  q(i);\n}\nfunction Fe(e, t, n) {\n  Re = Ct;\n  const i = _e(e, t, !1, M);\n  (!n || !n.render) && (i.user = !0), I ? I.push(i) : q(i);\n}\nfunction F(e, t, n) {\n  n = n ? Object.assign({}, J, n) : J;\n  const i = _e(e, t, !0, 0);\n  return i.observers = null, i.observerSlots = null, i.comparator = n.equals || void 0, q(i), Ke.bind(i);\n}\nfunction mt(e) {\n  return V(e, !1);\n}\nfunction T(e) {\n  if (m === null)\n    return e();\n  const t = m;\n  m = null;\n  try {\n    return e();\n  } finally {\n    m = t;\n  }\n}\nfunction bt(e) {\n  Fe(() => T(e));\n}\nfunction Me(e) {\n  return w === null || (w.cleanups === null ? w.cleanups = [e] : w.cleanups.push(e)), e;\n}\nfunction wt(e) {\n  const t = F(e), n = F(() => be(t()));\n  return n.toArray = () => {\n    const i = n();\n    return Array.isArray(i) ? i : i != null ? [i] : [];\n  }, n;\n}\nfunction Ke() {\n  if (this.sources && this.state)\n    if (this.state === M)\n      q(this);\n    else {\n      const e = S;\n      S = null, V(() => te(this), !1), S = e;\n    }\n  if (m) {\n    const e = this.observers ? this.observers.length : 0;\n    m.sources ? (m.sources.push(this), m.sourceSlots.push(e)) : (m.sources = [this], m.sourceSlots = [e]), this.observers ? (this.observers.push(m), this.observerSlots.push(m.sources.length - 1)) : (this.observers = [m], this.observerSlots = [m.sources.length - 1]);\n  }\n  return this.value;\n}\nfunction Be(e, t, n) {\n  let i = e.value;\n  return (!e.comparator || !e.comparator(i, t)) && (e.value = t, e.observers && e.observers.length && V(() => {\n    for (let r = 0; r < e.observers.length; r += 1) {\n      const s = e.observers[r], l = de && de.running;\n      l && de.disposed.has(s), (l ? !s.tState : !s.state) && (s.pure ? S.push(s) : I.push(s), s.observers && Ue(s)), l || (s.state = M);\n    }\n    if (S.length > 1e6)\n      throw S = [], new Error();\n  }, !1)), t;\n}\nfunction q(e) {\n  if (!e.fn)\n    return;\n  ie(e);\n  const t = ne;\n  vt(\n    e,\n    e.value,\n    t\n  );\n}\nfunction vt(e, t, n) {\n  let i;\n  const r = w, s = m;\n  m = w = e;\n  try {\n    i = e.fn(t);\n  } catch (l) {\n    return e.pure && (e.state = M, e.owned && e.owned.forEach(ie), e.owned = null), e.updatedAt = n + 1, We(l);\n  } finally {\n    m = s, w = r;\n  }\n  (!e.updatedAt || e.updatedAt <= n) && (e.updatedAt != null && \"observers\" in e ? Be(e, i) : e.value = i, e.updatedAt = n);\n}\nfunction _e(e, t, n, i = M, r) {\n  const s = {\n    fn: e,\n    state: i,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: t,\n    owner: w,\n    context: w ? w.context : null,\n    pure: n\n  };\n  return w === null || w !== Ie && (w.owned ? w.owned.push(s) : w.owned = [s]), s;\n}\nfunction ee(e) {\n  if (e.state === 0)\n    return;\n  if (e.state === Q)\n    return te(e);\n  if (e.suspense && T(e.suspense.inFallback))\n    return e.suspense.effects.push(e);\n  const t = [e];\n  for (; (e = e.owner) && (!e.updatedAt || e.updatedAt < ne); )\n    e.state && t.push(e);\n  for (let n = t.length - 1; n >= 0; n--)\n    if (e = t[n], e.state === M)\n      q(e);\n    else if (e.state === Q) {\n      const i = S;\n      S = null, V(() => te(e, t[0]), !1), S = i;\n    }\n}\nfunction V(e, t) {\n  if (S)\n    return e();\n  let n = !1;\n  t || (S = []), I ? n = !0 : I = [], ne++;\n  try {\n    const i = e();\n    return xt(n), i;\n  } catch (i) {\n    n || (I = null), S = null, We(i);\n  }\n}\nfunction xt(e) {\n  if (S && (De(S), S = null), e)\n    return;\n  const t = I;\n  I = null, t.length && V(() => Re(t), !1);\n}\nfunction De(e) {\n  for (let t = 0; t < e.length; t++)\n    ee(e[t]);\n}\nfunction Ct(e) {\n  let t, n = 0;\n  for (t = 0; t < e.length; t++) {\n    const i = e[t];\n    i.user ? e[n++] = i : ee(i);\n  }\n  for (t = 0; t < n; t++)\n    ee(e[t]);\n}\nfunction te(e, t) {\n  e.state = 0;\n  for (let n = 0; n < e.sources.length; n += 1) {\n    const i = e.sources[n];\n    if (i.sources) {\n      const r = i.state;\n      r === M ? i !== t && (!i.updatedAt || i.updatedAt < ne) && ee(i) : r === Q && te(i, t);\n    }\n  }\n}\nfunction Ue(e) {\n  for (let t = 0; t < e.observers.length; t += 1) {\n    const n = e.observers[t];\n    n.state || (n.state = Q, n.pure ? S.push(n) : I.push(n), n.observers && Ue(n));\n  }\n}\nfunction ie(e) {\n  let t;\n  if (e.sources)\n    for (; e.sources.length; ) {\n      const n = e.sources.pop(), i = e.sourceSlots.pop(), r = n.observers;\n      if (r && r.length) {\n        const s = r.pop(), l = n.observerSlots.pop();\n        i < r.length && (s.sourceSlots[l] = i, r[i] = s, n.observerSlots[i] = l);\n      }\n    }\n  if (e.owned) {\n    for (t = e.owned.length - 1; t >= 0; t--)\n      ie(e.owned[t]);\n    e.owned = null;\n  }\n  if (e.cleanups) {\n    for (t = e.cleanups.length - 1; t >= 0; t--)\n      e.cleanups[t]();\n    e.cleanups = null;\n  }\n  e.state = 0;\n}\nfunction Pt(e) {\n  return e instanceof Error ? e : new Error(typeof e == \"string\" ? e : \"Unknown error\", {\n    cause: e\n  });\n}\nfunction We(e, t = w) {\n  throw Pt(e);\n}\nfunction be(e) {\n  if (typeof e == \"function\" && !e.length)\n    return be(e());\n  if (Array.isArray(e)) {\n    const t = [];\n    for (let n = 0; n < e.length; n++) {\n      const i = be(e[n]);\n      Array.isArray(i) ? t.push.apply(t, i) : t.push(i);\n    }\n    return t;\n  }\n  return e;\n}\nconst St = Symbol(\"fallback\");\nfunction Ae(e) {\n  for (let t = 0; t < e.length; t++)\n    e[t]();\n}\nfunction _t(e, t, n = {}) {\n  let i = [], r = [], s = [], l = 0, o = t.length > 1 ? [] : null;\n  return Me(() => Ae(s)), () => {\n    let c = e() || [], f, a;\n    return c[yt], T(() => {\n      let d = c.length, h, v, y, z, $, P, _, E, R;\n      if (d === 0)\n        l !== 0 && (Ae(s), s = [], i = [], r = [], l = 0, o && (o = [])), n.fallback && (i = [St], r[0] = Z((se) => (s[0] = se, n.fallback())), l = 1);\n      else if (l === 0) {\n        for (r = new Array(d), a = 0; a < d; a++)\n          i[a] = c[a], r[a] = Z(u);\n        l = d;\n      } else {\n        for (y = new Array(d), z = new Array(d), o && ($ = new Array(d)), P = 0, _ = Math.min(l, d); P < _ && i[P] === c[P]; P++)\n          ;\n        for (_ = l - 1, E = d - 1; _ >= P && E >= P && i[_] === c[E]; _--, E--)\n          y[E] = r[_], z[E] = s[_], o && ($[E] = o[_]);\n        for (h = /* @__PURE__ */ new Map(), v = new Array(E + 1), a = E; a >= P; a--)\n          R = c[a], f = h.get(R), v[a] = f === void 0 ? -1 : f, h.set(R, a);\n        for (f = P; f <= _; f++)\n          R = i[f], a = h.get(R), a !== void 0 && a !== -1 ? (y[a] = r[f], z[a] = s[f], o && ($[a] = o[f]), a = v[a], h.set(R, a)) : s[f]();\n        for (a = P; a < d; a++)\n          a in y ? (r[a] = y[a], s[a] = z[a], o && (o[a] = $[a], o[a](a))) : r[a] = Z(u);\n        r = r.slice(0, l = d), i = c.slice(0);\n      }\n      return r;\n    });\n    function u(d) {\n      if (s[a] = d, o) {\n        const [h, v] = j(a);\n        return o[a] = v, t(c[a], h);\n      }\n      return t(c[a]);\n    }\n  };\n}\nfunction g(e, t) {\n  return T(() => e(t || {}));\n}\nfunction Y() {\n  return !0;\n}\nconst Et = {\n  get(e, t, n) {\n    return t === me ? n : e.get(t);\n  },\n  has(e, t) {\n    return t === me ? !0 : e.has(t);\n  },\n  set: Y,\n  deleteProperty: Y,\n  getOwnPropertyDescriptor(e, t) {\n    return {\n      configurable: !0,\n      enumerable: !0,\n      get() {\n        return e.get(t);\n      },\n      set: Y,\n      deleteProperty: Y\n    };\n  },\n  ownKeys(e) {\n    return e.keys();\n  }\n};\nfunction fe(e) {\n  return (e = typeof e == \"function\" ? e() : e) ? e : {};\n}\nfunction kt() {\n  for (let e = 0, t = this.length; e < t; ++e) {\n    const n = this[e]();\n    if (n !== void 0)\n      return n;\n  }\n}\nfunction $t(...e) {\n  let t = !1;\n  for (let l = 0; l < e.length; l++) {\n    const o = e[l];\n    t = t || !!o && me in o, e[l] = typeof o == \"function\" ? (t = !0, F(o)) : o;\n  }\n  if (t)\n    return new Proxy(\n      {\n        get(l) {\n          for (let o = e.length - 1; o >= 0; o--) {\n            const c = fe(e[o])[l];\n            if (c !== void 0)\n              return c;\n          }\n        },\n        has(l) {\n          for (let o = e.length - 1; o >= 0; o--)\n            if (l in fe(e[o]))\n              return !0;\n          return !1;\n        },\n        keys() {\n          const l = [];\n          for (let o = 0; o < e.length; o++)\n            l.push(...Object.keys(fe(e[o])));\n          return [...new Set(l)];\n        }\n      },\n      Et\n    );\n  const n = {}, i = /* @__PURE__ */ Object.create(null);\n  for (let l = e.length - 1; l >= 0; l--) {\n    const o = e[l];\n    if (!o)\n      continue;\n    const c = Object.getOwnPropertyNames(o);\n    for (let f = c.length - 1; f >= 0; f--) {\n      const a = c[f];\n      if (a === \"__proto__\" || a === \"constructor\")\n        continue;\n      const u = Object.getOwnPropertyDescriptor(o, a);\n      if (!i[a])\n        i[a] = u.get ? {\n          enumerable: !0,\n          configurable: !0,\n          get: kt.bind(n[a] = [u.get.bind(o)])\n        } : u.value !== void 0 ? u : void 0;\n      else {\n        const d = n[a];\n        d && (u.get ? d.push(u.get.bind(o)) : u.value !== void 0 && d.push(() => u.value));\n      }\n    }\n  }\n  const r = {}, s = Object.keys(i);\n  for (let l = s.length - 1; l >= 0; l--) {\n    const o = s[l], c = i[o];\n    c && c.get ? Object.defineProperty(r, o, c) : r[o] = c ? c.value : void 0;\n  }\n  return r;\n}\nconst Ve = (e) => `Stale read from <${e}>.`;\nfunction At(e) {\n  const t = \"fallback\" in e && {\n    fallback: () => e.fallback\n  };\n  return F(_t(() => e.each, e.children, t || void 0));\n}\nfunction he(e) {\n  const t = e.keyed, n = F(() => e.when, void 0, {\n    equals: (i, r) => t ? i === r : !i == !r\n  });\n  return F(\n    () => {\n      const i = n();\n      if (i) {\n        const r = e.children;\n        return typeof r == \"function\" && r.length > 0 ? T(\n          () => r(\n            t ? i : () => {\n              if (!T(n))\n                throw Ve(\"Show\");\n              return e.when;\n            }\n          )\n        ) : r;\n      }\n      return e.fallback;\n    },\n    void 0,\n    void 0\n  );\n}\nfunction Lt(e) {\n  let t = !1;\n  const n = (s, l) => (t ? s[1] === l[1] : !s[1] == !l[1]) && s[2] === l[2], i = wt(() => e.children), r = F(\n    () => {\n      let s = i();\n      Array.isArray(s) || (s = [s]);\n      for (let l = 0; l < s.length; l++) {\n        const o = s[l].when;\n        if (o)\n          return t = !!s[l].keyed, [l, o, s[l]];\n      }\n      return [-1];\n    },\n    void 0,\n    {\n      equals: n\n    }\n  );\n  return F(\n    () => {\n      const [s, l, o] = r();\n      if (s < 0)\n        return e.fallback;\n      const c = o.children;\n      return typeof c == \"function\" && c.length > 0 ? T(\n        () => c(\n          t ? l : () => {\n            if (T(r)[0] !== s)\n              throw Ve(\"Match\");\n            return o.when;\n          }\n        )\n      ) : c;\n    },\n    void 0,\n    void 0\n  );\n}\nfunction pe(e) {\n  return e;\n}\nconst Ot = [\n  \"allowfullscreen\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"indeterminate\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"seamless\",\n  \"selected\"\n], jt = /* @__PURE__ */ new Set([\n  \"className\",\n  \"value\",\n  \"readOnly\",\n  \"formNoValidate\",\n  \"isMap\",\n  \"noModule\",\n  \"playsInline\",\n  ...Ot\n]), Tt = /* @__PURE__ */ new Set([\n  \"innerHTML\",\n  \"textContent\",\n  \"innerText\",\n  \"children\"\n]), Nt = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n}), zt = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  class: \"className\",\n  formnovalidate: {\n    $: \"formNoValidate\",\n    BUTTON: 1,\n    INPUT: 1\n  },\n  ismap: {\n    $: \"isMap\",\n    IMG: 1\n  },\n  nomodule: {\n    $: \"noModule\",\n    SCRIPT: 1\n  },\n  playsinline: {\n    $: \"playsInline\",\n    VIDEO: 1\n  },\n  readonly: {\n    $: \"readOnly\",\n    INPUT: 1,\n    TEXTAREA: 1\n  }\n});\nfunction Rt(e, t) {\n  const n = zt[e];\n  return typeof n == \"object\" ? n[t] ? n.$ : void 0 : n;\n}\nconst It = /* @__PURE__ */ new Set([\n  \"beforeinput\",\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"focusin\",\n  \"focusout\",\n  \"input\",\n  \"keydown\",\n  \"keyup\",\n  \"mousedown\",\n  \"mousemove\",\n  \"mouseout\",\n  \"mouseover\",\n  \"mouseup\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerout\",\n  \"pointerover\",\n  \"pointerup\",\n  \"touchend\",\n  \"touchmove\",\n  \"touchstart\"\n]), Ft = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nfunction Mt(e, t, n) {\n  let i = n.length, r = t.length, s = i, l = 0, o = 0, c = t[r - 1].nextSibling, f = null;\n  for (; l < r || o < s; ) {\n    if (t[l] === n[o]) {\n      l++, o++;\n      continue;\n    }\n    for (; t[r - 1] === n[s - 1]; )\n      r--, s--;\n    if (r === l) {\n      const a = s < i ? o ? n[o - 1].nextSibling : n[s - o] : c;\n      for (; o < s; )\n        e.insertBefore(n[o++], a);\n    } else if (s === o)\n      for (; l < r; )\n        (!f || !f.has(t[l])) && t[l].remove(), l++;\n    else if (t[l] === n[s - 1] && n[o] === t[r - 1]) {\n      const a = t[--r].nextSibling;\n      e.insertBefore(n[o++], t[l++].nextSibling), e.insertBefore(n[--s], a), t[r] = n[s];\n    } else {\n      if (!f) {\n        f = /* @__PURE__ */ new Map();\n        let u = o;\n        for (; u < s; )\n          f.set(n[u], u++);\n      }\n      const a = f.get(t[l]);\n      if (a != null)\n        if (o < a && a < s) {\n          let u = l, d = 1, h;\n          for (; ++u < r && u < s && !((h = f.get(t[u])) == null || h !== a + d); )\n            d++;\n          if (d > a - o) {\n            const v = t[l];\n            for (; o < a; )\n              e.insertBefore(n[o++], v);\n          } else\n            e.replaceChild(n[o++], t[l++]);\n        } else\n          l++;\n      else\n        t[l++].remove();\n    }\n  }\n}\nconst Le = \"_$DX_DELEGATE\";\nfunction C(e, t, n) {\n  let i;\n  const r = () => {\n    const l = document.createElement(\"template\");\n    return l.innerHTML = e, n ? l.content.firstChild.firstChild : l.content.firstChild;\n  }, s = t ? () => T(() => document.importNode(i || (i = r()), !0)) : () => (i || (i = r())).cloneNode(!0);\n  return s.cloneNode = s, s;\n}\nfunction Kt(e, t = window.document) {\n  const n = t[Le] || (t[Le] = /* @__PURE__ */ new Set());\n  for (let i = 0, r = e.length; i < r; i++) {\n    const s = e[i];\n    n.has(s) || (n.add(s), t.addEventListener(s, Ht));\n  }\n}\nfunction N(e, t, n) {\n  n == null ? e.removeAttribute(t) : e.setAttribute(t, n);\n}\nfunction Bt(e, t, n, i) {\n  i == null ? e.removeAttributeNS(t, n) : e.setAttributeNS(t, n, i);\n}\nfunction Dt(e, t) {\n  t == null ? e.removeAttribute(\"class\") : e.className = t;\n}\nfunction Ut(e, t, n, i) {\n  if (i)\n    Array.isArray(n) ? (e[`$$${t}`] = n[0], e[`$$${t}Data`] = n[1]) : e[`$$${t}`] = n;\n  else if (Array.isArray(n)) {\n    const r = n[0];\n    e.addEventListener(t, n[0] = (s) => r.call(e, n[1], s));\n  } else\n    e.addEventListener(t, n);\n}\nfunction Wt(e, t, n = {}) {\n  const i = Object.keys(t || {}), r = Object.keys(n);\n  let s, l;\n  for (s = 0, l = r.length; s < l; s++) {\n    const o = r[s];\n    !o || o === \"undefined\" || t[o] || (Oe(e, o, !1), delete n[o]);\n  }\n  for (s = 0, l = i.length; s < l; s++) {\n    const o = i[s], c = !!t[o];\n    !o || o === \"undefined\" || n[o] === c || !c || (Oe(e, o, !0), n[o] = c);\n  }\n  return n;\n}\nfunction L(e, t, n) {\n  if (!t)\n    return n ? N(e, \"style\") : t;\n  const i = e.style;\n  if (typeof t == \"string\")\n    return i.cssText = t;\n  typeof n == \"string\" && (i.cssText = n = void 0), n || (n = {}), t || (t = {});\n  let r, s;\n  for (s in n)\n    t[s] == null && i.removeProperty(s), delete n[s];\n  for (s in t)\n    r = t[s], r !== n[s] && (i.setProperty(s, r), n[s] = r);\n  return n;\n}\nfunction Vt(e, t = {}, n, i) {\n  const r = {};\n  return i || A(\n    () => r.children = U(e, t.children, r.children)\n  ), A(() => t.ref && t.ref(e)), A(() => Xt(e, t, n, !0, r, !0)), r;\n}\nfunction ye(e, t, n) {\n  return T(() => e(t, n));\n}\nfunction b(e, t, n, i) {\n  if (n !== void 0 && !i && (i = []), typeof t != \"function\")\n    return U(e, t, i, n);\n  A((r) => U(e, t(), r, n), i);\n}\nfunction Xt(e, t, n, i, r = {}, s = !1) {\n  t || (t = {});\n  for (const l in r)\n    if (!(l in t)) {\n      if (l === \"children\")\n        continue;\n      r[l] = je(e, l, null, r[l], n, s);\n    }\n  for (const l in t) {\n    if (l === \"children\") {\n      i || U(e, t.children);\n      continue;\n    }\n    const o = t[l];\n    r[l] = je(e, l, o, r[l], n, s);\n  }\n}\nfunction qt(e) {\n  return e.toLowerCase().replace(/-([a-z])/g, (t, n) => n.toUpperCase());\n}\nfunction Oe(e, t, n) {\n  const i = t.trim().split(/\\s+/);\n  for (let r = 0, s = i.length; r < s; r++)\n    e.classList.toggle(i[r], n);\n}\nfunction je(e, t, n, i, r, s) {\n  let l, o, c, f, a;\n  if (t === \"style\")\n    return L(e, n, i);\n  if (t === \"classList\")\n    return Wt(e, n, i);\n  if (n === i)\n    return i;\n  if (t === \"ref\")\n    s || n(e);\n  else if (t.slice(0, 3) === \"on:\") {\n    const u = t.slice(3);\n    i && e.removeEventListener(u, i), n && e.addEventListener(u, n);\n  } else if (t.slice(0, 10) === \"oncapture:\") {\n    const u = t.slice(10);\n    i && e.removeEventListener(u, i, !0), n && e.addEventListener(u, n, !0);\n  } else if (t.slice(0, 2) === \"on\") {\n    const u = t.slice(2).toLowerCase(), d = It.has(u);\n    if (!d && i) {\n      const h = Array.isArray(i) ? i[0] : i;\n      e.removeEventListener(u, h);\n    }\n    (d || n) && (Ut(e, u, n, d), d && Kt([u]));\n  } else if (t.slice(0, 5) === \"attr:\")\n    N(e, t.slice(5), n);\n  else if ((a = t.slice(0, 5) === \"prop:\") || (c = Tt.has(t)) || !r && ((f = Rt(t, e.tagName)) || (o = jt.has(t))) || (l = e.nodeName.includes(\"-\")))\n    a && (t = t.slice(5), o = !0), t === \"class\" || t === \"className\" ? Dt(e, n) : l && !o && !c ? e[qt(t)] = n : e[f || t] = n;\n  else {\n    const u = r && t.indexOf(\":\") > -1 && Ft[t.split(\":\")[0]];\n    u ? Bt(e, u, t, n) : N(e, Nt[t] || t, n);\n  }\n  return n;\n}\nfunction Ht(e) {\n  const t = `$$${e.type}`;\n  let n = e.composedPath && e.composedPath()[0] || e.target;\n  for (e.target !== n && Object.defineProperty(e, \"target\", {\n    configurable: !0,\n    value: n\n  }), Object.defineProperty(e, \"currentTarget\", {\n    configurable: !0,\n    get() {\n      return n || document;\n    }\n  }); n; ) {\n    const i = n[t];\n    if (i && !n.disabled) {\n      const r = n[`${t}Data`];\n      if (r !== void 0 ? i.call(n, r, e) : i.call(n, e), e.cancelBubble)\n        return;\n    }\n    n = n._$host || n.parentNode || n.host;\n  }\n}\nfunction U(e, t, n, i, r) {\n  for (; typeof n == \"function\"; )\n    n = n();\n  if (t === n)\n    return n;\n  const s = typeof t, l = i !== void 0;\n  if (e = l && n[0] && n[0].parentNode || e, s === \"string\" || s === \"number\")\n    if (s === \"number\" && (t = t.toString()), l) {\n      let o = n[0];\n      o && o.nodeType === 3 ? o.data !== t && (o.data = t) : o = document.createTextNode(t), n = D(e, n, i, o);\n    } else\n      n !== \"\" && typeof n == \"string\" ? n = e.firstChild.data = t : n = e.textContent = t;\n  else if (t == null || s === \"boolean\")\n    n = D(e, n, i);\n  else {\n    if (s === \"function\")\n      return A(() => {\n        let o = t();\n        for (; typeof o == \"function\"; )\n          o = o();\n        n = U(e, o, n, i);\n      }), () => n;\n    if (Array.isArray(t)) {\n      const o = [], c = n && Array.isArray(n);\n      if (we(o, t, n, r))\n        return A(() => n = U(e, o, n, i, !0)), () => n;\n      if (o.length === 0) {\n        if (n = D(e, n, i), l)\n          return n;\n      } else\n        c ? n.length === 0 ? Te(e, o, i) : Mt(e, n, o) : (n && D(e), Te(e, o));\n      n = o;\n    } else if (t.nodeType) {\n      if (Array.isArray(n)) {\n        if (l)\n          return n = D(e, n, i, t);\n        D(e, n, null, t);\n      } else\n        n == null || n === \"\" || !e.firstChild ? e.appendChild(t) : e.replaceChild(t, e.firstChild);\n      n = t;\n    }\n  }\n  return n;\n}\nfunction we(e, t, n, i) {\n  let r = !1;\n  for (let s = 0, l = t.length; s < l; s++) {\n    let o = t[s], c = n && n[e.length], f;\n    if (!(o == null || o === !0 || o === !1))\n      if ((f = typeof o) == \"object\" && o.nodeType)\n        e.push(o);\n      else if (Array.isArray(o))\n        r = we(e, o, c) || r;\n      else if (f === \"function\")\n        if (i) {\n          for (; typeof o == \"function\"; )\n            o = o();\n          r = we(\n            e,\n            Array.isArray(o) ? o : [o],\n            Array.isArray(c) ? c : [c]\n          ) || r;\n        } else\n          e.push(o), r = !0;\n      else {\n        const a = String(o);\n        c && c.nodeType === 3 && c.data === a ? e.push(c) : e.push(document.createTextNode(a));\n      }\n  }\n  return r;\n}\nfunction Te(e, t, n = null) {\n  for (let i = 0, r = t.length; i < r; i++)\n    e.insertBefore(t[i], n);\n}\nfunction D(e, t, n, i) {\n  if (n === void 0)\n    return e.textContent = \"\";\n  const r = i || document.createTextNode(\"\");\n  if (t.length) {\n    let s = !1;\n    for (let l = t.length - 1; l >= 0; l--) {\n      const o = t[l];\n      if (r !== o) {\n        const c = o.parentNode === e;\n        !s && !l ? c ? e.replaceChild(r, o) : e.insertBefore(r, n) : c && o.remove();\n      } else\n        s = !0;\n    }\n  } else\n    e.insertBefore(r, n);\n  return [r];\n}\nfunction Yt(e) {\n  const t = Object.keys(e), n = {};\n  for (let i = 0; i < t.length; i++) {\n    const [r, s] = j(e[t[i]]);\n    Object.defineProperty(n, t[i], {\n      get: r,\n      set(l) {\n        s(() => l);\n      }\n    });\n  }\n  return n;\n}\nfunction Gt(e) {\n  if (e.assignedSlot && e.assignedSlot._$owner)\n    return e.assignedSlot._$owner;\n  let t = e.parentNode;\n  for (; t && !t._$owner && !(t.assignedSlot && t.assignedSlot._$owner); )\n    t = t.parentNode;\n  return t && t.assignedSlot ? t.assignedSlot._$owner : e._$owner;\n}\nfunction Zt(e) {\n  return (t, n) => {\n    const { element: i } = n;\n    return Z((r) => {\n      const s = Yt(t);\n      i.addPropertyChangedCallback((o, c) => s[o] = c), i.addReleaseCallback(() => {\n        i.renderRoot.textContent = \"\", r();\n      });\n      const l = e(s, n);\n      return b(i.renderRoot, l);\n    }, Gt(i));\n  };\n}\nfunction Jt(e, t, n) {\n  return arguments.length === 2 && (n = t, t = {}), ht(e, t)(Zt(n));\n}\nconst ve = \"sats-connect_wallet-provider-selector_select\", xe = \"sats-connect_wallet-provider-selector_cancel\", Ce = \"sats-connect_wallet-provider-selector_open\", Pe = \"sats-connect_wallet-provider-selector_close\", Xe = \"sats-connect_wallet-provider-selector_walletOpen\", qe = \"sats-connect_wallet-provider-selector_walletClose\", re = {\n  color: \"#181818\",\n  \"font-size\": \"18px\",\n  \"font-weight\": \"700\",\n  \"line-height\": \"1.4\"\n}, W = {\n  color: \"#181818\",\n  \"font-size\": \"14px\",\n  \"font-weight\": \"400\",\n  \"line-height\": \"1.4\"\n}, Qt = {\n  color: \"#181818\",\n  \"font-size\": \"14px\",\n  \"font-weight\": \"500\"\n};\nvar en = /* @__PURE__ */ C('<svg width=24 height=24 viewBox=\"0 0 24 24\"fill=none xmlns=http://www.w3.org/2000/svg><g id=XCircle><path id=Vector d=\"M12 2.25C10.0716 2.25 8.18657 2.82183 6.58319 3.89317C4.97982 4.96451 3.73013 6.48726 2.99218 8.26884C2.25422 10.0504 2.06114 12.0108 2.43735 13.9021C2.81355 15.7934 3.74215 17.5307 5.10571 18.8943C6.46928 20.2579 8.20656 21.1865 10.0979 21.5627C11.9892 21.9389 13.9496 21.7458 15.7312 21.0078C17.5127 20.2699 19.0355 19.0202 20.1068 17.4168C21.1782 15.8134 21.75 13.9284 21.75 12C21.745 9.41566 20.7162 6.93859 18.8888 5.11118C17.0614 3.28378 14.5843 2.25496 12 2.25ZM15.5344 14.4656C15.6752 14.6078 15.7542 14.7999 15.7542 15C15.7542 15.2001 15.6752 15.3922 15.5344 15.5344C15.391 15.673 15.1994 15.7505 15 15.7505C14.8006 15.7505 14.609 15.673 14.4656 15.5344L12 13.0594L9.53438 15.5344C9.39102 15.673 9.19942 15.7505 9 15.7505C8.80059 15.7505 8.60898 15.673 8.46563 15.5344C8.32479 15.3922 8.24578 15.2001 8.24578 15C8.24578 14.7999 8.32479 14.6078 8.46563 14.4656L10.9406 12L8.46563 9.53437C8.34603 9.38865 8.28491 9.20366 8.29416 9.01537C8.30341 8.82708 8.38236 8.64896 8.51566 8.51566C8.64896 8.38236 8.82708 8.3034 9.01537 8.29416C9.20366 8.28491 9.38866 8.34603 9.53438 8.46563L12 10.9406L14.4656 8.46563C14.6114 8.34603 14.7963 8.28491 14.9846 8.29416C15.1729 8.3034 15.351 8.38236 15.4843 8.51566C15.6176 8.64896 15.6966 8.82708 15.7058 9.01537C15.7151 9.20366 15.654 9.38865 15.5344 9.53437L13.0594 12L15.5344 14.4656Z\"fill=black fill-opacity=0.3>'), tn = /* @__PURE__ */ C(`<style>\n          .close-selector-button:focus-visible {\n            outline: 2px solid #181818;\n            outline-offset: -0.25px;\n          }\n        `), nn = /* @__PURE__ */ C(\"<div role=button tabindex=0 class=close-selector-button>\");\nfunction rn(e) {\n  return (() => {\n    var t = en();\n    return t.style.setProperty(\"display\", \"block\"), Vt(t, e, !0, !0), t;\n  })();\n}\nfunction sn(e) {\n  function t(n) {\n    (n.key === \"Enter\" || n.key === \" \") && e.onClose();\n  }\n  return [tn(), (() => {\n    var n = nn();\n    return n.style.setProperty(\"position\", \"absolute\"), n.style.setProperty(\"top\", \"16px\"), n.style.setProperty(\"right\", \"16px\"), n.style.setProperty(\"background\", \"none\"), n.style.setProperty(\"border\", \"none\"), n.style.setProperty(\"cursor\", \"pointer\"), n.style.setProperty(\"padding\", \"0\"), n.style.setProperty(\"margin\", \"0\"), n.style.setProperty(\"border-radius\", \"50%\"), n.addEventListener(\"click\", e.onClose), n.addEventListener(\"keydown\", t), b(n, g(rn, {})), n;\n  })()];\n}\nvar on = /* @__PURE__ */ C(`<style>\n/*! modern-normalize v2.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize */\n\n/*\nDocument\n========\n*/\n\n/**\nUse a better box model (opinionated).\n*/\n\n*,\n::before,\n::after {\n\tbox-sizing: border-box;\n\tmargin: 0; /* Remove all margins from everywhere. */\n}\n\n:host {\n\t/* Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3) */\n\tfont-family:\n\t\t'DM Sans', /* Note: not part of modern-normalize, added specifically for this project. */\n\t\tsystem-ui,\n\t\t'Segoe UI',\n\t\tRoboto,\n\t\tHelvetica,\n\t\tArial,\n\t\tsans-serif,\n\t\t'Apple Color Emoji',\n\t\t'Segoe UI Emoji';\n\tline-height: 1.15; /* 1. Correct the line height in all browsers. */\n\t-webkit-text-size-adjust: 100%; /* 2. Prevent adjustments of font size after orientation changes in iOS. */\n\t-moz-tab-size: 4; /* 3. Use a more readable tab size (opinionated). */\n\ttab-size: 4; /* 3 */\n}\n\n/*\nSections\n========\n*/\n\n:host {\n\tmargin: 0; /* Remove the margin in all browsers. */\n}\n\n/*\nGrouping content\n================\n*/\n\n/**\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n*/\n\nhr {\n\theight: 0; /* 1 */\n\tcolor: inherit; /* 2 */\n}\n\n/*\nText-level semantics\n====================\n*/\n\n/**\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr[title] {\n\ttext-decoration: underline dotted;\n}\n\n/**\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n\tfont-weight: bolder;\n}\n\n/**\n1. Improve consistency of default fonts in all browsers. (https://github.com/sindresorhus/modern-normalize/issues/3)\n2. Correct the odd 'em' font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n\tfont-family:\n\t\tui-monospace,\n\t\tSFMono-Regular,\n\t\tConsolas,\n\t\t'Liberation Mono',\n\t\tMenlo,\n\t\tmonospace; /* 1 */\n\tfont-size: 1em; /* 2 */\n}\n\n/**\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n\tfont-size: 80%;\n}\n\n/**\nPrevent 'sub' and 'sup' elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n\tfont-size: 75%;\n\tline-height: 0;\n\tposition: relative;\n\tvertical-align: baseline;\n}\n\nsub {\n\tbottom: -0.25em;\n}\n\nsup {\n\ttop: -0.5em;\n}\n\n/*\nTabular data\n============\n*/\n\n/**\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n*/\n\ntable {\n\ttext-indent: 0; /* 1 */\n\tborder-color: inherit; /* 2 */\n}\n\n/*\nForms\n=====\n*/\n\n/**\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n\tfont-family: inherit; /* 1 */\n\tfont-size: 100%; /* 1 */\n\tline-height: 1.15; /* 1 */\n\tmargin: 0; /* 2 */\n}\n\n/**\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n\ttext-transform: none;\n}\n\n/**\nCorrect the inability to style clickable types in iOS and Safari.\n*/\n\nbutton,\n[type='button'],\n[type='reset'],\n[type='submit'] {\n\t-webkit-appearance: button;\n}\n\n/**\nRemove the inner border and padding in Firefox.\n*/\n\n::-moz-focus-inner {\n\tborder-style: none;\n\tpadding: 0;\n}\n\n/**\nRestore the focus styles unset by the previous rule.\n*/\n\n:-moz-focusring {\n\toutline: 1px dotted ButtonText;\n}\n\n/**\nRemove the additional ':invalid' styles in Firefox.\nSee: https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737\n*/\n\n:-moz-ui-invalid {\n\tbox-shadow: none;\n}\n\n/**\nRemove the padding so developers are not caught out when they zero out 'fieldset' elements in all browsers.\n*/\n\nlegend {\n\tpadding: 0;\n}\n\n/**\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n\tvertical-align: baseline;\n}\n\n/**\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n\theight: auto;\n}\n\n/**\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type='search'] {\n\t-webkit-appearance: textfield; /* 1 */\n\toutline-offset: -2px; /* 2 */\n}\n\n/**\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n\t-webkit-appearance: none;\n}\n\n/**\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to 'inherit' in Safari.\n*/\n\n::-webkit-file-upload-button {\n\t-webkit-appearance: button; /* 1 */\n\tfont: inherit; /* 2 */\n}\n\n/*\nInteractive\n===========\n*/\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n\tdisplay: list-item;\n}\n`);\nfunction ln() {\n  return on();\n}\nvar an = /* @__PURE__ */ C(\"<div class=divider><div>\");\nfunction cn() {\n  return (() => {\n    var e = an(), t = e.firstChild;\n    return t.style.setProperty(\"height\", \"100%\"), t.style.setProperty(\"width\", \"1px\"), t.style.setProperty(\"background\", \"#dcdcdc\"), e;\n  })();\n}\nvar un = /* @__PURE__ */ C(\"<div>\");\nfunction dn(e) {\n  return (() => {\n    var t = un();\n    return t.style.setProperty(\"padding\", \"24px\"), t.style.setProperty(\"height\", \"100%\"), b(t, () => e.children), t;\n  })();\n}\nvar fn = /* @__PURE__ */ C(\"<div>\");\nfunction hn(e) {\n  return (() => {\n    var t = fn();\n    return t.style.setProperty(\"display\", \"flex\"), t.style.setProperty(\"flex-direction\", \"column\"), t.style.setProperty(\"justify-content\", \"center\"), t.style.setProperty(\"align-items\", \"center\"), t.style.setProperty(\"height\", \"100%\"), b(t, () => e.children), t;\n  })();\n}\nvar pn = /* @__PURE__ */ C(\"<div><div>🤔</div><div>What is a wallet?</div><p>Wallets let you send, receive, store and display digital assets like Bitcoin, Stacks, Ordinals & NFTs.</p><p>Explore Bitcoin apps by connecting your wallet.\");\nfunction yn() {\n  return (() => {\n    var e = pn(), t = e.firstChild, n = t.nextSibling, i = n.nextSibling, r = i.nextSibling;\n    return e.style.setProperty(\"display\", \"flex\"), e.style.setProperty(\"flex-direction\", \"column\"), e.style.setProperty(\"row-gap\", \"8px\"), e.style.setProperty(\"justify-content\", \"center\"), e.style.setProperty(\"align-items\", \"center\"), t.style.setProperty(\"font-size\", \"50px\"), t.style.setProperty(\"line-height\", \"140%\"), A((s) => {\n      var l = re, o = W, c = W;\n      return s.e = L(n, l, s.e), s.t = L(i, o, s.t), s.a = L(r, c, s.a), s;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0\n    }), e;\n  })();\n}\nfunction Se(e) {\n  var n;\n  const t = (n = e.installPrompt) == null ? void 0 : n.url;\n  if (!t) {\n    console.error(\"No install prompt URL found for\", e.id);\n    return;\n  }\n  window.open(t, \"_blank\");\n}\nvar gn = /* @__PURE__ */ C(`<style>\n          .install-prompt-button:focus-visible {\n            outline: 2px solid #181818;\n            outline-offset: 2px;\n          }\n        `), mn = /* @__PURE__ */ C(\"<div><img><h1>Don't have <!>?</h1><p>Download it on the Chrome web store.</p><div class=install-prompt-button role=button tabindex=0>Get\");\nfunction bn(e) {\n  function t(i) {\n    (i.key === \"Enter\" || i.key === \" \") && Se(e.option);\n  }\n  function n() {\n    Se(e.option);\n  }\n  return [gn(), (() => {\n    var i = mn(), r = i.firstChild, s = r.nextSibling, l = s.firstChild, o = l.nextSibling;\n    o.nextSibling;\n    var c = s.nextSibling, f = c.nextSibling;\n    return i.style.setProperty(\"display\", \"flex\"), i.style.setProperty(\"flex-direction\", \"column\"), i.style.setProperty(\"align-items\", \"center\"), i.style.setProperty(\"row-gap\", \"16px\"), r.style.setProperty(\"border-radius\", \"12px\"), r.style.setProperty(\"height\", \"64px\"), r.style.setProperty(\"width\", \"64px\"), r.style.setProperty(\"object-fit\", \"cover\"), b(s, () => e.option.name, o), f.addEventListener(\"click\", n), f.addEventListener(\"keydown\", t), A((a) => {\n      var u = e.option.icon, d = e.option.name, h = {\n        ...re,\n        \"text-align\": \"center\"\n      }, v = W, y = {\n        ...Qt,\n        cursor: \"pointer\",\n        \"border-radius\": \"12px\",\n        background: \"#181818\",\n        color: \"white\",\n        padding: \"12px 16px\"\n      };\n      return u !== a.e && N(r, \"src\", a.e = u), d !== a.t && N(r, \"alt\", a.t = d), a.a = L(s, h, a.a), a.o = L(c, v, a.o), a.i = L(f, y, a.i), a;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0,\n      i: void 0\n    }), i;\n  })()];\n}\nvar wn = /* @__PURE__ */ C('<svg width=20 height=20 viewBox=\"0 0 20 20\"xmlns=http://www.w3.org/2000/svg><circle cx=10 cy=10 r=9.05 stroke=black stroke-width=1.9 fill=none stroke-dasharray=\"42.65 14.22\"stroke-dashoffset=0><animateTransform attributeName=transform attributeType=XML type=rotate from=\"0 10 10\"to=\"360 10 10\"dur=0.75s repeatCount=indefinite>'), vn = /* @__PURE__ */ C(\"<div>\");\nconst xn = () => wn();\nfunction Cn() {\n  return (() => {\n    var e = vn();\n    return e.style.setProperty(\"display\", \"flex\"), e.style.setProperty(\"justify-content\", \"center\"), e.style.setProperty(\"align-items\", \"center\"), e.style.setProperty(\"height\", \"100%\"), e.style.setProperty(\"animation\", \"spin 1s linear infinite\"), b(e, g(xn, {})), e;\n  })();\n}\nvar Pn = /* @__PURE__ */ C(\"<div><img><h1>Opening <!>...</h1><p>Confirm the operation in \");\nfunction Sn(e) {\n  return (() => {\n    var t = Pn(), n = t.firstChild, i = n.nextSibling, r = i.firstChild, s = r.nextSibling;\n    s.nextSibling;\n    var l = i.nextSibling;\n    return l.firstChild, t.style.setProperty(\"display\", \"flex\"), t.style.setProperty(\"flex-direction\", \"column\"), t.style.setProperty(\"align-items\", \"center\"), t.style.setProperty(\"row-gap\", \"16px\"), n.style.setProperty(\"border-radius\", \"12px\"), n.style.setProperty(\"height\", \"64px\"), n.style.setProperty(\"width\", \"64px\"), n.style.setProperty(\"object-fit\", \"cover\"), b(i, () => e.option.name, s), b(l, () => e.option.name, null), b(t, g(Cn, {}), null), A((o) => {\n      var c = e.option.icon, f = e.option.name, a = {\n        ...re,\n        \"text-align\": \"center\"\n      }, u = W;\n      return c !== o.e && N(n, \"src\", o.e = c), f !== o.t && N(n, \"alt\", o.t = f), o.a = L(i, a, o.a), o.o = L(l, u, o.o), o;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0\n    }), t;\n  })();\n}\nvar _n = /* @__PURE__ */ C(\"<div><div tabindex=0><img><div>\");\nfunction En(e) {\n  function t() {\n    e.onProviderSelected(e.id);\n  }\n  const n = F(() => ke(e) ? \"button\" : \"link\");\n  function i(u) {\n    if (n() === \"link\") {\n      u.key === \"Enter\" && t();\n      return;\n    }\n    if (n() === \"button\") {\n      (u.key === \"Enter\" || u.key === \" \") && t();\n      return;\n    }\n  }\n  const [r, s] = j(!1), [l, o] = j(!1), c = () => r() || l(), f = \"rgba(24, 24, 24, 0.20)\", a = \"rgba(24, 24, 24, 0.60)\";\n  return (() => {\n    var u = _n(), d = u.firstChild, h = d.firstChild, v = h.nextSibling;\n    return u.style.setProperty(\"aspect-ratio\", \"1 / 1\"), u.style.setProperty(\"overflow\", \"hidden\"), d.style.setProperty(\"display\", \"flex\"), d.style.setProperty(\"flex-direction\", \"column\"), d.style.setProperty(\"row-gap\", \"12px\"), d.style.setProperty(\"align-items\", \"center\"), d.style.setProperty(\"cursor\", \"pointer\"), d.style.setProperty(\"outline\", \"none\"), d.style.setProperty(\"padding-top\", \"10px\"), d.addEventListener(\"click\", t), d.addEventListener(\"keydown\", i), d.addEventListener(\"mouseenter\", () => s(!0)), d.addEventListener(\"mouseleave\", () => s(!1)), d.addEventListener(\"focus\", () => o(!0)), d.addEventListener(\"blur\", () => o(!1)), h.style.setProperty(\"width\", \"56px\"), h.style.setProperty(\"height\", \"56px\"), h.style.setProperty(\"object-fit\", \"cover\"), h.style.setProperty(\"border-radius\", \"12px\"), b(v, () => e.name), A((y) => {\n      var z = n(), $ = c() ? `6px solid ${f}` : \"none\", P = e.icon, _ = e.name, E = {\n        ...W,\n        color: c() ? a : void 0,\n        \"text-align\": \"center\"\n      };\n      return z !== y.e && N(d, \"role\", y.e = z), $ !== y.t && ((y.t = $) != null ? h.style.setProperty(\"outline\", $) : h.style.removeProperty(\"outline\")), P !== y.a && N(h, \"src\", y.a = P), _ !== y.o && N(h, \"alt\", y.o = _), y.i = L(v, E, y.i), y;\n    }, {\n      e: void 0,\n      t: void 0,\n      a: void 0,\n      o: void 0,\n      i: void 0\n    }), u;\n  })();\n}\nvar kn = /* @__PURE__ */ C('<link href=\"https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&amp;display=swap\"rel=stylesheet>'), $n = /* @__PURE__ */ C(\"<div class=side-panel>\"), An = /* @__PURE__ */ C('<div><div></div><div><div class=card-width-container><div class=card-height-container><div class=card><div class=card-grid><div class=main-panel><div></div><div></div><div class=wallets-grid-container data-desc=\"wallet grid container for padding\"><div class=wallets-grid data-desc=\"wallet grid container\">'), Ln = /* @__PURE__ */ C(`<div><style>\n        @keyframes wallet-selector-fade-in {\n          from {opacity: 0; transform: translateY(40px);}\n          to {opacity: 1; transform: translateY(0);}\n        }\n\n        @keyframes wallet-selector-fade-out {\n          from {opacity: 1; transform: translateY(0);}\n          to {opacity: 0; transform: translateY(40px);}\n        }\n        @keyframes wallet-selector-blur-in {\n          from {opacity: 0; backdrop-filter: blur(0px);}\n          to {opacity: 1; backdrop-filter: blur(10px);}\n        }\n\n        @keyframes wallet-selector-blur-out {\n          from {opacity: 1; backdrop-filter: blur(10px);}\n          to {opacity: 0; backdrop-filter: blur(0px);}\n        }\n      </style><style>`);\nconst G = \"24px\";\nfunction On() {\n  const [e, t] = j(), [n, i] = j(), [r, s] = j();\n  function l() {\n    const p = e(), x = r();\n    return !(!p || !x || !p.contains(x) || getComputedStyle(x).display === \"none\");\n  }\n  const [o, c] = j(!1), [f, a] = j(!1), [u, d] = j([]), [h, v] = j({\n    type: \"none\"\n  }), y = () => u().some((p) => jn(p)), z = () => c(!1);\n  function $() {\n    const p = new CustomEvent(xe, {\n      bubbles: !0,\n      composed: !0\n    });\n    window.dispatchEvent(p), z();\n  }\n  function P(p) {\n    p.key === \"Escape\" && $();\n  }\n  Fe(() => {\n    if (o()) {\n      window.addEventListener(\"keydown\", P);\n      return;\n    }\n    window.removeEventListener(\"keydown\", P);\n  });\n  function _(p) {\n    const x = u().find((K) => K.id === p);\n    if (ke(x)) {\n      l() ? v({\n        type: \"install-wallet-prompt\",\n        option: x\n      }) : Se(x);\n      return;\n    }\n    const O = new CustomEvent(ve, {\n      detail: p,\n      bubbles: !0,\n      composed: !0\n    });\n    window.dispatchEvent(O);\n  }\n  function E(p) {\n    mt(() => {\n      c(!0), a(!0);\n      const x = p.detail.options;\n      d(x), x.some((O) => !O.installPrompt) ? v({\n        type: \"explainer\"\n      }) : v({\n        type: \"none\"\n      });\n    });\n  }\n  function R() {\n    c(!1);\n  }\n  const se = () => {\n    o() || a(!1);\n  };\n  function Ye(p) {\n    const x = p.detail;\n    v({\n      type: \"opening-wallet\",\n      option: u().find((O) => O.id === x)\n    });\n  }\n  function Ge() {\n    v({\n      type: \"explainer\"\n    });\n  }\n  bt(() => {\n    window.addEventListener(Ce, E), window.addEventListener(Pe, R), window.addEventListener(Xe, Ye), window.addEventListener(qe, Ge), document.head.appendChild(kn());\n  }), Me(() => {\n    window.removeEventListener(Ce, E), window.removeEventListener(Pe, R);\n  });\n  function Ze(p) {\n    const x = p.target;\n    if (!x)\n      return;\n    const O = n();\n    O && (O.contains(x) || $());\n  }\n  return (() => {\n    var p = Ln(), x = p.firstChild, O = x.nextSibling;\n    return ye(t, p), p.style.setProperty(\"inset\", \"0\"), p.addEventListener(\"click\", Ze), p.addEventListener(\"keydown\", () => {\n      console.log(\"Inside root keydown\");\n    }), b(p, g(ln, {}), x), b(O, () => `\n        .card-width-container {\n          container: card-width-container / inline-size;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          height: 100%;\n          width: 740px;\n        }\n\n        .card-height-container {\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n          justify-content: flex-end;\n          height: 100%;\n          width: 100%;\n        }\n\n        .card {\n          min-height: 340px;\n          max-height: calc(100vh - 8rem);\n          width: 100%;\n          border-top-left-radius: ${G};\n          border-top-right-radius: ${G};\n\n          background: rgb(196, 177, 217);\n          overflow: hidden;\n\n          display: flex;\n          flex-direction: column;\n\n          position: \"relative\"; /* For the close button */\n          background-color: #ffffff;\n          display: ${f() ? \"block\" : \"none\"};\n\n          box-shadow: 0px 8px 64px 0px rgba(0, 0, 0, 0.25);\n          animation: ${o() ? \"wallet-selector-fade-in 0.4s cubic-bezier(.05, .7, .1, 1) forwards\" : \"wallet-selector-fade-out 0.2s cubic-bezier(.3, 0, .8, .15) forwards\"};\n        }\n\n        .card-grid {\n          flex-grow: 1;\n          height: 100%;\n          \n          display: grid;\n          grid-template-columns: 1fr;\n          grid-template-areas: \"mainPanel\";\n        }\n\n        .main-panel {\n          height: 100%;\n          overflow: hidden;\n          display: flex;\n          flex-direction: column;\n          grid-area: mainPanel;\n        }\n\n        .wallets-grid-container {\n          overflow: auto;\n          flex-grow: 1;\n        }\n\n        .wallets-grid {\n          display: grid;\n          grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));\n          align-content: start;\n\n          padding-left: 24px;\n          padding-right: 24px;\n          padding-bottom: 40px;\n        }\n\n        .divider {\n          display: none;\n          grid-area: divider;\n        }\n\n        .side-panel {\n          display: none;\n          grid-area: sidePanel;\n        }\n\n        @container card-width-container (width > 400px) {\n          .card-height-container {\n            justify-content: center;\n          }\n\n          .card {\n            max-width: calc(100vw - 2rem);\n            max-height: 460px;\n            ${y() ? \"\" : \"width: 360px;\"}\n            border-bottom-left-radius: ${G};\n            border-bottom-right-radius: ${G};\n          }\n\n          .card-grid {\n            grid-template-columns: ${y() ? \"5fr auto 4fr\" : \"1fr\"};\n            grid-template-areas: ${y() ? '\"mainPanel divider sidePanel\"' : '\"mainPanel\"'};\n          }\n\n          .divider {\n            display: block;\n          }\n\n          .side-panel {\n            display: flex;\n            flex-direction: column;\n            justify-content: center;\n            align-items: center;\n          }\n        }\n      `), b(p, g(he, {\n      get when() {\n        return f();\n      },\n      get children() {\n        var K = An(), B = K.firstChild, X = B.nextSibling, Je = X.firstChild, Qe = Je.firstChild, H = Qe.firstChild, oe = H.firstChild, et = oe.firstChild, le = et.firstChild, ae = le.nextSibling, tt = ae.nextSibling, nt = tt.firstChild;\n        return K.style.setProperty(\"position\", \"fixed\"), K.style.setProperty(\"inset\", \"0\"), B.style.setProperty(\"background-color\", \"#FFFFFF80\"), B.style.setProperty(\"position\", \"absolute\"), B.style.setProperty(\"inset\", \"0\"), X.style.setProperty(\"display\", \"flex\"), X.style.setProperty(\"justify-content\", \"center\"), X.style.setProperty(\"align-items\", \"center\"), X.style.setProperty(\"height\", \"100%\"), ye(i, H), H.addEventListener(\"animationend\", se), b(le, () => y() ? \"Choose wallet to connect\" : \"Don't have a wallet?\"), b(ae, () => y() ? \"Start by selecting with one of the wallets below and confirming the connection.\" : \"Start by installing one of the wallets below.\"), b(nt, g(At, {\n          get each() {\n            return u();\n          },\n          children: (k) => g(En, $t(k, {\n            onProviderSelected: _\n          }))\n        })), b(oe, g(he, {\n          get when() {\n            return h().type !== \"none\";\n          },\n          get children() {\n            return g(cn, {});\n          }\n        }), null), b(oe, g(he, {\n          get when() {\n            return h().type !== \"none\";\n          },\n          get children() {\n            var k = $n();\n            return ye(s, k), b(k, g(dn, {\n              get children() {\n                return g(hn, {\n                  get children() {\n                    return g(Lt, {\n                      fallback: null,\n                      get children() {\n                        return [g(pe, {\n                          get when() {\n                            return h().type === \"install-wallet-prompt\";\n                          },\n                          get children() {\n                            return g(bn, {\n                              get option() {\n                                return h().option;\n                              }\n                            });\n                          }\n                        }), g(pe, {\n                          get when() {\n                            return h().type === \"explainer\";\n                          },\n                          get children() {\n                            return g(yn, {});\n                          }\n                        }), g(pe, {\n                          get when() {\n                            return h().type === \"opening-wallet\";\n                          },\n                          get children() {\n                            return g(Sn, {\n                              get option() {\n                                return h().option;\n                              }\n                            });\n                          }\n                        })];\n                      }\n                    });\n                  }\n                });\n              }\n            })), k;\n          }\n        }), null), b(H, g(sn, {\n          onClose: $\n        }), null), A((k) => {\n          var ce = o() ? \"wallet-selector-blur-in 0.2s cubic-bezier(.05, .7, .1, 1) forwards\" : \"wallet-selector-blur-out 0.2s cubic-bezier(.3, 0, .8, .15) forwards\", it = {\n            ...re,\n            margin: \"0\",\n            \"padding-top\": \"24px\",\n            \"padding-left\": \"24px\",\n            \"padding-right\": \"24px\",\n            \"padding-bottom\": \"16px\"\n          }, rt = {\n            ...W,\n            \"padding-left\": \"24px\",\n            \"padding-right\": \"24px\",\n            \"padding-bottom\": \"30px\"\n          };\n          return ce !== k.e && ((k.e = ce) != null ? B.style.setProperty(\"animation\", ce) : B.style.removeProperty(\"animation\")), k.t = L(le, it, k.t), k.a = L(ae, rt, k.a), k;\n        }, {\n          e: void 0,\n          t: void 0,\n          a: void 0\n        }), K;\n      }\n    }), null), A(() => (f() ? \"fixed\" : \"static\") != null ? p.style.setProperty(\"position\", f() ? \"fixed\" : \"static\") : p.style.removeProperty(\"position\")), p;\n  })();\n}\nconst Ee = \"sats-connect-wallet-provider-selector\", ge = Ee;\nfunction He() {\n  return document.getElementById(Ee);\n}\nfunction Nn() {\n  if (customElements.get(ge))\n    return;\n  Jt(ge, On);\n  const e = document.createElement(ge);\n  e.id = Ee, e.style.position = \"relative\", e.style.zIndex = \"999999\", document.body.appendChild(e);\n}\nfunction zn() {\n  const e = He();\n  e && e.remove();\n}\nfunction ke(e) {\n  return !!e.installPrompt;\n}\nfunction jn(e) {\n  return !ke(e);\n}\nfunction Rn(e) {\n  return new Promise((t, n) => {\n    if (!He()) {\n      n(\"Failed to detect the wallet provider selector.\");\n      return;\n    }\n    function r() {\n      window.removeEventListener(ve, s), window.removeEventListener(xe, l);\n    }\n    function s(c) {\n      t(c.detail), r();\n    }\n    function l() {\n      n(), r();\n    }\n    window.addEventListener(ve, s), window.addEventListener(xe, l);\n    const o = new CustomEvent(Ce, {\n      detail: e\n    });\n    window.dispatchEvent(o);\n  });\n}\nfunction In(e) {\n  const t = new CustomEvent(Xe, {\n    detail: e\n  });\n  window.dispatchEvent(t);\n}\nfunction Fn() {\n  const e = new CustomEvent(qe);\n  window.dispatchEvent(e);\n}\nfunction Mn() {\n  const e = new CustomEvent(Pe);\n  window.dispatchEvent(e);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNhdHMtY29ubmVjdCt1aUAwLjAuNi9ub2RlX21vZHVsZXMvQHNhdHMtY29ubmVjdC91aS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhGQUE4RjtBQUNoSSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxPQUFPO0FBQzNFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNKQUFzSjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFEQUFxRDtBQUM5RDtB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QUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2F0cy1jb25uZWN0K3VpQDAuMC42L25vZGVfbW9kdWxlcy9Ac2F0cy1jb25uZWN0L3VpL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gc3QoZSkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoZSkucmVkdWNlKChuLCBpKSA9PiB7XG4gICAgY29uc3QgciA9IGVbaV07XG4gICAgcmV0dXJuIG5baV0gPSBPYmplY3QuYXNzaWduKHt9LCByKSwgemUoci52YWx1ZSkgJiYgIXV0KHIudmFsdWUpICYmICFBcnJheS5pc0FycmF5KHIudmFsdWUpICYmIChuW2ldLnZhbHVlID0gT2JqZWN0LmFzc2lnbih7fSwgci52YWx1ZSkpLCBBcnJheS5pc0FycmF5KHIudmFsdWUpICYmIChuW2ldLnZhbHVlID0gci52YWx1ZS5zbGljZSgwKSksIG47XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIG90KGUpIHtcbiAgcmV0dXJuIGUgPyBPYmplY3Qua2V5cyhlKS5yZWR1Y2UoKG4sIGkpID0+IHtcbiAgICBjb25zdCByID0gZVtpXTtcbiAgICByZXR1cm4gbltpXSA9IHplKHIpICYmIFwidmFsdWVcIiBpbiByID8gciA6IHtcbiAgICAgIHZhbHVlOiByXG4gICAgfSwgbltpXS5hdHRyaWJ1dGUgfHwgKG5baV0uYXR0cmlidXRlID0gY3QoaSkpLCBuW2ldLnBhcnNlID0gXCJwYXJzZVwiIGluIG5baV0gPyBuW2ldLnBhcnNlIDogdHlwZW9mIG5baV0udmFsdWUgIT0gXCJzdHJpbmdcIiwgbjtcbiAgfSwge30pIDoge307XG59XG5mdW5jdGlvbiBsdChlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhlKS5yZWR1Y2UoKG4sIGkpID0+IChuW2ldID0gZVtpXS52YWx1ZSwgbiksIHt9KTtcbn1cbmZ1bmN0aW9uIGF0KGUsIHQpIHtcbiAgY29uc3QgbiA9IHN0KHQpO1xuICByZXR1cm4gT2JqZWN0LmtleXModCkuZm9yRWFjaCgocikgPT4ge1xuICAgIGNvbnN0IHMgPSBuW3JdLCBsID0gZS5nZXRBdHRyaWJ1dGUocy5hdHRyaWJ1dGUpLCBvID0gZVtyXTtcbiAgICBsICYmIChzLnZhbHVlID0gcy5wYXJzZSA/IE5lKGwpIDogbCksIG8gIT0gbnVsbCAmJiAocy52YWx1ZSA9IEFycmF5LmlzQXJyYXkobykgPyBvLnNsaWNlKDApIDogbyksIHMucmVmbGVjdCAmJiAkZShlLCBzLmF0dHJpYnV0ZSwgcy52YWx1ZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBzLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldChjKSB7XG4gICAgICAgIGNvbnN0IGYgPSBzLnZhbHVlO1xuICAgICAgICBzLnZhbHVlID0gYywgcy5yZWZsZWN0ICYmICRlKHRoaXMsIHMuYXR0cmlidXRlLCBzLnZhbHVlKTtcbiAgICAgICAgZm9yIChsZXQgYSA9IDAsIHUgPSB0aGlzLl9fcHJvcGVydHlDaGFuZ2VkQ2FsbGJhY2tzLmxlbmd0aDsgYSA8IHU7IGErKylcbiAgICAgICAgICB0aGlzLl9fcHJvcGVydHlDaGFuZ2VkQ2FsbGJhY2tzW2FdKHIsIGMsIGYpO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH0pO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIE5lKGUpIHtcbiAgaWYgKGUpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxufVxuZnVuY3Rpb24gJGUoZSwgdCwgbikge1xuICBpZiAobiA9PSBudWxsIHx8IG4gPT09ICExKVxuICAgIHJldHVybiBlLnJlbW92ZUF0dHJpYnV0ZSh0KTtcbiAgbGV0IGkgPSBKU09OLnN0cmluZ2lmeShuKTtcbiAgZS5fX3VwZGF0aW5nW3RdID0gITAsIGkgPT09IFwidHJ1ZVwiICYmIChpID0gXCJcIiksIGUuc2V0QXR0cmlidXRlKHQsIGkpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGRlbGV0ZSBlLl9fdXBkYXRpbmdbdF0pO1xufVxuZnVuY3Rpb24gY3QoZSkge1xuICByZXR1cm4gZS5yZXBsYWNlKC9cXC4/KFtBLVpdKykvZywgKHQsIG4pID0+IFwiLVwiICsgbi50b0xvd2VyQ2FzZSgpKS5yZXBsYWNlKFwiX1wiLCBcIi1cIikucmVwbGFjZSgvXi0vLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIHplKGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gdXQoZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG59XG5mdW5jdGlvbiBkdChlKSB7XG4gIHJldHVybiB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgZS50b1N0cmluZygpLmluZGV4T2YoXCJjbGFzc1wiKSA9PT0gMDtcbn1cbmxldCB1ZTtcbmZ1bmN0aW9uIGZ0KGUsIHQpIHtcbiAgY29uc3QgbiA9IE9iamVjdC5rZXlzKHQpO1xuICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBlIHtcbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIHJldHVybiBuLm1hcCgocikgPT4gdFtyXS5hdHRyaWJ1dGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCksIHRoaXMuX19pbml0aWFsaXplZCA9ICExLCB0aGlzLl9fcmVsZWFzZWQgPSAhMSwgdGhpcy5fX3JlbGVhc2VDYWxsYmFja3MgPSBbXSwgdGhpcy5fX3Byb3BlcnR5Q2hhbmdlZENhbGxiYWNrcyA9IFtdLCB0aGlzLl9fdXBkYXRpbmcgPSB7fSwgdGhpcy5wcm9wcyA9IHt9O1xuICAgIH1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmICh0aGlzLl9faW5pdGlhbGl6ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX19yZWxlYXNlQ2FsbGJhY2tzID0gW10sIHRoaXMuX19wcm9wZXJ0eUNoYW5nZWRDYWxsYmFja3MgPSBbXSwgdGhpcy5fX3VwZGF0aW5nID0ge30sIHRoaXMucHJvcHMgPSBhdCh0aGlzLCB0KTtcbiAgICAgIGNvbnN0IHIgPSBsdCh0aGlzLnByb3BzKSwgcyA9IHRoaXMuQ29tcG9uZW50LCBsID0gdWU7XG4gICAgICB0cnkge1xuICAgICAgICB1ZSA9IHRoaXMsIHRoaXMuX19pbml0aWFsaXplZCA9ICEwLCBkdChzKSA/IG5ldyBzKHIsIHtcbiAgICAgICAgICBlbGVtZW50OiB0aGlzXG4gICAgICAgIH0pIDogcyhyLCB7XG4gICAgICAgICAgZWxlbWVudDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVlID0gbDtcbiAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBpZiAoYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCksIHRoaXMuaXNDb25uZWN0ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX19wcm9wZXJ0eUNoYW5nZWRDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGxldCByID0gbnVsbDtcbiAgICAgIGZvciAoOyByID0gdGhpcy5fX3JlbGVhc2VDYWxsYmFja3MucG9wKCk7IClcbiAgICAgICAgcih0aGlzKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9faW5pdGlhbGl6ZWQsIHRoaXMuX19yZWxlYXNlZCA9ICEwO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sociwgcywgbCkge1xuICAgICAgaWYgKHRoaXMuX19pbml0aWFsaXplZCAmJiAhdGhpcy5fX3VwZGF0aW5nW3JdICYmIChyID0gdGhpcy5sb29rdXBQcm9wKHIpLCByIGluIHQpKSB7XG4gICAgICAgIGlmIChsID09IG51bGwgJiYgIXRoaXNbcl0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzW3JdID0gdFtyXS5wYXJzZSA/IE5lKGwpIDogbDtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9va3VwUHJvcChyKSB7XG4gICAgICBpZiAodClcbiAgICAgICAgcmV0dXJuIG4uZmluZCgocykgPT4gciA9PT0gcyB8fCByID09PSB0W3NdLmF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIGdldCByZW5kZXJSb290KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhZG93Um9vdCB8fCB0aGlzLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgIG1vZGU6IFwib3BlblwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgYWRkUmVsZWFzZUNhbGxiYWNrKHIpIHtcbiAgICAgIHRoaXMuX19yZWxlYXNlQ2FsbGJhY2tzLnB1c2gocik7XG4gICAgfVxuICAgIGFkZFByb3BlcnR5Q2hhbmdlZENhbGxiYWNrKHIpIHtcbiAgICAgIHRoaXMuX19wcm9wZXJ0eUNoYW5nZWRDYWxsYmFja3MucHVzaChyKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBodChlLCB0ID0ge30sIG4gPSB7fSkge1xuICBjb25zdCB7XG4gICAgQmFzZUVsZW1lbnQ6IGkgPSBIVE1MRWxlbWVudCxcbiAgICBleHRlbnNpb246IHJcbiAgfSA9IG47XG4gIHJldHVybiAocykgPT4ge1xuICAgIGlmICghZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInRhZyBpcyByZXF1aXJlZCB0byByZWdpc3RlciBhIENvbXBvbmVudFwiKTtcbiAgICBsZXQgbCA9IGN1c3RvbUVsZW1lbnRzLmdldChlKTtcbiAgICByZXR1cm4gbCA/IChsLnByb3RvdHlwZS5Db21wb25lbnQgPSBzLCBsKSA6IChsID0gZnQoaSwgb3QodCkpLCBsLnByb3RvdHlwZS5Db21wb25lbnQgPSBzLCBsLnByb3RvdHlwZS5yZWdpc3RlcmVkVGFnID0gZSwgY3VzdG9tRWxlbWVudHMuZGVmaW5lKGUsIGwsIHIpLCBsKTtcbiAgfTtcbn1cbmNvbnN0IHB0ID0gKGUsIHQpID0+IGUgPT09IHQsIG1lID0gU3ltYm9sKFwic29saWQtcHJveHlcIiksIHl0ID0gU3ltYm9sKFwic29saWQtdHJhY2tcIiksIEogPSB7XG4gIGVxdWFsczogcHRcbn07XG5sZXQgUmUgPSBEZTtcbmNvbnN0IE0gPSAxLCBRID0gMiwgSWUgPSB7XG4gIG93bmVkOiBudWxsLFxuICBjbGVhbnVwczogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgb3duZXI6IG51bGxcbn07XG52YXIgdyA9IG51bGw7XG5sZXQgZGUgPSBudWxsLCBndCA9IG51bGwsIG0gPSBudWxsLCBTID0gbnVsbCwgSSA9IG51bGwsIG5lID0gMDtcbmZ1bmN0aW9uIFooZSwgdCkge1xuICBjb25zdCBuID0gbSwgaSA9IHcsIHIgPSBlLmxlbmd0aCA9PT0gMCwgcyA9IHQgPT09IHZvaWQgMCA/IGkgOiB0LCBsID0gciA/IEllIDoge1xuICAgIG93bmVkOiBudWxsLFxuICAgIGNsZWFudXBzOiBudWxsLFxuICAgIGNvbnRleHQ6IHMgPyBzLmNvbnRleHQgOiBudWxsLFxuICAgIG93bmVyOiBzXG4gIH0sIG8gPSByID8gZSA6ICgpID0+IGUoKCkgPT4gVCgoKSA9PiBpZShsKSkpO1xuICB3ID0gbCwgbSA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFYobywgITApO1xuICB9IGZpbmFsbHkge1xuICAgIG0gPSBuLCB3ID0gaTtcbiAgfVxufVxuZnVuY3Rpb24gaihlLCB0KSB7XG4gIHQgPSB0ID8gT2JqZWN0LmFzc2lnbih7fSwgSiwgdCkgOiBKO1xuICBjb25zdCBuID0ge1xuICAgIHZhbHVlOiBlLFxuICAgIG9ic2VydmVyczogbnVsbCxcbiAgICBvYnNlcnZlclNsb3RzOiBudWxsLFxuICAgIGNvbXBhcmF0b3I6IHQuZXF1YWxzIHx8IHZvaWQgMFxuICB9LCBpID0gKHIpID0+ICh0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgJiYgKHIgPSByKG4udmFsdWUpKSwgQmUobiwgcikpO1xuICByZXR1cm4gW0tlLmJpbmQobiksIGldO1xufVxuZnVuY3Rpb24gQShlLCB0LCBuKSB7XG4gIGNvbnN0IGkgPSBfZShlLCB0LCAhMSwgTSk7XG4gIHEoaSk7XG59XG5mdW5jdGlvbiBGZShlLCB0LCBuKSB7XG4gIFJlID0gQ3Q7XG4gIGNvbnN0IGkgPSBfZShlLCB0LCAhMSwgTSk7XG4gICghbiB8fCAhbi5yZW5kZXIpICYmIChpLnVzZXIgPSAhMCksIEkgPyBJLnB1c2goaSkgOiBxKGkpO1xufVxuZnVuY3Rpb24gRihlLCB0LCBuKSB7XG4gIG4gPSBuID8gT2JqZWN0LmFzc2lnbih7fSwgSiwgbikgOiBKO1xuICBjb25zdCBpID0gX2UoZSwgdCwgITAsIDApO1xuICByZXR1cm4gaS5vYnNlcnZlcnMgPSBudWxsLCBpLm9ic2VydmVyU2xvdHMgPSBudWxsLCBpLmNvbXBhcmF0b3IgPSBuLmVxdWFscyB8fCB2b2lkIDAsIHEoaSksIEtlLmJpbmQoaSk7XG59XG5mdW5jdGlvbiBtdChlKSB7XG4gIHJldHVybiBWKGUsICExKTtcbn1cbmZ1bmN0aW9uIFQoZSkge1xuICBpZiAobSA9PT0gbnVsbClcbiAgICByZXR1cm4gZSgpO1xuICBjb25zdCB0ID0gbTtcbiAgbSA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGUoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBtID0gdDtcbiAgfVxufVxuZnVuY3Rpb24gYnQoZSkge1xuICBGZSgoKSA9PiBUKGUpKTtcbn1cbmZ1bmN0aW9uIE1lKGUpIHtcbiAgcmV0dXJuIHcgPT09IG51bGwgfHwgKHcuY2xlYW51cHMgPT09IG51bGwgPyB3LmNsZWFudXBzID0gW2VdIDogdy5jbGVhbnVwcy5wdXNoKGUpKSwgZTtcbn1cbmZ1bmN0aW9uIHd0KGUpIHtcbiAgY29uc3QgdCA9IEYoZSksIG4gPSBGKCgpID0+IGJlKHQoKSkpO1xuICByZXR1cm4gbi50b0FycmF5ID0gKCkgPT4ge1xuICAgIGNvbnN0IGkgPSBuKCk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaSkgPyBpIDogaSAhPSBudWxsID8gW2ldIDogW107XG4gIH0sIG47XG59XG5mdW5jdGlvbiBLZSgpIHtcbiAgaWYgKHRoaXMuc291cmNlcyAmJiB0aGlzLnN0YXRlKVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBNKVxuICAgICAgcSh0aGlzKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IGUgPSBTO1xuICAgICAgUyA9IG51bGwsIFYoKCkgPT4gdGUodGhpcyksICExKSwgUyA9IGU7XG4gICAgfVxuICBpZiAobSkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9ic2VydmVycyA/IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA6IDA7XG4gICAgbS5zb3VyY2VzID8gKG0uc291cmNlcy5wdXNoKHRoaXMpLCBtLnNvdXJjZVNsb3RzLnB1c2goZSkpIDogKG0uc291cmNlcyA9IFt0aGlzXSwgbS5zb3VyY2VTbG90cyA9IFtlXSksIHRoaXMub2JzZXJ2ZXJzID8gKHRoaXMub2JzZXJ2ZXJzLnB1c2gobSksIHRoaXMub2JzZXJ2ZXJTbG90cy5wdXNoKG0uc291cmNlcy5sZW5ndGggLSAxKSkgOiAodGhpcy5vYnNlcnZlcnMgPSBbbV0sIHRoaXMub2JzZXJ2ZXJTbG90cyA9IFttLnNvdXJjZXMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIHJldHVybiB0aGlzLnZhbHVlO1xufVxuZnVuY3Rpb24gQmUoZSwgdCwgbikge1xuICBsZXQgaSA9IGUudmFsdWU7XG4gIHJldHVybiAoIWUuY29tcGFyYXRvciB8fCAhZS5jb21wYXJhdG9yKGksIHQpKSAmJiAoZS52YWx1ZSA9IHQsIGUub2JzZXJ2ZXJzICYmIGUub2JzZXJ2ZXJzLmxlbmd0aCAmJiBWKCgpID0+IHtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGUub2JzZXJ2ZXJzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICBjb25zdCBzID0gZS5vYnNlcnZlcnNbcl0sIGwgPSBkZSAmJiBkZS5ydW5uaW5nO1xuICAgICAgbCAmJiBkZS5kaXNwb3NlZC5oYXMocyksIChsID8gIXMudFN0YXRlIDogIXMuc3RhdGUpICYmIChzLnB1cmUgPyBTLnB1c2gocykgOiBJLnB1c2gocyksIHMub2JzZXJ2ZXJzICYmIFVlKHMpKSwgbCB8fCAocy5zdGF0ZSA9IE0pO1xuICAgIH1cbiAgICBpZiAoUy5sZW5ndGggPiAxZTYpXG4gICAgICB0aHJvdyBTID0gW10sIG5ldyBFcnJvcigpO1xuICB9LCAhMSkpLCB0O1xufVxuZnVuY3Rpb24gcShlKSB7XG4gIGlmICghZS5mbilcbiAgICByZXR1cm47XG4gIGllKGUpO1xuICBjb25zdCB0ID0gbmU7XG4gIHZ0KFxuICAgIGUsXG4gICAgZS52YWx1ZSxcbiAgICB0XG4gICk7XG59XG5mdW5jdGlvbiB2dChlLCB0LCBuKSB7XG4gIGxldCBpO1xuICBjb25zdCByID0gdywgcyA9IG07XG4gIG0gPSB3ID0gZTtcbiAgdHJ5IHtcbiAgICBpID0gZS5mbih0KTtcbiAgfSBjYXRjaCAobCkge1xuICAgIHJldHVybiBlLnB1cmUgJiYgKGUuc3RhdGUgPSBNLCBlLm93bmVkICYmIGUub3duZWQuZm9yRWFjaChpZSksIGUub3duZWQgPSBudWxsKSwgZS51cGRhdGVkQXQgPSBuICsgMSwgV2UobCk7XG4gIH0gZmluYWxseSB7XG4gICAgbSA9IHMsIHcgPSByO1xuICB9XG4gICghZS51cGRhdGVkQXQgfHwgZS51cGRhdGVkQXQgPD0gbikgJiYgKGUudXBkYXRlZEF0ICE9IG51bGwgJiYgXCJvYnNlcnZlcnNcIiBpbiBlID8gQmUoZSwgaSkgOiBlLnZhbHVlID0gaSwgZS51cGRhdGVkQXQgPSBuKTtcbn1cbmZ1bmN0aW9uIF9lKGUsIHQsIG4sIGkgPSBNLCByKSB7XG4gIGNvbnN0IHMgPSB7XG4gICAgZm46IGUsXG4gICAgc3RhdGU6IGksXG4gICAgdXBkYXRlZEF0OiBudWxsLFxuICAgIG93bmVkOiBudWxsLFxuICAgIHNvdXJjZXM6IG51bGwsXG4gICAgc291cmNlU2xvdHM6IG51bGwsXG4gICAgY2xlYW51cHM6IG51bGwsXG4gICAgdmFsdWU6IHQsXG4gICAgb3duZXI6IHcsXG4gICAgY29udGV4dDogdyA/IHcuY29udGV4dCA6IG51bGwsXG4gICAgcHVyZTogblxuICB9O1xuICByZXR1cm4gdyA9PT0gbnVsbCB8fCB3ICE9PSBJZSAmJiAody5vd25lZCA/IHcub3duZWQucHVzaChzKSA6IHcub3duZWQgPSBbc10pLCBzO1xufVxuZnVuY3Rpb24gZWUoZSkge1xuICBpZiAoZS5zdGF0ZSA9PT0gMClcbiAgICByZXR1cm47XG4gIGlmIChlLnN0YXRlID09PSBRKVxuICAgIHJldHVybiB0ZShlKTtcbiAgaWYgKGUuc3VzcGVuc2UgJiYgVChlLnN1c3BlbnNlLmluRmFsbGJhY2spKVxuICAgIHJldHVybiBlLnN1c3BlbnNlLmVmZmVjdHMucHVzaChlKTtcbiAgY29uc3QgdCA9IFtlXTtcbiAgZm9yICg7IChlID0gZS5vd25lcikgJiYgKCFlLnVwZGF0ZWRBdCB8fCBlLnVwZGF0ZWRBdCA8IG5lKTsgKVxuICAgIGUuc3RhdGUgJiYgdC5wdXNoKGUpO1xuICBmb3IgKGxldCBuID0gdC5sZW5ndGggLSAxOyBuID49IDA7IG4tLSlcbiAgICBpZiAoZSA9IHRbbl0sIGUuc3RhdGUgPT09IE0pXG4gICAgICBxKGUpO1xuICAgIGVsc2UgaWYgKGUuc3RhdGUgPT09IFEpIHtcbiAgICAgIGNvbnN0IGkgPSBTO1xuICAgICAgUyA9IG51bGwsIFYoKCkgPT4gdGUoZSwgdFswXSksICExKSwgUyA9IGk7XG4gICAgfVxufVxuZnVuY3Rpb24gVihlLCB0KSB7XG4gIGlmIChTKVxuICAgIHJldHVybiBlKCk7XG4gIGxldCBuID0gITE7XG4gIHQgfHwgKFMgPSBbXSksIEkgPyBuID0gITAgOiBJID0gW10sIG5lKys7XG4gIHRyeSB7XG4gICAgY29uc3QgaSA9IGUoKTtcbiAgICByZXR1cm4geHQobiksIGk7XG4gIH0gY2F0Y2ggKGkpIHtcbiAgICBuIHx8IChJID0gbnVsbCksIFMgPSBudWxsLCBXZShpKTtcbiAgfVxufVxuZnVuY3Rpb24geHQoZSkge1xuICBpZiAoUyAmJiAoRGUoUyksIFMgPSBudWxsKSwgZSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHQgPSBJO1xuICBJID0gbnVsbCwgdC5sZW5ndGggJiYgVigoKSA9PiBSZSh0KSwgITEpO1xufVxuZnVuY3Rpb24gRGUoZSkge1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspXG4gICAgZWUoZVt0XSk7XG59XG5mdW5jdGlvbiBDdChlKSB7XG4gIGxldCB0LCBuID0gMDtcbiAgZm9yICh0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICBjb25zdCBpID0gZVt0XTtcbiAgICBpLnVzZXIgPyBlW24rK10gPSBpIDogZWUoaSk7XG4gIH1cbiAgZm9yICh0ID0gMDsgdCA8IG47IHQrKylcbiAgICBlZShlW3RdKTtcbn1cbmZ1bmN0aW9uIHRlKGUsIHQpIHtcbiAgZS5zdGF0ZSA9IDA7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgZS5zb3VyY2VzLmxlbmd0aDsgbiArPSAxKSB7XG4gICAgY29uc3QgaSA9IGUuc291cmNlc1tuXTtcbiAgICBpZiAoaS5zb3VyY2VzKSB7XG4gICAgICBjb25zdCByID0gaS5zdGF0ZTtcbiAgICAgIHIgPT09IE0gPyBpICE9PSB0ICYmICghaS51cGRhdGVkQXQgfHwgaS51cGRhdGVkQXQgPCBuZSkgJiYgZWUoaSkgOiByID09PSBRICYmIHRlKGksIHQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gVWUoZSkge1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IGUub2JzZXJ2ZXJzLmxlbmd0aDsgdCArPSAxKSB7XG4gICAgY29uc3QgbiA9IGUub2JzZXJ2ZXJzW3RdO1xuICAgIG4uc3RhdGUgfHwgKG4uc3RhdGUgPSBRLCBuLnB1cmUgPyBTLnB1c2gobikgOiBJLnB1c2gobiksIG4ub2JzZXJ2ZXJzICYmIFVlKG4pKTtcbiAgfVxufVxuZnVuY3Rpb24gaWUoZSkge1xuICBsZXQgdDtcbiAgaWYgKGUuc291cmNlcylcbiAgICBmb3IgKDsgZS5zb3VyY2VzLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBuID0gZS5zb3VyY2VzLnBvcCgpLCBpID0gZS5zb3VyY2VTbG90cy5wb3AoKSwgciA9IG4ub2JzZXJ2ZXJzO1xuICAgICAgaWYgKHIgJiYgci5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcyA9IHIucG9wKCksIGwgPSBuLm9ic2VydmVyU2xvdHMucG9wKCk7XG4gICAgICAgIGkgPCByLmxlbmd0aCAmJiAocy5zb3VyY2VTbG90c1tsXSA9IGksIHJbaV0gPSBzLCBuLm9ic2VydmVyU2xvdHNbaV0gPSBsKTtcbiAgICAgIH1cbiAgICB9XG4gIGlmIChlLm93bmVkKSB7XG4gICAgZm9yICh0ID0gZS5vd25lZC5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSlcbiAgICAgIGllKGUub3duZWRbdF0pO1xuICAgIGUub3duZWQgPSBudWxsO1xuICB9XG4gIGlmIChlLmNsZWFudXBzKSB7XG4gICAgZm9yICh0ID0gZS5jbGVhbnVwcy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSlcbiAgICAgIGUuY2xlYW51cHNbdF0oKTtcbiAgICBlLmNsZWFudXBzID0gbnVsbDtcbiAgfVxuICBlLnN0YXRlID0gMDtcbn1cbmZ1bmN0aW9uIFB0KGUpIHtcbiAgcmV0dXJuIGUgaW5zdGFuY2VvZiBFcnJvciA/IGUgOiBuZXcgRXJyb3IodHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBcIlVua25vd24gZXJyb3JcIiwge1xuICAgIGNhdXNlOiBlXG4gIH0pO1xufVxuZnVuY3Rpb24gV2UoZSwgdCA9IHcpIHtcbiAgdGhyb3cgUHQoZSk7XG59XG5mdW5jdGlvbiBiZShlKSB7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgIWUubGVuZ3RoKVxuICAgIHJldHVybiBiZShlKCkpO1xuICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNvbnN0IGkgPSBiZShlW25dKTtcbiAgICAgIEFycmF5LmlzQXJyYXkoaSkgPyB0LnB1c2guYXBwbHkodCwgaSkgOiB0LnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBlO1xufVxuY29uc3QgU3QgPSBTeW1ib2woXCJmYWxsYmFja1wiKTtcbmZ1bmN0aW9uIEFlKGUpIHtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCsrKVxuICAgIGVbdF0oKTtcbn1cbmZ1bmN0aW9uIF90KGUsIHQsIG4gPSB7fSkge1xuICBsZXQgaSA9IFtdLCByID0gW10sIHMgPSBbXSwgbCA9IDAsIG8gPSB0Lmxlbmd0aCA+IDEgPyBbXSA6IG51bGw7XG4gIHJldHVybiBNZSgoKSA9PiBBZShzKSksICgpID0+IHtcbiAgICBsZXQgYyA9IGUoKSB8fCBbXSwgZiwgYTtcbiAgICByZXR1cm4gY1t5dF0sIFQoKCkgPT4ge1xuICAgICAgbGV0IGQgPSBjLmxlbmd0aCwgaCwgdiwgeSwgeiwgJCwgUCwgXywgRSwgUjtcbiAgICAgIGlmIChkID09PSAwKVxuICAgICAgICBsICE9PSAwICYmIChBZShzKSwgcyA9IFtdLCBpID0gW10sIHIgPSBbXSwgbCA9IDAsIG8gJiYgKG8gPSBbXSkpLCBuLmZhbGxiYWNrICYmIChpID0gW1N0XSwgclswXSA9IFooKHNlKSA9PiAoc1swXSA9IHNlLCBuLmZhbGxiYWNrKCkpKSwgbCA9IDEpO1xuICAgICAgZWxzZSBpZiAobCA9PT0gMCkge1xuICAgICAgICBmb3IgKHIgPSBuZXcgQXJyYXkoZCksIGEgPSAwOyBhIDwgZDsgYSsrKVxuICAgICAgICAgIGlbYV0gPSBjW2FdLCByW2FdID0gWih1KTtcbiAgICAgICAgbCA9IGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHkgPSBuZXcgQXJyYXkoZCksIHogPSBuZXcgQXJyYXkoZCksIG8gJiYgKCQgPSBuZXcgQXJyYXkoZCkpLCBQID0gMCwgXyA9IE1hdGgubWluKGwsIGQpOyBQIDwgXyAmJiBpW1BdID09PSBjW1BdOyBQKyspXG4gICAgICAgICAgO1xuICAgICAgICBmb3IgKF8gPSBsIC0gMSwgRSA9IGQgLSAxOyBfID49IFAgJiYgRSA+PSBQICYmIGlbX10gPT09IGNbRV07IF8tLSwgRS0tKVxuICAgICAgICAgIHlbRV0gPSByW19dLCB6W0VdID0gc1tfXSwgbyAmJiAoJFtFXSA9IG9bX10pO1xuICAgICAgICBmb3IgKGggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB2ID0gbmV3IEFycmF5KEUgKyAxKSwgYSA9IEU7IGEgPj0gUDsgYS0tKVxuICAgICAgICAgIFIgPSBjW2FdLCBmID0gaC5nZXQoUiksIHZbYV0gPSBmID09PSB2b2lkIDAgPyAtMSA6IGYsIGguc2V0KFIsIGEpO1xuICAgICAgICBmb3IgKGYgPSBQOyBmIDw9IF87IGYrKylcbiAgICAgICAgICBSID0gaVtmXSwgYSA9IGguZ2V0KFIpLCBhICE9PSB2b2lkIDAgJiYgYSAhPT0gLTEgPyAoeVthXSA9IHJbZl0sIHpbYV0gPSBzW2ZdLCBvICYmICgkW2FdID0gb1tmXSksIGEgPSB2W2FdLCBoLnNldChSLCBhKSkgOiBzW2ZdKCk7XG4gICAgICAgIGZvciAoYSA9IFA7IGEgPCBkOyBhKyspXG4gICAgICAgICAgYSBpbiB5ID8gKHJbYV0gPSB5W2FdLCBzW2FdID0gelthXSwgbyAmJiAob1thXSA9ICRbYV0sIG9bYV0oYSkpKSA6IHJbYV0gPSBaKHUpO1xuICAgICAgICByID0gci5zbGljZSgwLCBsID0gZCksIGkgPSBjLnNsaWNlKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gdShkKSB7XG4gICAgICBpZiAoc1thXSA9IGQsIG8pIHtcbiAgICAgICAgY29uc3QgW2gsIHZdID0gaihhKTtcbiAgICAgICAgcmV0dXJuIG9bYV0gPSB2LCB0KGNbYV0sIGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQoY1thXSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZyhlLCB0KSB7XG4gIHJldHVybiBUKCgpID0+IGUodCB8fCB7fSkpO1xufVxuZnVuY3Rpb24gWSgpIHtcbiAgcmV0dXJuICEwO1xufVxuY29uc3QgRXQgPSB7XG4gIGdldChlLCB0LCBuKSB7XG4gICAgcmV0dXJuIHQgPT09IG1lID8gbiA6IGUuZ2V0KHQpO1xuICB9LFxuICBoYXMoZSwgdCkge1xuICAgIHJldHVybiB0ID09PSBtZSA/ICEwIDogZS5oYXModCk7XG4gIH0sXG4gIHNldDogWSxcbiAgZGVsZXRlUHJvcGVydHk6IFksXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCB0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGUuZ2V0KHQpO1xuICAgICAgfSxcbiAgICAgIHNldDogWSxcbiAgICAgIGRlbGV0ZVByb3BlcnR5OiBZXG4gICAgfTtcbiAgfSxcbiAgb3duS2V5cyhlKSB7XG4gICAgcmV0dXJuIGUua2V5cygpO1xuICB9XG59O1xuZnVuY3Rpb24gZmUoZSkge1xuICByZXR1cm4gKGUgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKCkgOiBlKSA/IGUgOiB7fTtcbn1cbmZ1bmN0aW9uIGt0KCkge1xuICBmb3IgKGxldCBlID0gMCwgdCA9IHRoaXMubGVuZ3RoOyBlIDwgdDsgKytlKSB7XG4gICAgY29uc3QgbiA9IHRoaXNbZV0oKTtcbiAgICBpZiAobiAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cbmZ1bmN0aW9uICR0KC4uLmUpIHtcbiAgbGV0IHQgPSAhMTtcbiAgZm9yIChsZXQgbCA9IDA7IGwgPCBlLmxlbmd0aDsgbCsrKSB7XG4gICAgY29uc3QgbyA9IGVbbF07XG4gICAgdCA9IHQgfHwgISFvICYmIG1lIGluIG8sIGVbbF0gPSB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCIgPyAodCA9ICEwLCBGKG8pKSA6IG87XG4gIH1cbiAgaWYgKHQpXG4gICAgcmV0dXJuIG5ldyBQcm94eShcbiAgICAgIHtcbiAgICAgICAgZ2V0KGwpIHtcbiAgICAgICAgICBmb3IgKGxldCBvID0gZS5sZW5ndGggLSAxOyBvID49IDA7IG8tLSkge1xuICAgICAgICAgICAgY29uc3QgYyA9IGZlKGVbb10pW2xdO1xuICAgICAgICAgICAgaWYgKGMgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoYXMobCkge1xuICAgICAgICAgIGZvciAobGV0IG8gPSBlLmxlbmd0aCAtIDE7IG8gPj0gMDsgby0tKVxuICAgICAgICAgICAgaWYgKGwgaW4gZmUoZVtvXSkpXG4gICAgICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH0sXG4gICAgICAgIGtleXMoKSB7XG4gICAgICAgICAgY29uc3QgbCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKylcbiAgICAgICAgICAgIGwucHVzaCguLi5PYmplY3Qua2V5cyhmZShlW29dKSkpO1xuICAgICAgICAgIHJldHVybiBbLi4ubmV3IFNldChsKV07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBFdFxuICAgICk7XG4gIGNvbnN0IG4gPSB7fSwgaSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBsID0gZS5sZW5ndGggLSAxOyBsID49IDA7IGwtLSkge1xuICAgIGNvbnN0IG8gPSBlW2xdO1xuICAgIGlmICghbylcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvKTtcbiAgICBmb3IgKGxldCBmID0gYy5sZW5ndGggLSAxOyBmID49IDA7IGYtLSkge1xuICAgICAgY29uc3QgYSA9IGNbZl07XG4gICAgICBpZiAoYSA9PT0gXCJfX3Byb3RvX19cIiB8fCBhID09PSBcImNvbnN0cnVjdG9yXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgYSk7XG4gICAgICBpZiAoIWlbYV0pXG4gICAgICAgIGlbYV0gPSB1LmdldCA/IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgIGdldDoga3QuYmluZChuW2FdID0gW3UuZ2V0LmJpbmQobyldKVxuICAgICAgICB9IDogdS52YWx1ZSAhPT0gdm9pZCAwID8gdSA6IHZvaWQgMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkID0gblthXTtcbiAgICAgICAgZCAmJiAodS5nZXQgPyBkLnB1c2godS5nZXQuYmluZChvKSkgOiB1LnZhbHVlICE9PSB2b2lkIDAgJiYgZC5wdXNoKCgpID0+IHUudmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgciA9IHt9LCBzID0gT2JqZWN0LmtleXMoaSk7XG4gIGZvciAobGV0IGwgPSBzLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgY29uc3QgbyA9IHNbbF0sIGMgPSBpW29dO1xuICAgIGMgJiYgYy5nZXQgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgbywgYykgOiByW29dID0gYyA/IGMudmFsdWUgOiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5jb25zdCBWZSA9IChlKSA9PiBgU3RhbGUgcmVhZCBmcm9tIDwke2V9Pi5gO1xuZnVuY3Rpb24gQXQoZSkge1xuICBjb25zdCB0ID0gXCJmYWxsYmFja1wiIGluIGUgJiYge1xuICAgIGZhbGxiYWNrOiAoKSA9PiBlLmZhbGxiYWNrXG4gIH07XG4gIHJldHVybiBGKF90KCgpID0+IGUuZWFjaCwgZS5jaGlsZHJlbiwgdCB8fCB2b2lkIDApKTtcbn1cbmZ1bmN0aW9uIGhlKGUpIHtcbiAgY29uc3QgdCA9IGUua2V5ZWQsIG4gPSBGKCgpID0+IGUud2hlbiwgdm9pZCAwLCB7XG4gICAgZXF1YWxzOiAoaSwgcikgPT4gdCA/IGkgPT09IHIgOiAhaSA9PSAhclxuICB9KTtcbiAgcmV0dXJuIEYoXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3QgaSA9IG4oKTtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGNvbnN0IHIgPSBlLmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiICYmIHIubGVuZ3RoID4gMCA/IFQoXG4gICAgICAgICAgKCkgPT4gcihcbiAgICAgICAgICAgIHQgPyBpIDogKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIVQobikpXG4gICAgICAgICAgICAgICAgdGhyb3cgVmUoXCJTaG93XCIpO1xuICAgICAgICAgICAgICByZXR1cm4gZS53aGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgKSA6IHI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZS5mYWxsYmFjaztcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIEx0KGUpIHtcbiAgbGV0IHQgPSAhMTtcbiAgY29uc3QgbiA9IChzLCBsKSA9PiAodCA/IHNbMV0gPT09IGxbMV0gOiAhc1sxXSA9PSAhbFsxXSkgJiYgc1syXSA9PT0gbFsyXSwgaSA9IHd0KCgpID0+IGUuY2hpbGRyZW4pLCByID0gRihcbiAgICAoKSA9PiB7XG4gICAgICBsZXQgcyA9IGkoKTtcbiAgICAgIEFycmF5LmlzQXJyYXkocykgfHwgKHMgPSBbc10pO1xuICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGNvbnN0IG8gPSBzW2xdLndoZW47XG4gICAgICAgIGlmIChvKVxuICAgICAgICAgIHJldHVybiB0ID0gISFzW2xdLmtleWVkLCBbbCwgbywgc1tsXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gWy0xXTtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICB7XG4gICAgICBlcXVhbHM6IG5cbiAgICB9XG4gICk7XG4gIHJldHVybiBGKFxuICAgICgpID0+IHtcbiAgICAgIGNvbnN0IFtzLCBsLCBvXSA9IHIoKTtcbiAgICAgIGlmIChzIDwgMClcbiAgICAgICAgcmV0dXJuIGUuZmFsbGJhY2s7XG4gICAgICBjb25zdCBjID0gby5jaGlsZHJlbjtcbiAgICAgIHJldHVybiB0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIgJiYgYy5sZW5ndGggPiAwID8gVChcbiAgICAgICAgKCkgPT4gYyhcbiAgICAgICAgICB0ID8gbCA6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChUKHIpWzBdICE9PSBzKVxuICAgICAgICAgICAgICB0aHJvdyBWZShcIk1hdGNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG8ud2hlbjtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICkgOiBjO1xuICAgIH0sXG4gICAgdm9pZCAwLFxuICAgIHZvaWQgMFxuICApO1xufVxuZnVuY3Rpb24gcGUoZSkge1xuICByZXR1cm4gZTtcbn1cbmNvbnN0IE90ID0gW1xuICBcImFsbG93ZnVsbHNjcmVlblwiLFxuICBcImFzeW5jXCIsXG4gIFwiYXV0b2ZvY3VzXCIsXG4gIFwiYXV0b3BsYXlcIixcbiAgXCJjaGVja2VkXCIsXG4gIFwiY29udHJvbHNcIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwiZGlzYWJsZWRcIixcbiAgXCJmb3Jtbm92YWxpZGF0ZVwiLFxuICBcImhpZGRlblwiLFxuICBcImluZGV0ZXJtaW5hdGVcIixcbiAgXCJpbmVydFwiLFxuICBcImlzbWFwXCIsXG4gIFwibG9vcFwiLFxuICBcIm11bHRpcGxlXCIsXG4gIFwibXV0ZWRcIixcbiAgXCJub21vZHVsZVwiLFxuICBcIm5vdmFsaWRhdGVcIixcbiAgXCJvcGVuXCIsXG4gIFwicGxheXNpbmxpbmVcIixcbiAgXCJyZWFkb25seVwiLFxuICBcInJlcXVpcmVkXCIsXG4gIFwicmV2ZXJzZWRcIixcbiAgXCJzZWFtbGVzc1wiLFxuICBcInNlbGVjdGVkXCJcbl0sIGp0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImNsYXNzTmFtZVwiLFxuICBcInZhbHVlXCIsXG4gIFwicmVhZE9ubHlcIixcbiAgXCJmb3JtTm9WYWxpZGF0ZVwiLFxuICBcImlzTWFwXCIsXG4gIFwibm9Nb2R1bGVcIixcbiAgXCJwbGF5c0lubGluZVwiLFxuICAuLi5PdFxuXSksIFR0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcImlubmVySFRNTFwiLFxuICBcInRleHRDb250ZW50XCIsXG4gIFwiaW5uZXJUZXh0XCIsXG4gIFwiY2hpbGRyZW5cIlxuXSksIE50ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCJcbn0pLCB6dCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIGNsYXNzOiBcImNsYXNzTmFtZVwiLFxuICBmb3Jtbm92YWxpZGF0ZToge1xuICAgICQ6IFwiZm9ybU5vVmFsaWRhdGVcIixcbiAgICBCVVRUT046IDEsXG4gICAgSU5QVVQ6IDFcbiAgfSxcbiAgaXNtYXA6IHtcbiAgICAkOiBcImlzTWFwXCIsXG4gICAgSU1HOiAxXG4gIH0sXG4gIG5vbW9kdWxlOiB7XG4gICAgJDogXCJub01vZHVsZVwiLFxuICAgIFNDUklQVDogMVxuICB9LFxuICBwbGF5c2lubGluZToge1xuICAgICQ6IFwicGxheXNJbmxpbmVcIixcbiAgICBWSURFTzogMVxuICB9LFxuICByZWFkb25seToge1xuICAgICQ6IFwicmVhZE9ubHlcIixcbiAgICBJTlBVVDogMSxcbiAgICBURVhUQVJFQTogMVxuICB9XG59KTtcbmZ1bmN0aW9uIFJ0KGUsIHQpIHtcbiAgY29uc3QgbiA9IHp0W2VdO1xuICByZXR1cm4gdHlwZW9mIG4gPT0gXCJvYmplY3RcIiA/IG5bdF0gPyBuLiQgOiB2b2lkIDAgOiBuO1xufVxuY29uc3QgSXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYmVmb3JlaW5wdXRcIixcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwiY29udGV4dG1lbnVcIixcbiAgXCJmb2N1c2luXCIsXG4gIFwiZm9jdXNvdXRcIixcbiAgXCJpbnB1dFwiLFxuICBcImtleWRvd25cIixcbiAgXCJrZXl1cFwiLFxuICBcIm1vdXNlZG93blwiLFxuICBcIm1vdXNlbW92ZVwiLFxuICBcIm1vdXNlb3V0XCIsXG4gIFwibW91c2VvdmVyXCIsXG4gIFwibW91c2V1cFwiLFxuICBcInBvaW50ZXJkb3duXCIsXG4gIFwicG9pbnRlcm1vdmVcIixcbiAgXCJwb2ludGVyb3V0XCIsXG4gIFwicG9pbnRlcm92ZXJcIixcbiAgXCJwb2ludGVydXBcIixcbiAgXCJ0b3VjaGVuZFwiLFxuICBcInRvdWNobW92ZVwiLFxuICBcInRvdWNoc3RhcnRcIlxuXSksIEZ0ID0ge1xuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIlxufTtcbmZ1bmN0aW9uIE10KGUsIHQsIG4pIHtcbiAgbGV0IGkgPSBuLmxlbmd0aCwgciA9IHQubGVuZ3RoLCBzID0gaSwgbCA9IDAsIG8gPSAwLCBjID0gdFtyIC0gMV0ubmV4dFNpYmxpbmcsIGYgPSBudWxsO1xuICBmb3IgKDsgbCA8IHIgfHwgbyA8IHM7ICkge1xuICAgIGlmICh0W2xdID09PSBuW29dKSB7XG4gICAgICBsKyssIG8rKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKDsgdFtyIC0gMV0gPT09IG5bcyAtIDFdOyApXG4gICAgICByLS0sIHMtLTtcbiAgICBpZiAociA9PT0gbCkge1xuICAgICAgY29uc3QgYSA9IHMgPCBpID8gbyA/IG5bbyAtIDFdLm5leHRTaWJsaW5nIDogbltzIC0gb10gOiBjO1xuICAgICAgZm9yICg7IG8gPCBzOyApXG4gICAgICAgIGUuaW5zZXJ0QmVmb3JlKG5bbysrXSwgYSk7XG4gICAgfSBlbHNlIGlmIChzID09PSBvKVxuICAgICAgZm9yICg7IGwgPCByOyApXG4gICAgICAgICghZiB8fCAhZi5oYXModFtsXSkpICYmIHRbbF0ucmVtb3ZlKCksIGwrKztcbiAgICBlbHNlIGlmICh0W2xdID09PSBuW3MgLSAxXSAmJiBuW29dID09PSB0W3IgLSAxXSkge1xuICAgICAgY29uc3QgYSA9IHRbLS1yXS5uZXh0U2libGluZztcbiAgICAgIGUuaW5zZXJ0QmVmb3JlKG5bbysrXSwgdFtsKytdLm5leHRTaWJsaW5nKSwgZS5pbnNlcnRCZWZvcmUoblstLXNdLCBhKSwgdFtyXSA9IG5bc107XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghZikge1xuICAgICAgICBmID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IHUgPSBvO1xuICAgICAgICBmb3IgKDsgdSA8IHM7IClcbiAgICAgICAgICBmLnNldChuW3VdLCB1KyspO1xuICAgICAgfVxuICAgICAgY29uc3QgYSA9IGYuZ2V0KHRbbF0pO1xuICAgICAgaWYgKGEgIT0gbnVsbClcbiAgICAgICAgaWYgKG8gPCBhICYmIGEgPCBzKSB7XG4gICAgICAgICAgbGV0IHUgPSBsLCBkID0gMSwgaDtcbiAgICAgICAgICBmb3IgKDsgKyt1IDwgciAmJiB1IDwgcyAmJiAhKChoID0gZi5nZXQodFt1XSkpID09IG51bGwgfHwgaCAhPT0gYSArIGQpOyApXG4gICAgICAgICAgICBkKys7XG4gICAgICAgICAgaWYgKGQgPiBhIC0gbykge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRbbF07XG4gICAgICAgICAgICBmb3IgKDsgbyA8IGE7IClcbiAgICAgICAgICAgICAgZS5pbnNlcnRCZWZvcmUobltvKytdLCB2KTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGUucmVwbGFjZUNoaWxkKG5bbysrXSwgdFtsKytdKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbCsrO1xuICAgICAgZWxzZVxuICAgICAgICB0W2wrK10ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5jb25zdCBMZSA9IFwiXyREWF9ERUxFR0FURVwiO1xuZnVuY3Rpb24gQyhlLCB0LCBuKSB7XG4gIGxldCBpO1xuICBjb25zdCByID0gKCkgPT4ge1xuICAgIGNvbnN0IGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgcmV0dXJuIGwuaW5uZXJIVE1MID0gZSwgbiA/IGwuY29udGVudC5maXJzdENoaWxkLmZpcnN0Q2hpbGQgOiBsLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgfSwgcyA9IHQgPyAoKSA9PiBUKCgpID0+IGRvY3VtZW50LmltcG9ydE5vZGUoaSB8fCAoaSA9IHIoKSksICEwKSkgOiAoKSA9PiAoaSB8fCAoaSA9IHIoKSkpLmNsb25lTm9kZSghMCk7XG4gIHJldHVybiBzLmNsb25lTm9kZSA9IHMsIHM7XG59XG5mdW5jdGlvbiBLdChlLCB0ID0gd2luZG93LmRvY3VtZW50KSB7XG4gIGNvbnN0IG4gPSB0W0xlXSB8fCAodFtMZV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgZm9yIChsZXQgaSA9IDAsIHIgPSBlLmxlbmd0aDsgaSA8IHI7IGkrKykge1xuICAgIGNvbnN0IHMgPSBlW2ldO1xuICAgIG4uaGFzKHMpIHx8IChuLmFkZChzKSwgdC5hZGRFdmVudExpc3RlbmVyKHMsIEh0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIE4oZSwgdCwgbikge1xuICBuID09IG51bGwgPyBlLnJlbW92ZUF0dHJpYnV0ZSh0KSA6IGUuc2V0QXR0cmlidXRlKHQsIG4pO1xufVxuZnVuY3Rpb24gQnQoZSwgdCwgbiwgaSkge1xuICBpID09IG51bGwgPyBlLnJlbW92ZUF0dHJpYnV0ZU5TKHQsIG4pIDogZS5zZXRBdHRyaWJ1dGVOUyh0LCBuLCBpKTtcbn1cbmZ1bmN0aW9uIER0KGUsIHQpIHtcbiAgdCA9PSBudWxsID8gZS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKSA6IGUuY2xhc3NOYW1lID0gdDtcbn1cbmZ1bmN0aW9uIFV0KGUsIHQsIG4sIGkpIHtcbiAgaWYgKGkpXG4gICAgQXJyYXkuaXNBcnJheShuKSA/IChlW2AkJCR7dH1gXSA9IG5bMF0sIGVbYCQkJHt0fURhdGFgXSA9IG5bMV0pIDogZVtgJCQke3R9YF0gPSBuO1xuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG4pKSB7XG4gICAgY29uc3QgciA9IG5bMF07XG4gICAgZS5hZGRFdmVudExpc3RlbmVyKHQsIG5bMF0gPSAocykgPT4gci5jYWxsKGUsIG5bMV0sIHMpKTtcbiAgfSBlbHNlXG4gICAgZS5hZGRFdmVudExpc3RlbmVyKHQsIG4pO1xufVxuZnVuY3Rpb24gV3QoZSwgdCwgbiA9IHt9KSB7XG4gIGNvbnN0IGkgPSBPYmplY3Qua2V5cyh0IHx8IHt9KSwgciA9IE9iamVjdC5rZXlzKG4pO1xuICBsZXQgcywgbDtcbiAgZm9yIChzID0gMCwgbCA9IHIubGVuZ3RoOyBzIDwgbDsgcysrKSB7XG4gICAgY29uc3QgbyA9IHJbc107XG4gICAgIW8gfHwgbyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0W29dIHx8IChPZShlLCBvLCAhMSksIGRlbGV0ZSBuW29dKTtcbiAgfVxuICBmb3IgKHMgPSAwLCBsID0gaS5sZW5ndGg7IHMgPCBsOyBzKyspIHtcbiAgICBjb25zdCBvID0gaVtzXSwgYyA9ICEhdFtvXTtcbiAgICAhbyB8fCBvID09PSBcInVuZGVmaW5lZFwiIHx8IG5bb10gPT09IGMgfHwgIWMgfHwgKE9lKGUsIG8sICEwKSwgbltvXSA9IGMpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gTChlLCB0LCBuKSB7XG4gIGlmICghdClcbiAgICByZXR1cm4gbiA/IE4oZSwgXCJzdHlsZVwiKSA6IHQ7XG4gIGNvbnN0IGkgPSBlLnN0eWxlO1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gaS5jc3NUZXh0ID0gdDtcbiAgdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiAoaS5jc3NUZXh0ID0gbiA9IHZvaWQgMCksIG4gfHwgKG4gPSB7fSksIHQgfHwgKHQgPSB7fSk7XG4gIGxldCByLCBzO1xuICBmb3IgKHMgaW4gbilcbiAgICB0W3NdID09IG51bGwgJiYgaS5yZW1vdmVQcm9wZXJ0eShzKSwgZGVsZXRlIG5bc107XG4gIGZvciAocyBpbiB0KVxuICAgIHIgPSB0W3NdLCByICE9PSBuW3NdICYmIChpLnNldFByb3BlcnR5KHMsIHIpLCBuW3NdID0gcik7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gVnQoZSwgdCA9IHt9LCBuLCBpKSB7XG4gIGNvbnN0IHIgPSB7fTtcbiAgcmV0dXJuIGkgfHwgQShcbiAgICAoKSA9PiByLmNoaWxkcmVuID0gVShlLCB0LmNoaWxkcmVuLCByLmNoaWxkcmVuKVxuICApLCBBKCgpID0+IHQucmVmICYmIHQucmVmKGUpKSwgQSgoKSA9PiBYdChlLCB0LCBuLCAhMCwgciwgITApKSwgcjtcbn1cbmZ1bmN0aW9uIHllKGUsIHQsIG4pIHtcbiAgcmV0dXJuIFQoKCkgPT4gZSh0LCBuKSk7XG59XG5mdW5jdGlvbiBiKGUsIHQsIG4sIGkpIHtcbiAgaWYgKG4gIT09IHZvaWQgMCAmJiAhaSAmJiAoaSA9IFtdKSwgdHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBVKGUsIHQsIGksIG4pO1xuICBBKChyKSA9PiBVKGUsIHQoKSwgciwgbiksIGkpO1xufVxuZnVuY3Rpb24gWHQoZSwgdCwgbiwgaSwgciA9IHt9LCBzID0gITEpIHtcbiAgdCB8fCAodCA9IHt9KTtcbiAgZm9yIChjb25zdCBsIGluIHIpXG4gICAgaWYgKCEobCBpbiB0KSkge1xuICAgICAgaWYgKGwgPT09IFwiY2hpbGRyZW5cIilcbiAgICAgICAgY29udGludWU7XG4gICAgICByW2xdID0gamUoZSwgbCwgbnVsbCwgcltsXSwgbiwgcyk7XG4gICAgfVxuICBmb3IgKGNvbnN0IGwgaW4gdCkge1xuICAgIGlmIChsID09PSBcImNoaWxkcmVuXCIpIHtcbiAgICAgIGkgfHwgVShlLCB0LmNoaWxkcmVuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvID0gdFtsXTtcbiAgICByW2xdID0gamUoZSwgbCwgbywgcltsXSwgbiwgcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHF0KGUpIHtcbiAgcmV0dXJuIGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFthLXpdKS9nLCAodCwgbikgPT4gbi50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIE9lKGUsIHQsIG4pIHtcbiAgY29uc3QgaSA9IHQudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gIGZvciAobGV0IHIgPSAwLCBzID0gaS5sZW5ndGg7IHIgPCBzOyByKyspXG4gICAgZS5jbGFzc0xpc3QudG9nZ2xlKGlbcl0sIG4pO1xufVxuZnVuY3Rpb24gamUoZSwgdCwgbiwgaSwgciwgcykge1xuICBsZXQgbCwgbywgYywgZiwgYTtcbiAgaWYgKHQgPT09IFwic3R5bGVcIilcbiAgICByZXR1cm4gTChlLCBuLCBpKTtcbiAgaWYgKHQgPT09IFwiY2xhc3NMaXN0XCIpXG4gICAgcmV0dXJuIFd0KGUsIG4sIGkpO1xuICBpZiAobiA9PT0gaSlcbiAgICByZXR1cm4gaTtcbiAgaWYgKHQgPT09IFwicmVmXCIpXG4gICAgcyB8fCBuKGUpO1xuICBlbHNlIGlmICh0LnNsaWNlKDAsIDMpID09PSBcIm9uOlwiKSB7XG4gICAgY29uc3QgdSA9IHQuc2xpY2UoMyk7XG4gICAgaSAmJiBlLnJlbW92ZUV2ZW50TGlzdGVuZXIodSwgaSksIG4gJiYgZS5hZGRFdmVudExpc3RlbmVyKHUsIG4pO1xuICB9IGVsc2UgaWYgKHQuc2xpY2UoMCwgMTApID09PSBcIm9uY2FwdHVyZTpcIikge1xuICAgIGNvbnN0IHUgPSB0LnNsaWNlKDEwKTtcbiAgICBpICYmIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcih1LCBpLCAhMCksIG4gJiYgZS5hZGRFdmVudExpc3RlbmVyKHUsIG4sICEwKTtcbiAgfSBlbHNlIGlmICh0LnNsaWNlKDAsIDIpID09PSBcIm9uXCIpIHtcbiAgICBjb25zdCB1ID0gdC5zbGljZSgyKS50b0xvd2VyQ2FzZSgpLCBkID0gSXQuaGFzKHUpO1xuICAgIGlmICghZCAmJiBpKSB7XG4gICAgICBjb25zdCBoID0gQXJyYXkuaXNBcnJheShpKSA/IGlbMF0gOiBpO1xuICAgICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKHUsIGgpO1xuICAgIH1cbiAgICAoZCB8fCBuKSAmJiAoVXQoZSwgdSwgbiwgZCksIGQgJiYgS3QoW3VdKSk7XG4gIH0gZWxzZSBpZiAodC5zbGljZSgwLCA1KSA9PT0gXCJhdHRyOlwiKVxuICAgIE4oZSwgdC5zbGljZSg1KSwgbik7XG4gIGVsc2UgaWYgKChhID0gdC5zbGljZSgwLCA1KSA9PT0gXCJwcm9wOlwiKSB8fCAoYyA9IFR0Lmhhcyh0KSkgfHwgIXIgJiYgKChmID0gUnQodCwgZS50YWdOYW1lKSkgfHwgKG8gPSBqdC5oYXModCkpKSB8fCAobCA9IGUubm9kZU5hbWUuaW5jbHVkZXMoXCItXCIpKSlcbiAgICBhICYmICh0ID0gdC5zbGljZSg1KSwgbyA9ICEwKSwgdCA9PT0gXCJjbGFzc1wiIHx8IHQgPT09IFwiY2xhc3NOYW1lXCIgPyBEdChlLCBuKSA6IGwgJiYgIW8gJiYgIWMgPyBlW3F0KHQpXSA9IG4gOiBlW2YgfHwgdF0gPSBuO1xuICBlbHNlIHtcbiAgICBjb25zdCB1ID0gciAmJiB0LmluZGV4T2YoXCI6XCIpID4gLTEgJiYgRnRbdC5zcGxpdChcIjpcIilbMF1dO1xuICAgIHUgPyBCdChlLCB1LCB0LCBuKSA6IE4oZSwgTnRbdF0gfHwgdCwgbik7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBIdChlKSB7XG4gIGNvbnN0IHQgPSBgJCQke2UudHlwZX1gO1xuICBsZXQgbiA9IGUuY29tcG9zZWRQYXRoICYmIGUuY29tcG9zZWRQYXRoKClbMF0gfHwgZS50YXJnZXQ7XG4gIGZvciAoZS50YXJnZXQgIT09IG4gJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwidGFyZ2V0XCIsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHZhbHVlOiBuXG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJjdXJyZW50VGFyZ2V0XCIsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBuIHx8IGRvY3VtZW50O1xuICAgIH1cbiAgfSk7IG47ICkge1xuICAgIGNvbnN0IGkgPSBuW3RdO1xuICAgIGlmIChpICYmICFuLmRpc2FibGVkKSB7XG4gICAgICBjb25zdCByID0gbltgJHt0fURhdGFgXTtcbiAgICAgIGlmIChyICE9PSB2b2lkIDAgPyBpLmNhbGwobiwgciwgZSkgOiBpLmNhbGwobiwgZSksIGUuY2FuY2VsQnViYmxlKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG4gPSBuLl8kaG9zdCB8fCBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICB9XG59XG5mdW5jdGlvbiBVKGUsIHQsIG4sIGksIHIpIHtcbiAgZm9yICg7IHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIjsgKVxuICAgIG4gPSBuKCk7XG4gIGlmICh0ID09PSBuKVxuICAgIHJldHVybiBuO1xuICBjb25zdCBzID0gdHlwZW9mIHQsIGwgPSBpICE9PSB2b2lkIDA7XG4gIGlmIChlID0gbCAmJiBuWzBdICYmIG5bMF0ucGFyZW50Tm9kZSB8fCBlLCBzID09PSBcInN0cmluZ1wiIHx8IHMgPT09IFwibnVtYmVyXCIpXG4gICAgaWYgKHMgPT09IFwibnVtYmVyXCIgJiYgKHQgPSB0LnRvU3RyaW5nKCkpLCBsKSB7XG4gICAgICBsZXQgbyA9IG5bMF07XG4gICAgICBvICYmIG8ubm9kZVR5cGUgPT09IDMgPyBvLmRhdGEgIT09IHQgJiYgKG8uZGF0YSA9IHQpIDogbyA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHQpLCBuID0gRChlLCBuLCBpLCBvKTtcbiAgICB9IGVsc2VcbiAgICAgIG4gIT09IFwiXCIgJiYgdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiA/IG4gPSBlLmZpcnN0Q2hpbGQuZGF0YSA9IHQgOiBuID0gZS50ZXh0Q29udGVudCA9IHQ7XG4gIGVsc2UgaWYgKHQgPT0gbnVsbCB8fCBzID09PSBcImJvb2xlYW5cIilcbiAgICBuID0gRChlLCBuLCBpKTtcbiAgZWxzZSB7XG4gICAgaWYgKHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiBBKCgpID0+IHtcbiAgICAgICAgbGV0IG8gPSB0KCk7XG4gICAgICAgIGZvciAoOyB0eXBlb2YgbyA9PSBcImZ1bmN0aW9uXCI7IClcbiAgICAgICAgICBvID0gbygpO1xuICAgICAgICBuID0gVShlLCBvLCBuLCBpKTtcbiAgICAgIH0pLCAoKSA9PiBuO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgICBjb25zdCBvID0gW10sIGMgPSBuICYmIEFycmF5LmlzQXJyYXkobik7XG4gICAgICBpZiAod2UobywgdCwgbiwgcikpXG4gICAgICAgIHJldHVybiBBKCgpID0+IG4gPSBVKGUsIG8sIG4sIGksICEwKSksICgpID0+IG47XG4gICAgICBpZiAoby5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKG4gPSBEKGUsIG4sIGkpLCBsKVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGMgPyBuLmxlbmd0aCA9PT0gMCA/IFRlKGUsIG8sIGkpIDogTXQoZSwgbiwgbykgOiAobiAmJiBEKGUpLCBUZShlLCBvKSk7XG4gICAgICBuID0gbztcbiAgICB9IGVsc2UgaWYgKHQubm9kZVR5cGUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKSB7XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgIHJldHVybiBuID0gRChlLCBuLCBpLCB0KTtcbiAgICAgICAgRChlLCBuLCBudWxsLCB0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBuID09IG51bGwgfHwgbiA9PT0gXCJcIiB8fCAhZS5maXJzdENoaWxkID8gZS5hcHBlbmRDaGlsZCh0KSA6IGUucmVwbGFjZUNoaWxkKHQsIGUuZmlyc3RDaGlsZCk7XG4gICAgICBuID0gdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB3ZShlLCB0LCBuLCBpKSB7XG4gIGxldCByID0gITE7XG4gIGZvciAobGV0IHMgPSAwLCBsID0gdC5sZW5ndGg7IHMgPCBsOyBzKyspIHtcbiAgICBsZXQgbyA9IHRbc10sIGMgPSBuICYmIG5bZS5sZW5ndGhdLCBmO1xuICAgIGlmICghKG8gPT0gbnVsbCB8fCBvID09PSAhMCB8fCBvID09PSAhMSkpXG4gICAgICBpZiAoKGYgPSB0eXBlb2YgbykgPT0gXCJvYmplY3RcIiAmJiBvLm5vZGVUeXBlKVxuICAgICAgICBlLnB1c2gobyk7XG4gICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG8pKVxuICAgICAgICByID0gd2UoZSwgbywgYykgfHwgcjtcbiAgICAgIGVsc2UgaWYgKGYgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBmb3IgKDsgdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiOyApXG4gICAgICAgICAgICBvID0gbygpO1xuICAgICAgICAgIHIgPSB3ZShcbiAgICAgICAgICAgIGUsXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KG8pID8gbyA6IFtvXSxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoYykgPyBjIDogW2NdXG4gICAgICAgICAgKSB8fCByO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBlLnB1c2gobyksIHIgPSAhMDtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBhID0gU3RyaW5nKG8pO1xuICAgICAgICBjICYmIGMubm9kZVR5cGUgPT09IDMgJiYgYy5kYXRhID09PSBhID8gZS5wdXNoKGMpIDogZS5wdXNoKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFRlKGUsIHQsIG4gPSBudWxsKSB7XG4gIGZvciAobGV0IGkgPSAwLCByID0gdC5sZW5ndGg7IGkgPCByOyBpKyspXG4gICAgZS5pbnNlcnRCZWZvcmUodFtpXSwgbik7XG59XG5mdW5jdGlvbiBEKGUsIHQsIG4sIGkpIHtcbiAgaWYgKG4gPT09IHZvaWQgMClcbiAgICByZXR1cm4gZS50ZXh0Q29udGVudCA9IFwiXCI7XG4gIGNvbnN0IHIgPSBpIHx8IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICBpZiAodC5sZW5ndGgpIHtcbiAgICBsZXQgcyA9ICExO1xuICAgIGZvciAobGV0IGwgPSB0Lmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tKSB7XG4gICAgICBjb25zdCBvID0gdFtsXTtcbiAgICAgIGlmIChyICE9PSBvKSB7XG4gICAgICAgIGNvbnN0IGMgPSBvLnBhcmVudE5vZGUgPT09IGU7XG4gICAgICAgICFzICYmICFsID8gYyA/IGUucmVwbGFjZUNoaWxkKHIsIG8pIDogZS5pbnNlcnRCZWZvcmUociwgbikgOiBjICYmIG8ucmVtb3ZlKCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcyA9ICEwO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgZS5pbnNlcnRCZWZvcmUociwgbik7XG4gIHJldHVybiBbcl07XG59XG5mdW5jdGlvbiBZdChlKSB7XG4gIGNvbnN0IHQgPSBPYmplY3Qua2V5cyhlKSwgbiA9IHt9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbciwgc10gPSBqKGVbdFtpXV0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCB0W2ldLCB7XG4gICAgICBnZXQ6IHIsXG4gICAgICBzZXQobCkge1xuICAgICAgICBzKCgpID0+IGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gR3QoZSkge1xuICBpZiAoZS5hc3NpZ25lZFNsb3QgJiYgZS5hc3NpZ25lZFNsb3QuXyRvd25lcilcbiAgICByZXR1cm4gZS5hc3NpZ25lZFNsb3QuXyRvd25lcjtcbiAgbGV0IHQgPSBlLnBhcmVudE5vZGU7XG4gIGZvciAoOyB0ICYmICF0Ll8kb3duZXIgJiYgISh0LmFzc2lnbmVkU2xvdCAmJiB0LmFzc2lnbmVkU2xvdC5fJG93bmVyKTsgKVxuICAgIHQgPSB0LnBhcmVudE5vZGU7XG4gIHJldHVybiB0ICYmIHQuYXNzaWduZWRTbG90ID8gdC5hc3NpZ25lZFNsb3QuXyRvd25lciA6IGUuXyRvd25lcjtcbn1cbmZ1bmN0aW9uIFp0KGUpIHtcbiAgcmV0dXJuICh0LCBuKSA9PiB7XG4gICAgY29uc3QgeyBlbGVtZW50OiBpIH0gPSBuO1xuICAgIHJldHVybiBaKChyKSA9PiB7XG4gICAgICBjb25zdCBzID0gWXQodCk7XG4gICAgICBpLmFkZFByb3BlcnR5Q2hhbmdlZENhbGxiYWNrKChvLCBjKSA9PiBzW29dID0gYyksIGkuYWRkUmVsZWFzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaS5yZW5kZXJSb290LnRleHRDb250ZW50ID0gXCJcIiwgcigpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBsID0gZShzLCBuKTtcbiAgICAgIHJldHVybiBiKGkucmVuZGVyUm9vdCwgbCk7XG4gICAgfSwgR3QoaSkpO1xuICB9O1xufVxuZnVuY3Rpb24gSnQoZSwgdCwgbikge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAobiA9IHQsIHQgPSB7fSksIGh0KGUsIHQpKFp0KG4pKTtcbn1cbmNvbnN0IHZlID0gXCJzYXRzLWNvbm5lY3Rfd2FsbGV0LXByb3ZpZGVyLXNlbGVjdG9yX3NlbGVjdFwiLCB4ZSA9IFwic2F0cy1jb25uZWN0X3dhbGxldC1wcm92aWRlci1zZWxlY3Rvcl9jYW5jZWxcIiwgQ2UgPSBcInNhdHMtY29ubmVjdF93YWxsZXQtcHJvdmlkZXItc2VsZWN0b3Jfb3BlblwiLCBQZSA9IFwic2F0cy1jb25uZWN0X3dhbGxldC1wcm92aWRlci1zZWxlY3Rvcl9jbG9zZVwiLCBYZSA9IFwic2F0cy1jb25uZWN0X3dhbGxldC1wcm92aWRlci1zZWxlY3Rvcl93YWxsZXRPcGVuXCIsIHFlID0gXCJzYXRzLWNvbm5lY3Rfd2FsbGV0LXByb3ZpZGVyLXNlbGVjdG9yX3dhbGxldENsb3NlXCIsIHJlID0ge1xuICBjb2xvcjogXCIjMTgxODE4XCIsXG4gIFwiZm9udC1zaXplXCI6IFwiMThweFwiLFxuICBcImZvbnQtd2VpZ2h0XCI6IFwiNzAwXCIsXG4gIFwibGluZS1oZWlnaHRcIjogXCIxLjRcIlxufSwgVyA9IHtcbiAgY29sb3I6IFwiIzE4MTgxOFwiLFxuICBcImZvbnQtc2l6ZVwiOiBcIjE0cHhcIixcbiAgXCJmb250LXdlaWdodFwiOiBcIjQwMFwiLFxuICBcImxpbmUtaGVpZ2h0XCI6IFwiMS40XCJcbn0sIFF0ID0ge1xuICBjb2xvcjogXCIjMTgxODE4XCIsXG4gIFwiZm9udC1zaXplXCI6IFwiMTRweFwiLFxuICBcImZvbnQtd2VpZ2h0XCI6IFwiNTAwXCJcbn07XG52YXIgZW4gPSAvKiBAX19QVVJFX18gKi8gQygnPHN2ZyB3aWR0aD0yNCBoZWlnaHQ9MjQgdmlld0JveD1cIjAgMCAyNCAyNFwiZmlsbD1ub25lIHhtbG5zPWh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnPjxnIGlkPVhDaXJjbGU+PHBhdGggaWQ9VmVjdG9yIGQ9XCJNMTIgMi4yNUMxMC4wNzE2IDIuMjUgOC4xODY1NyAyLjgyMTgzIDYuNTgzMTkgMy44OTMxN0M0Ljk3OTgyIDQuOTY0NTEgMy43MzAxMyA2LjQ4NzI2IDIuOTkyMTggOC4yNjg4NEMyLjI1NDIyIDEwLjA1MDQgMi4wNjExNCAxMi4wMTA4IDIuNDM3MzUgMTMuOTAyMUMyLjgxMzU1IDE1Ljc5MzQgMy43NDIxNSAxNy41MzA3IDUuMTA1NzEgMTguODk0M0M2LjQ2OTI4IDIwLjI1NzkgOC4yMDY1NiAyMS4xODY1IDEwLjA5NzkgMjEuNTYyN0MxMS45ODkyIDIxLjkzODkgMTMuOTQ5NiAyMS43NDU4IDE1LjczMTIgMjEuMDA3OEMxNy41MTI3IDIwLjI2OTkgMTkuMDM1NSAxOS4wMjAyIDIwLjEwNjggMTcuNDE2OEMyMS4xNzgyIDE1LjgxMzQgMjEuNzUgMTMuOTI4NCAyMS43NSAxMkMyMS43NDUgOS40MTU2NiAyMC43MTYyIDYuOTM4NTkgMTguODg4OCA1LjExMTE4QzE3LjA2MTQgMy4yODM3OCAxNC41ODQzIDIuMjU0OTYgMTIgMi4yNVpNMTUuNTM0NCAxNC40NjU2QzE1LjY3NTIgMTQuNjA3OCAxNS43NTQyIDE0Ljc5OTkgMTUuNzU0MiAxNUMxNS43NTQyIDE1LjIwMDEgMTUuNjc1MiAxNS4zOTIyIDE1LjUzNDQgMTUuNTM0NEMxNS4zOTEgMTUuNjczIDE1LjE5OTQgMTUuNzUwNSAxNSAxNS43NTA1QzE0LjgwMDYgMTUuNzUwNSAxNC42MDkgMTUuNjczIDE0LjQ2NTYgMTUuNTM0NEwxMiAxMy4wNTk0TDkuNTM0MzggMTUuNTM0NEM5LjM5MTAyIDE1LjY3MyA5LjE5OTQyIDE1Ljc1MDUgOSAxNS43NTA1QzguODAwNTkgMTUuNzUwNSA4LjYwODk4IDE1LjY3MyA4LjQ2NTYzIDE1LjUzNDRDOC4zMjQ3OSAxNS4zOTIyIDguMjQ1NzggMTUuMjAwMSA4LjI0NTc4IDE1QzguMjQ1NzggMTQuNzk5OSA4LjMyNDc5IDE0LjYwNzggOC40NjU2MyAxNC40NjU2TDEwLjk0MDYgMTJMOC40NjU2MyA5LjUzNDM3QzguMzQ2MDMgOS4zODg2NSA4LjI4NDkxIDkuMjAzNjYgOC4yOTQxNiA5LjAxNTM3QzguMzAzNDEgOC44MjcwOCA4LjM4MjM2IDguNjQ4OTYgOC41MTU2NiA4LjUxNTY2QzguNjQ4OTYgOC4zODIzNiA4LjgyNzA4IDguMzAzNCA5LjAxNTM3IDguMjk0MTZDOS4yMDM2NiA4LjI4NDkxIDkuMzg4NjYgOC4zNDYwMyA5LjUzNDM4IDguNDY1NjNMMTIgMTAuOTQwNkwxNC40NjU2IDguNDY1NjNDMTQuNjExNCA4LjM0NjAzIDE0Ljc5NjMgOC4yODQ5MSAxNC45ODQ2IDguMjk0MTZDMTUuMTcyOSA4LjMwMzQgMTUuMzUxIDguMzgyMzYgMTUuNDg0MyA4LjUxNTY2QzE1LjYxNzYgOC42NDg5NiAxNS42OTY2IDguODI3MDggMTUuNzA1OCA5LjAxNTM3QzE1LjcxNTEgOS4yMDM2NiAxNS42NTQgOS4zODg2NSAxNS41MzQ0IDkuNTM0MzdMMTMuMDU5NCAxMkwxNS41MzQ0IDE0LjQ2NTZaXCJmaWxsPWJsYWNrIGZpbGwtb3BhY2l0eT0wLjM+JyksIHRuID0gLyogQF9fUFVSRV9fICovIEMoYDxzdHlsZT5cbiAgICAgICAgICAuY2xvc2Utc2VsZWN0b3ItYnV0dG9uOmZvY3VzLXZpc2libGUge1xuICAgICAgICAgICAgb3V0bGluZTogMnB4IHNvbGlkICMxODE4MTg7XG4gICAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTAuMjVweDtcbiAgICAgICAgICB9XG4gICAgICAgIGApLCBubiA9IC8qIEBfX1BVUkVfXyAqLyBDKFwiPGRpdiByb2xlPWJ1dHRvbiB0YWJpbmRleD0wIGNsYXNzPWNsb3NlLXNlbGVjdG9yLWJ1dHRvbj5cIik7XG5mdW5jdGlvbiBybihlKSB7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciB0ID0gZW4oKTtcbiAgICByZXR1cm4gdC5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJibG9ja1wiKSwgVnQodCwgZSwgITAsICEwKSwgdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIHNuKGUpIHtcbiAgZnVuY3Rpb24gdChuKSB7XG4gICAgKG4ua2V5ID09PSBcIkVudGVyXCIgfHwgbi5rZXkgPT09IFwiIFwiKSAmJiBlLm9uQ2xvc2UoKTtcbiAgfVxuICByZXR1cm4gW3RuKCksICgoKSA9PiB7XG4gICAgdmFyIG4gPSBubigpO1xuICAgIHJldHVybiBuLnN0eWxlLnNldFByb3BlcnR5KFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcInRvcFwiLCBcIjE2cHhcIiksIG4uc3R5bGUuc2V0UHJvcGVydHkoXCJyaWdodFwiLCBcIjE2cHhcIiksIG4uc3R5bGUuc2V0UHJvcGVydHkoXCJiYWNrZ3JvdW5kXCIsIFwibm9uZVwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcImJvcmRlclwiLCBcIm5vbmVcIiksIG4uc3R5bGUuc2V0UHJvcGVydHkoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpLCBuLnN0eWxlLnNldFByb3BlcnR5KFwicGFkZGluZ1wiLCBcIjBcIiksIG4uc3R5bGUuc2V0UHJvcGVydHkoXCJtYXJnaW5cIiwgXCIwXCIpLCBuLnN0eWxlLnNldFByb3BlcnR5KFwiYm9yZGVyLXJhZGl1c1wiLCBcIjUwJVwiKSwgbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZS5vbkNsb3NlKSwgbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0KSwgYihuLCBnKHJuLCB7fSkpLCBuO1xuICB9KSgpXTtcbn1cbnZhciBvbiA9IC8qIEBfX1BVUkVfXyAqLyBDKGA8c3R5bGU+XG4vKiEgbW9kZXJuLW5vcm1hbGl6ZSB2Mi4wLjAgfCBNSVQgTGljZW5zZSB8IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvbW9kZXJuLW5vcm1hbGl6ZSAqL1xuXG4vKlxuRG9jdW1lbnRcbj09PT09PT09XG4qL1xuXG4vKipcblVzZSBhIGJldHRlciBib3ggbW9kZWwgKG9waW5pb25hdGVkKS5cbiovXG5cbiosXG46OmJlZm9yZSxcbjo6YWZ0ZXIge1xuXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xuXHRtYXJnaW46IDA7IC8qIFJlbW92ZSBhbGwgbWFyZ2lucyBmcm9tIGV2ZXJ5d2hlcmUuICovXG59XG5cbjpob3N0IHtcblx0LyogSW1wcm92ZSBjb25zaXN0ZW5jeSBvZiBkZWZhdWx0IGZvbnRzIGluIGFsbCBicm93c2Vycy4gKGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvbW9kZXJuLW5vcm1hbGl6ZS9pc3N1ZXMvMykgKi9cblx0Zm9udC1mYW1pbHk6XG5cdFx0J0RNIFNhbnMnLCAvKiBOb3RlOiBub3QgcGFydCBvZiBtb2Rlcm4tbm9ybWFsaXplLCBhZGRlZCBzcGVjaWZpY2FsbHkgZm9yIHRoaXMgcHJvamVjdC4gKi9cblx0XHRzeXN0ZW0tdWksXG5cdFx0J1NlZ29lIFVJJyxcblx0XHRSb2JvdG8sXG5cdFx0SGVsdmV0aWNhLFxuXHRcdEFyaWFsLFxuXHRcdHNhbnMtc2VyaWYsXG5cdFx0J0FwcGxlIENvbG9yIEVtb2ppJyxcblx0XHQnU2Vnb2UgVUkgRW1vamknO1xuXHRsaW5lLWhlaWdodDogMS4xNTsgLyogMS4gQ29ycmVjdCB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLiAqL1xuXHQtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLiAqL1xuXHQtbW96LXRhYi1zaXplOiA0OyAvKiAzLiBVc2UgYSBtb3JlIHJlYWRhYmxlIHRhYiBzaXplIChvcGluaW9uYXRlZCkuICovXG5cdHRhYi1zaXplOiA0OyAvKiAzICovXG59XG5cbi8qXG5TZWN0aW9uc1xuPT09PT09PT1cbiovXG5cbjpob3N0IHtcblx0bWFyZ2luOiAwOyAvKiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuICovXG59XG5cbi8qXG5Hcm91cGluZyBjb250ZW50XG49PT09PT09PT09PT09PT09XG4qL1xuXG4vKipcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cbjIuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIG9mIGJvcmRlciBjb2xvciBpbiBGaXJlZm94LiAoaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkwNjU1KVxuKi9cblxuaHIge1xuXHRoZWlnaHQ6IDA7IC8qIDEgKi9cblx0Y29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cbn1cblxuLypcblRleHQtbGV2ZWwgc2VtYW50aWNzXG49PT09PT09PT09PT09PT09PT09PVxuKi9cblxuLyoqXG5BZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgYW5kIFNhZmFyaS5cbiovXG5cbmFiYnJbdGl0bGVdIHtcblx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xufVxuXG4vKipcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXG4qL1xuXG5iLFxuc3Ryb25nIHtcblx0Zm9udC13ZWlnaHQ6IGJvbGRlcjtcbn1cblxuLyoqXG4xLiBJbXByb3ZlIGNvbnNpc3RlbmN5IG9mIGRlZmF1bHQgZm9udHMgaW4gYWxsIGJyb3dzZXJzLiAoaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9tb2Rlcm4tbm9ybWFsaXplL2lzc3Vlcy8zKVxuMi4gQ29ycmVjdCB0aGUgb2RkICdlbScgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxuKi9cblxuY29kZSxcbmtiZCxcbnNhbXAsXG5wcmUge1xuXHRmb250LWZhbWlseTpcblx0XHR1aS1tb25vc3BhY2UsXG5cdFx0U0ZNb25vLVJlZ3VsYXIsXG5cdFx0Q29uc29sYXMsXG5cdFx0J0xpYmVyYXRpb24gTW9ubycsXG5cdFx0TWVubG8sXG5cdFx0bW9ub3NwYWNlOyAvKiAxICovXG5cdGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXG59XG5cbi8qKlxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXG4qL1xuXG5zbWFsbCB7XG5cdGZvbnQtc2l6ZTogODAlO1xufVxuXG4vKipcblByZXZlbnQgJ3N1YicgYW5kICdzdXAnIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXG4qL1xuXG5zdWIsXG5zdXAge1xuXHRmb250LXNpemU6IDc1JTtcblx0bGluZS1oZWlnaHQ6IDA7XG5cdHBvc2l0aW9uOiByZWxhdGl2ZTtcblx0dmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xufVxuXG5zdWIge1xuXHRib3R0b206IC0wLjI1ZW07XG59XG5cbnN1cCB7XG5cdHRvcDogLTAuNWVtO1xufVxuXG4vKlxuVGFidWxhciBkYXRhXG49PT09PT09PT09PT1cbiovXG5cbi8qKlxuMS4gUmVtb3ZlIHRleHQgaW5kZW50YXRpb24gZnJvbSB0YWJsZSBjb250ZW50cyBpbiBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk5OTA4OCwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIwMTI5NylcbjIuIENvcnJlY3QgdGFibGUgYm9yZGVyIGNvbG9yIGluaGVyaXRhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxuKi9cblxudGFibGUge1xuXHR0ZXh0LWluZGVudDogMDsgLyogMSAqL1xuXHRib3JkZXItY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cbn1cblxuLypcbkZvcm1zXG49PT09PVxuKi9cblxuLyoqXG4xLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cbiovXG5cbmJ1dHRvbixcbmlucHV0LFxub3B0Z3JvdXAsXG5zZWxlY3QsXG50ZXh0YXJlYSB7XG5cdGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXG5cdGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xuXHRsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xuXHRtYXJnaW46IDA7IC8qIDIgKi9cbn1cblxuLyoqXG5SZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UgYW5kIEZpcmVmb3guXG4qL1xuXG5idXR0b24sXG5zZWxlY3Qge1xuXHR0ZXh0LXRyYW5zZm9ybTogbm9uZTtcbn1cblxuLyoqXG5Db3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxuKi9cblxuYnV0dG9uLFxuW3R5cGU9J2J1dHRvbiddLFxuW3R5cGU9J3Jlc2V0J10sXG5bdHlwZT0nc3VibWl0J10ge1xuXHQtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcbn1cblxuLyoqXG5SZW1vdmUgdGhlIGlubmVyIGJvcmRlciBhbmQgcGFkZGluZyBpbiBGaXJlZm94LlxuKi9cblxuOjotbW96LWZvY3VzLWlubmVyIHtcblx0Ym9yZGVyLXN0eWxlOiBub25lO1xuXHRwYWRkaW5nOiAwO1xufVxuXG4vKipcblJlc3RvcmUgdGhlIGZvY3VzIHN0eWxlcyB1bnNldCBieSB0aGUgcHJldmlvdXMgcnVsZS5cbiovXG5cbjotbW96LWZvY3VzcmluZyB7XG5cdG91dGxpbmU6IDFweCBkb3R0ZWQgQnV0dG9uVGV4dDtcbn1cblxuLyoqXG5SZW1vdmUgdGhlIGFkZGl0aW9uYWwgJzppbnZhbGlkJyBzdHlsZXMgaW4gRmlyZWZveC5cblNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvZ2Vja28tZGV2L2Jsb2IvMmY5ZWFjZDlkM2Q5OTVjOTM3YjQyNTFhNTU1N2Q5NWQ0OTRjOWJlMS9sYXlvdXQvc3R5bGUvcmVzL2Zvcm1zLmNzcyNMNzI4LUw3MzdcbiovXG5cbjotbW96LXVpLWludmFsaWQge1xuXHRib3gtc2hhZG93OiBub25lO1xufVxuXG4vKipcblJlbW92ZSB0aGUgcGFkZGluZyBzbyBkZXZlbG9wZXJzIGFyZSBub3QgY2F1Z2h0IG91dCB3aGVuIHRoZXkgemVybyBvdXQgJ2ZpZWxkc2V0JyBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXG4qL1xuXG5sZWdlbmQge1xuXHRwYWRkaW5nOiAwO1xufVxuXG4vKipcbkFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lIGFuZCBGaXJlZm94LlxuKi9cblxucHJvZ3Jlc3Mge1xuXHR2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XG59XG5cbi8qKlxuQ29ycmVjdCB0aGUgY3Vyc29yIHN0eWxlIG9mIGluY3JlbWVudCBhbmQgZGVjcmVtZW50IGJ1dHRvbnMgaW4gU2FmYXJpLlxuKi9cblxuOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxuOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcblx0aGVpZ2h0OiBhdXRvO1xufVxuXG4vKipcbjEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxuMi4gQ29ycmVjdCB0aGUgb3V0bGluZSBzdHlsZSBpbiBTYWZhcmkuXG4qL1xuXG5bdHlwZT0nc2VhcmNoJ10ge1xuXHQtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xuXHRvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xufVxuXG4vKipcblJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cbiovXG5cbjo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XG5cdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbn1cblxuLyoqXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxuMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byAnaW5oZXJpdCcgaW4gU2FmYXJpLlxuKi9cblxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XG5cdC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXG5cdGZvbnQ6IGluaGVyaXQ7IC8qIDIgKi9cbn1cblxuLypcbkludGVyYWN0aXZlXG49PT09PT09PT09PVxuKi9cblxuLypcbkFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIENocm9tZSBhbmQgU2FmYXJpLlxuKi9cblxuc3VtbWFyeSB7XG5cdGRpc3BsYXk6IGxpc3QtaXRlbTtcbn1cbmApO1xuZnVuY3Rpb24gbG4oKSB7XG4gIHJldHVybiBvbigpO1xufVxudmFyIGFuID0gLyogQF9fUFVSRV9fICovIEMoXCI8ZGl2IGNsYXNzPWRpdmlkZXI+PGRpdj5cIik7XG5mdW5jdGlvbiBjbigpIHtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIGUgPSBhbigpLCB0ID0gZS5maXJzdENoaWxkO1xuICAgIHJldHVybiB0LnN0eWxlLnNldFByb3BlcnR5KFwiaGVpZ2h0XCIsIFwiMTAwJVwiKSwgdC5zdHlsZS5zZXRQcm9wZXJ0eShcIndpZHRoXCIsIFwiMXB4XCIpLCB0LnN0eWxlLnNldFByb3BlcnR5KFwiYmFja2dyb3VuZFwiLCBcIiNkY2RjZGNcIiksIGU7XG4gIH0pKCk7XG59XG52YXIgdW4gPSAvKiBAX19QVVJFX18gKi8gQyhcIjxkaXY+XCIpO1xuZnVuY3Rpb24gZG4oZSkge1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgdCA9IHVuKCk7XG4gICAgcmV0dXJuIHQuc3R5bGUuc2V0UHJvcGVydHkoXCJwYWRkaW5nXCIsIFwiMjRweFwiKSwgdC5zdHlsZS5zZXRQcm9wZXJ0eShcImhlaWdodFwiLCBcIjEwMCVcIiksIGIodCwgKCkgPT4gZS5jaGlsZHJlbiksIHQ7XG4gIH0pKCk7XG59XG52YXIgZm4gPSAvKiBAX19QVVJFX18gKi8gQyhcIjxkaXY+XCIpO1xuZnVuY3Rpb24gaG4oZSkge1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgdCA9IGZuKCk7XG4gICAgcmV0dXJuIHQuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwiZmxleFwiKSwgdC5zdHlsZS5zZXRQcm9wZXJ0eShcImZsZXgtZGlyZWN0aW9uXCIsIFwiY29sdW1uXCIpLCB0LnN0eWxlLnNldFByb3BlcnR5KFwianVzdGlmeS1jb250ZW50XCIsIFwiY2VudGVyXCIpLCB0LnN0eWxlLnNldFByb3BlcnR5KFwiYWxpZ24taXRlbXNcIiwgXCJjZW50ZXJcIiksIHQuc3R5bGUuc2V0UHJvcGVydHkoXCJoZWlnaHRcIiwgXCIxMDAlXCIpLCBiKHQsICgpID0+IGUuY2hpbGRyZW4pLCB0O1xuICB9KSgpO1xufVxudmFyIHBuID0gLyogQF9fUFVSRV9fICovIEMoXCI8ZGl2PjxkaXY+8J+klDwvZGl2PjxkaXY+V2hhdCBpcyBhIHdhbGxldD88L2Rpdj48cD5XYWxsZXRzIGxldCB5b3Ugc2VuZCwgcmVjZWl2ZSwgc3RvcmUgYW5kIGRpc3BsYXkgZGlnaXRhbCBhc3NldHMgbGlrZSBCaXRjb2luLCBTdGFja3MsIE9yZGluYWxzICYgTkZUcy48L3A+PHA+RXhwbG9yZSBCaXRjb2luIGFwcHMgYnkgY29ubmVjdGluZyB5b3VyIHdhbGxldC5cIik7XG5mdW5jdGlvbiB5bigpIHtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIGUgPSBwbigpLCB0ID0gZS5maXJzdENoaWxkLCBuID0gdC5uZXh0U2libGluZywgaSA9IG4ubmV4dFNpYmxpbmcsIHIgPSBpLm5leHRTaWJsaW5nO1xuICAgIHJldHVybiBlLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcImZsZXhcIiksIGUuc3R5bGUuc2V0UHJvcGVydHkoXCJmbGV4LWRpcmVjdGlvblwiLCBcImNvbHVtblwiKSwgZS5zdHlsZS5zZXRQcm9wZXJ0eShcInJvdy1nYXBcIiwgXCI4cHhcIiksIGUuc3R5bGUuc2V0UHJvcGVydHkoXCJqdXN0aWZ5LWNvbnRlbnRcIiwgXCJjZW50ZXJcIiksIGUuc3R5bGUuc2V0UHJvcGVydHkoXCJhbGlnbi1pdGVtc1wiLCBcImNlbnRlclwiKSwgdC5zdHlsZS5zZXRQcm9wZXJ0eShcImZvbnQtc2l6ZVwiLCBcIjUwcHhcIiksIHQuc3R5bGUuc2V0UHJvcGVydHkoXCJsaW5lLWhlaWdodFwiLCBcIjE0MCVcIiksIEEoKHMpID0+IHtcbiAgICAgIHZhciBsID0gcmUsIG8gPSBXLCBjID0gVztcbiAgICAgIHJldHVybiBzLmUgPSBMKG4sIGwsIHMuZSksIHMudCA9IEwoaSwgbywgcy50KSwgcy5hID0gTChyLCBjLCBzLmEpLCBzO1xuICAgIH0sIHtcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIHQ6IHZvaWQgMCxcbiAgICAgIGE6IHZvaWQgMFxuICAgIH0pLCBlO1xuICB9KSgpO1xufVxuZnVuY3Rpb24gU2UoZSkge1xuICB2YXIgbjtcbiAgY29uc3QgdCA9IChuID0gZS5pbnN0YWxsUHJvbXB0KSA9PSBudWxsID8gdm9pZCAwIDogbi51cmw7XG4gIGlmICghdCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJObyBpbnN0YWxsIHByb21wdCBVUkwgZm91bmQgZm9yXCIsIGUuaWQpO1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cub3Blbih0LCBcIl9ibGFua1wiKTtcbn1cbnZhciBnbiA9IC8qIEBfX1BVUkVfXyAqLyBDKGA8c3R5bGU+XG4gICAgICAgICAgLmluc3RhbGwtcHJvbXB0LWJ1dHRvbjpmb2N1cy12aXNpYmxlIHtcbiAgICAgICAgICAgIG91dGxpbmU6IDJweCBzb2xpZCAjMTgxODE4O1xuICAgICAgICAgICAgb3V0bGluZS1vZmZzZXQ6IDJweDtcbiAgICAgICAgICB9XG4gICAgICAgIGApLCBtbiA9IC8qIEBfX1BVUkVfXyAqLyBDKFwiPGRpdj48aW1nPjxoMT5Eb24ndCBoYXZlIDwhPj88L2gxPjxwPkRvd25sb2FkIGl0IG9uIHRoZSBDaHJvbWUgd2ViIHN0b3JlLjwvcD48ZGl2IGNsYXNzPWluc3RhbGwtcHJvbXB0LWJ1dHRvbiByb2xlPWJ1dHRvbiB0YWJpbmRleD0wPkdldFwiKTtcbmZ1bmN0aW9uIGJuKGUpIHtcbiAgZnVuY3Rpb24gdChpKSB7XG4gICAgKGkua2V5ID09PSBcIkVudGVyXCIgfHwgaS5rZXkgPT09IFwiIFwiKSAmJiBTZShlLm9wdGlvbik7XG4gIH1cbiAgZnVuY3Rpb24gbigpIHtcbiAgICBTZShlLm9wdGlvbik7XG4gIH1cbiAgcmV0dXJuIFtnbigpLCAoKCkgPT4ge1xuICAgIHZhciBpID0gbW4oKSwgciA9IGkuZmlyc3RDaGlsZCwgcyA9IHIubmV4dFNpYmxpbmcsIGwgPSBzLmZpcnN0Q2hpbGQsIG8gPSBsLm5leHRTaWJsaW5nO1xuICAgIG8ubmV4dFNpYmxpbmc7XG4gICAgdmFyIGMgPSBzLm5leHRTaWJsaW5nLCBmID0gYy5uZXh0U2libGluZztcbiAgICByZXR1cm4gaS5zdHlsZS5zZXRQcm9wZXJ0eShcImRpc3BsYXlcIiwgXCJmbGV4XCIpLCBpLnN0eWxlLnNldFByb3BlcnR5KFwiZmxleC1kaXJlY3Rpb25cIiwgXCJjb2x1bW5cIiksIGkuc3R5bGUuc2V0UHJvcGVydHkoXCJhbGlnbi1pdGVtc1wiLCBcImNlbnRlclwiKSwgaS5zdHlsZS5zZXRQcm9wZXJ0eShcInJvdy1nYXBcIiwgXCIxNnB4XCIpLCByLnN0eWxlLnNldFByb3BlcnR5KFwiYm9yZGVyLXJhZGl1c1wiLCBcIjEycHhcIiksIHIuc3R5bGUuc2V0UHJvcGVydHkoXCJoZWlnaHRcIiwgXCI2NHB4XCIpLCByLnN0eWxlLnNldFByb3BlcnR5KFwid2lkdGhcIiwgXCI2NHB4XCIpLCByLnN0eWxlLnNldFByb3BlcnR5KFwib2JqZWN0LWZpdFwiLCBcImNvdmVyXCIpLCBiKHMsICgpID0+IGUub3B0aW9uLm5hbWUsIG8pLCBmLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBuKSwgZi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0KSwgQSgoYSkgPT4ge1xuICAgICAgdmFyIHUgPSBlLm9wdGlvbi5pY29uLCBkID0gZS5vcHRpb24ubmFtZSwgaCA9IHtcbiAgICAgICAgLi4ucmUsXG4gICAgICAgIFwidGV4dC1hbGlnblwiOiBcImNlbnRlclwiXG4gICAgICB9LCB2ID0gVywgeSA9IHtcbiAgICAgICAgLi4uUXQsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICAgIFwiYm9yZGVyLXJhZGl1c1wiOiBcIjEycHhcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMTgxODE4XCIsXG4gICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgIHBhZGRpbmc6IFwiMTJweCAxNnB4XCJcbiAgICAgIH07XG4gICAgICByZXR1cm4gdSAhPT0gYS5lICYmIE4ociwgXCJzcmNcIiwgYS5lID0gdSksIGQgIT09IGEudCAmJiBOKHIsIFwiYWx0XCIsIGEudCA9IGQpLCBhLmEgPSBMKHMsIGgsIGEuYSksIGEubyA9IEwoYywgdiwgYS5vKSwgYS5pID0gTChmLCB5LCBhLmkpLCBhO1xuICAgIH0sIHtcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIHQ6IHZvaWQgMCxcbiAgICAgIGE6IHZvaWQgMCxcbiAgICAgIG86IHZvaWQgMCxcbiAgICAgIGk6IHZvaWQgMFxuICAgIH0pLCBpO1xuICB9KSgpXTtcbn1cbnZhciB3biA9IC8qIEBfX1BVUkVfXyAqLyBDKCc8c3ZnIHdpZHRoPTIwIGhlaWdodD0yMCB2aWV3Qm94PVwiMCAwIDIwIDIwXCJ4bWxucz1odHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zz48Y2lyY2xlIGN4PTEwIGN5PTEwIHI9OS4wNSBzdHJva2U9YmxhY2sgc3Ryb2tlLXdpZHRoPTEuOSBmaWxsPW5vbmUgc3Ryb2tlLWRhc2hhcnJheT1cIjQyLjY1IDE0LjIyXCJzdHJva2UtZGFzaG9mZnNldD0wPjxhbmltYXRlVHJhbnNmb3JtIGF0dHJpYnV0ZU5hbWU9dHJhbnNmb3JtIGF0dHJpYnV0ZVR5cGU9WE1MIHR5cGU9cm90YXRlIGZyb209XCIwIDEwIDEwXCJ0bz1cIjM2MCAxMCAxMFwiZHVyPTAuNzVzIHJlcGVhdENvdW50PWluZGVmaW5pdGU+JyksIHZuID0gLyogQF9fUFVSRV9fICovIEMoXCI8ZGl2PlwiKTtcbmNvbnN0IHhuID0gKCkgPT4gd24oKTtcbmZ1bmN0aW9uIENuKCkge1xuICByZXR1cm4gKCgpID0+IHtcbiAgICB2YXIgZSA9IHZuKCk7XG4gICAgcmV0dXJuIGUuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwiZmxleFwiKSwgZS5zdHlsZS5zZXRQcm9wZXJ0eShcImp1c3RpZnktY29udGVudFwiLCBcImNlbnRlclwiKSwgZS5zdHlsZS5zZXRQcm9wZXJ0eShcImFsaWduLWl0ZW1zXCIsIFwiY2VudGVyXCIpLCBlLnN0eWxlLnNldFByb3BlcnR5KFwiaGVpZ2h0XCIsIFwiMTAwJVwiKSwgZS5zdHlsZS5zZXRQcm9wZXJ0eShcImFuaW1hdGlvblwiLCBcInNwaW4gMXMgbGluZWFyIGluZmluaXRlXCIpLCBiKGUsIGcoeG4sIHt9KSksIGU7XG4gIH0pKCk7XG59XG52YXIgUG4gPSAvKiBAX19QVVJFX18gKi8gQyhcIjxkaXY+PGltZz48aDE+T3BlbmluZyA8IT4uLi48L2gxPjxwPkNvbmZpcm0gdGhlIG9wZXJhdGlvbiBpbiBcIik7XG5mdW5jdGlvbiBTbihlKSB7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIHZhciB0ID0gUG4oKSwgbiA9IHQuZmlyc3RDaGlsZCwgaSA9IG4ubmV4dFNpYmxpbmcsIHIgPSBpLmZpcnN0Q2hpbGQsIHMgPSByLm5leHRTaWJsaW5nO1xuICAgIHMubmV4dFNpYmxpbmc7XG4gICAgdmFyIGwgPSBpLm5leHRTaWJsaW5nO1xuICAgIHJldHVybiBsLmZpcnN0Q2hpbGQsIHQuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwiZmxleFwiKSwgdC5zdHlsZS5zZXRQcm9wZXJ0eShcImZsZXgtZGlyZWN0aW9uXCIsIFwiY29sdW1uXCIpLCB0LnN0eWxlLnNldFByb3BlcnR5KFwiYWxpZ24taXRlbXNcIiwgXCJjZW50ZXJcIiksIHQuc3R5bGUuc2V0UHJvcGVydHkoXCJyb3ctZ2FwXCIsIFwiMTZweFwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcImJvcmRlci1yYWRpdXNcIiwgXCIxMnB4XCIpLCBuLnN0eWxlLnNldFByb3BlcnR5KFwiaGVpZ2h0XCIsIFwiNjRweFwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcIndpZHRoXCIsIFwiNjRweFwiKSwgbi5zdHlsZS5zZXRQcm9wZXJ0eShcIm9iamVjdC1maXRcIiwgXCJjb3ZlclwiKSwgYihpLCAoKSA9PiBlLm9wdGlvbi5uYW1lLCBzKSwgYihsLCAoKSA9PiBlLm9wdGlvbi5uYW1lLCBudWxsKSwgYih0LCBnKENuLCB7fSksIG51bGwpLCBBKChvKSA9PiB7XG4gICAgICB2YXIgYyA9IGUub3B0aW9uLmljb24sIGYgPSBlLm9wdGlvbi5uYW1lLCBhID0ge1xuICAgICAgICAuLi5yZSxcbiAgICAgICAgXCJ0ZXh0LWFsaWduXCI6IFwiY2VudGVyXCJcbiAgICAgIH0sIHUgPSBXO1xuICAgICAgcmV0dXJuIGMgIT09IG8uZSAmJiBOKG4sIFwic3JjXCIsIG8uZSA9IGMpLCBmICE9PSBvLnQgJiYgTihuLCBcImFsdFwiLCBvLnQgPSBmKSwgby5hID0gTChpLCBhLCBvLmEpLCBvLm8gPSBMKGwsIHUsIG8ubyksIG87XG4gICAgfSwge1xuICAgICAgZTogdm9pZCAwLFxuICAgICAgdDogdm9pZCAwLFxuICAgICAgYTogdm9pZCAwLFxuICAgICAgbzogdm9pZCAwXG4gICAgfSksIHQ7XG4gIH0pKCk7XG59XG52YXIgX24gPSAvKiBAX19QVVJFX18gKi8gQyhcIjxkaXY+PGRpdiB0YWJpbmRleD0wPjxpbWc+PGRpdj5cIik7XG5mdW5jdGlvbiBFbihlKSB7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgZS5vblByb3ZpZGVyU2VsZWN0ZWQoZS5pZCk7XG4gIH1cbiAgY29uc3QgbiA9IEYoKCkgPT4ga2UoZSkgPyBcImJ1dHRvblwiIDogXCJsaW5rXCIpO1xuICBmdW5jdGlvbiBpKHUpIHtcbiAgICBpZiAobigpID09PSBcImxpbmtcIikge1xuICAgICAgdS5rZXkgPT09IFwiRW50ZXJcIiAmJiB0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuKCkgPT09IFwiYnV0dG9uXCIpIHtcbiAgICAgICh1LmtleSA9PT0gXCJFbnRlclwiIHx8IHUua2V5ID09PSBcIiBcIikgJiYgdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjb25zdCBbciwgc10gPSBqKCExKSwgW2wsIG9dID0gaighMSksIGMgPSAoKSA9PiByKCkgfHwgbCgpLCBmID0gXCJyZ2JhKDI0LCAyNCwgMjQsIDAuMjApXCIsIGEgPSBcInJnYmEoMjQsIDI0LCAyNCwgMC42MClcIjtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIHUgPSBfbigpLCBkID0gdS5maXJzdENoaWxkLCBoID0gZC5maXJzdENoaWxkLCB2ID0gaC5uZXh0U2libGluZztcbiAgICByZXR1cm4gdS5zdHlsZS5zZXRQcm9wZXJ0eShcImFzcGVjdC1yYXRpb1wiLCBcIjEgLyAxXCIpLCB1LnN0eWxlLnNldFByb3BlcnR5KFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIiksIGQuc3R5bGUuc2V0UHJvcGVydHkoXCJkaXNwbGF5XCIsIFwiZmxleFwiKSwgZC5zdHlsZS5zZXRQcm9wZXJ0eShcImZsZXgtZGlyZWN0aW9uXCIsIFwiY29sdW1uXCIpLCBkLnN0eWxlLnNldFByb3BlcnR5KFwicm93LWdhcFwiLCBcIjEycHhcIiksIGQuc3R5bGUuc2V0UHJvcGVydHkoXCJhbGlnbi1pdGVtc1wiLCBcImNlbnRlclwiKSwgZC5zdHlsZS5zZXRQcm9wZXJ0eShcImN1cnNvclwiLCBcInBvaW50ZXJcIiksIGQuc3R5bGUuc2V0UHJvcGVydHkoXCJvdXRsaW5lXCIsIFwibm9uZVwiKSwgZC5zdHlsZS5zZXRQcm9wZXJ0eShcInBhZGRpbmctdG9wXCIsIFwiMTBweFwiKSwgZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdCksIGQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaSksIGQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgKCkgPT4gcyghMCkpLCBkLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHMoITEpKSwgZC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKCkgPT4gbyghMCkpLCBkLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IG8oITEpKSwgaC5zdHlsZS5zZXRQcm9wZXJ0eShcIndpZHRoXCIsIFwiNTZweFwiKSwgaC5zdHlsZS5zZXRQcm9wZXJ0eShcImhlaWdodFwiLCBcIjU2cHhcIiksIGguc3R5bGUuc2V0UHJvcGVydHkoXCJvYmplY3QtZml0XCIsIFwiY292ZXJcIiksIGguc3R5bGUuc2V0UHJvcGVydHkoXCJib3JkZXItcmFkaXVzXCIsIFwiMTJweFwiKSwgYih2LCAoKSA9PiBlLm5hbWUpLCBBKCh5KSA9PiB7XG4gICAgICB2YXIgeiA9IG4oKSwgJCA9IGMoKSA/IGA2cHggc29saWQgJHtmfWAgOiBcIm5vbmVcIiwgUCA9IGUuaWNvbiwgXyA9IGUubmFtZSwgRSA9IHtcbiAgICAgICAgLi4uVyxcbiAgICAgICAgY29sb3I6IGMoKSA/IGEgOiB2b2lkIDAsXG4gICAgICAgIFwidGV4dC1hbGlnblwiOiBcImNlbnRlclwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHogIT09IHkuZSAmJiBOKGQsIFwicm9sZVwiLCB5LmUgPSB6KSwgJCAhPT0geS50ICYmICgoeS50ID0gJCkgIT0gbnVsbCA/IGguc3R5bGUuc2V0UHJvcGVydHkoXCJvdXRsaW5lXCIsICQpIDogaC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcIm91dGxpbmVcIikpLCBQICE9PSB5LmEgJiYgTihoLCBcInNyY1wiLCB5LmEgPSBQKSwgXyAhPT0geS5vICYmIE4oaCwgXCJhbHRcIiwgeS5vID0gXyksIHkuaSA9IEwodiwgRSwgeS5pKSwgeTtcbiAgICB9LCB7XG4gICAgICBlOiB2b2lkIDAsXG4gICAgICB0OiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDAsXG4gICAgICBvOiB2b2lkIDAsXG4gICAgICBpOiB2b2lkIDBcbiAgICB9KSwgdTtcbiAgfSkoKTtcbn1cbnZhciBrbiA9IC8qIEBfX1BVUkVfXyAqLyBDKCc8bGluayBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1ETStTYW5zOml0YWwsb3Bzeix3Z2h0QDAsOS4uNDAsMTAwLi4xMDAwOzEsOS4uNDAsMTAwLi4xMDAwJmFtcDtkaXNwbGF5PXN3YXBcInJlbD1zdHlsZXNoZWV0PicpLCAkbiA9IC8qIEBfX1BVUkVfXyAqLyBDKFwiPGRpdiBjbGFzcz1zaWRlLXBhbmVsPlwiKSwgQW4gPSAvKiBAX19QVVJFX18gKi8gQygnPGRpdj48ZGl2PjwvZGl2PjxkaXY+PGRpdiBjbGFzcz1jYXJkLXdpZHRoLWNvbnRhaW5lcj48ZGl2IGNsYXNzPWNhcmQtaGVpZ2h0LWNvbnRhaW5lcj48ZGl2IGNsYXNzPWNhcmQ+PGRpdiBjbGFzcz1jYXJkLWdyaWQ+PGRpdiBjbGFzcz1tYWluLXBhbmVsPjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2IGNsYXNzPXdhbGxldHMtZ3JpZC1jb250YWluZXIgZGF0YS1kZXNjPVwid2FsbGV0IGdyaWQgY29udGFpbmVyIGZvciBwYWRkaW5nXCI+PGRpdiBjbGFzcz13YWxsZXRzLWdyaWQgZGF0YS1kZXNjPVwid2FsbGV0IGdyaWQgY29udGFpbmVyXCI+JyksIExuID0gLyogQF9fUFVSRV9fICovIEMoYDxkaXY+PHN0eWxlPlxuICAgICAgICBAa2V5ZnJhbWVzIHdhbGxldC1zZWxlY3Rvci1mYWRlLWluIHtcbiAgICAgICAgICBmcm9tIHtvcGFjaXR5OiAwOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoNDBweCk7fVxuICAgICAgICAgIHRvIHtvcGFjaXR5OiAxOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7fVxuICAgICAgICB9XG5cbiAgICAgICAgQGtleWZyYW1lcyB3YWxsZXQtc2VsZWN0b3ItZmFkZS1vdXQge1xuICAgICAgICAgIGZyb20ge29wYWNpdHk6IDE7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTt9XG4gICAgICAgICAgdG8ge29wYWNpdHk6IDA7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSg0MHB4KTt9XG4gICAgICAgIH1cbiAgICAgICAgQGtleWZyYW1lcyB3YWxsZXQtc2VsZWN0b3ItYmx1ci1pbiB7XG4gICAgICAgICAgZnJvbSB7b3BhY2l0eTogMDsgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDBweCk7fVxuICAgICAgICAgIHRvIHtvcGFjaXR5OiAxOyBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMTBweCk7fVxuICAgICAgICB9XG5cbiAgICAgICAgQGtleWZyYW1lcyB3YWxsZXQtc2VsZWN0b3ItYmx1ci1vdXQge1xuICAgICAgICAgIGZyb20ge29wYWNpdHk6IDE7IGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KTt9XG4gICAgICAgICAgdG8ge29wYWNpdHk6IDA7IGJhY2tkcm9wLWZpbHRlcjogYmx1cigwcHgpO31cbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT48c3R5bGU+YCk7XG5jb25zdCBHID0gXCIyNHB4XCI7XG5mdW5jdGlvbiBPbigpIHtcbiAgY29uc3QgW2UsIHRdID0gaigpLCBbbiwgaV0gPSBqKCksIFtyLCBzXSA9IGooKTtcbiAgZnVuY3Rpb24gbCgpIHtcbiAgICBjb25zdCBwID0gZSgpLCB4ID0gcigpO1xuICAgIHJldHVybiAhKCFwIHx8ICF4IHx8ICFwLmNvbnRhaW5zKHgpIHx8IGdldENvbXB1dGVkU3R5bGUoeCkuZGlzcGxheSA9PT0gXCJub25lXCIpO1xuICB9XG4gIGNvbnN0IFtvLCBjXSA9IGooITEpLCBbZiwgYV0gPSBqKCExKSwgW3UsIGRdID0gaihbXSksIFtoLCB2XSA9IGooe1xuICAgIHR5cGU6IFwibm9uZVwiXG4gIH0pLCB5ID0gKCkgPT4gdSgpLnNvbWUoKHApID0+IGpuKHApKSwgeiA9ICgpID0+IGMoITEpO1xuICBmdW5jdGlvbiAkKCkge1xuICAgIGNvbnN0IHAgPSBuZXcgQ3VzdG9tRXZlbnQoeGUsIHtcbiAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgY29tcG9zZWQ6ICEwXG4gICAgfSk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQocCksIHooKTtcbiAgfVxuICBmdW5jdGlvbiBQKHApIHtcbiAgICBwLmtleSA9PT0gXCJFc2NhcGVcIiAmJiAkKCk7XG4gIH1cbiAgRmUoKCkgPT4ge1xuICAgIGlmIChvKCkpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBQKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIFApO1xuICB9KTtcbiAgZnVuY3Rpb24gXyhwKSB7XG4gICAgY29uc3QgeCA9IHUoKS5maW5kKChLKSA9PiBLLmlkID09PSBwKTtcbiAgICBpZiAoa2UoeCkpIHtcbiAgICAgIGwoKSA/IHYoe1xuICAgICAgICB0eXBlOiBcImluc3RhbGwtd2FsbGV0LXByb21wdFwiLFxuICAgICAgICBvcHRpb246IHhcbiAgICAgIH0pIDogU2UoeCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IE8gPSBuZXcgQ3VzdG9tRXZlbnQodmUsIHtcbiAgICAgIGRldGFpbDogcCxcbiAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgY29tcG9zZWQ6ICEwXG4gICAgfSk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQoTyk7XG4gIH1cbiAgZnVuY3Rpb24gRShwKSB7XG4gICAgbXQoKCkgPT4ge1xuICAgICAgYyghMCksIGEoITApO1xuICAgICAgY29uc3QgeCA9IHAuZGV0YWlsLm9wdGlvbnM7XG4gICAgICBkKHgpLCB4LnNvbWUoKE8pID0+ICFPLmluc3RhbGxQcm9tcHQpID8gdih7XG4gICAgICAgIHR5cGU6IFwiZXhwbGFpbmVyXCJcbiAgICAgIH0pIDogdih7XG4gICAgICAgIHR5cGU6IFwibm9uZVwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBSKCkge1xuICAgIGMoITEpO1xuICB9XG4gIGNvbnN0IHNlID0gKCkgPT4ge1xuICAgIG8oKSB8fCBhKCExKTtcbiAgfTtcbiAgZnVuY3Rpb24gWWUocCkge1xuICAgIGNvbnN0IHggPSBwLmRldGFpbDtcbiAgICB2KHtcbiAgICAgIHR5cGU6IFwib3BlbmluZy13YWxsZXRcIixcbiAgICAgIG9wdGlvbjogdSgpLmZpbmQoKE8pID0+IE8uaWQgPT09IHgpXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gR2UoKSB7XG4gICAgdih7XG4gICAgICB0eXBlOiBcImV4cGxhaW5lclwiXG4gICAgfSk7XG4gIH1cbiAgYnQoKCkgPT4ge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKENlLCBFKSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUGUsIFIpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihYZSwgWWUpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihxZSwgR2UpLCBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGtuKCkpO1xuICB9KSwgTWUoKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKENlLCBFKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoUGUsIFIpO1xuICB9KTtcbiAgZnVuY3Rpb24gWmUocCkge1xuICAgIGNvbnN0IHggPSBwLnRhcmdldDtcbiAgICBpZiAoIXgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgTyA9IG4oKTtcbiAgICBPICYmIChPLmNvbnRhaW5zKHgpIHx8ICQoKSk7XG4gIH1cbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgdmFyIHAgPSBMbigpLCB4ID0gcC5maXJzdENoaWxkLCBPID0geC5uZXh0U2libGluZztcbiAgICByZXR1cm4geWUodCwgcCksIHAuc3R5bGUuc2V0UHJvcGVydHkoXCJpbnNldFwiLCBcIjBcIiksIHAuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIFplKSwgcC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIkluc2lkZSByb290IGtleWRvd25cIik7XG4gICAgfSksIGIocCwgZyhsbiwge30pLCB4KSwgYihPLCAoKSA9PiBgXG4gICAgICAgIC5jYXJkLXdpZHRoLWNvbnRhaW5lciB7XG4gICAgICAgICAgY29udGFpbmVyOiBjYXJkLXdpZHRoLWNvbnRhaW5lciAvIGlubGluZS1zaXplO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgd2lkdGg6IDc0MHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgLmNhcmQtaGVpZ2h0LWNvbnRhaW5lciB7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIH1cblxuICAgICAgICAuY2FyZCB7XG4gICAgICAgICAgbWluLWhlaWdodDogMzQwcHg7XG4gICAgICAgICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtIDhyZW0pO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6ICR7R307XG4gICAgICAgICAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6ICR7R307XG5cbiAgICAgICAgICBiYWNrZ3JvdW5kOiByZ2IoMTk2LCAxNzcsIDIxNyk7XG4gICAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcblxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcblxuICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCI7IC8qIEZvciB0aGUgY2xvc2UgYnV0dG9uICovXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcbiAgICAgICAgICBkaXNwbGF5OiAke2YoKSA/IFwiYmxvY2tcIiA6IFwibm9uZVwifTtcblxuICAgICAgICAgIGJveC1zaGFkb3c6IDBweCA4cHggNjRweCAwcHggcmdiYSgwLCAwLCAwLCAwLjI1KTtcbiAgICAgICAgICBhbmltYXRpb246ICR7bygpID8gXCJ3YWxsZXQtc2VsZWN0b3ItZmFkZS1pbiAwLjRzIGN1YmljLWJlemllciguMDUsIC43LCAuMSwgMSkgZm9yd2FyZHNcIiA6IFwid2FsbGV0LXNlbGVjdG9yLWZhZGUtb3V0IDAuMnMgY3ViaWMtYmV6aWVyKC4zLCAwLCAuOCwgLjE1KSBmb3J3YXJkc1wifTtcbiAgICAgICAgfVxuXG4gICAgICAgIC5jYXJkLWdyaWQge1xuICAgICAgICAgIGZsZXgtZ3JvdzogMTtcbiAgICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgICAgXG4gICAgICAgICAgZGlzcGxheTogZ3JpZDtcbiAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjtcbiAgICAgICAgICBncmlkLXRlbXBsYXRlLWFyZWFzOiBcIm1haW5QYW5lbFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLm1haW4tcGFuZWwge1xuICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICBncmlkLWFyZWE6IG1haW5QYW5lbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC53YWxsZXRzLWdyaWQtY29udGFpbmVyIHtcbiAgICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgIH1cblxuICAgICAgICAud2FsbGV0cy1ncmlkIHtcbiAgICAgICAgICBkaXNwbGF5OiBncmlkO1xuICAgICAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZmlsbCwgbWlubWF4KDEwMHB4LCAxZnIpKTtcbiAgICAgICAgICBhbGlnbi1jb250ZW50OiBzdGFydDtcblxuICAgICAgICAgIHBhZGRpbmctbGVmdDogMjRweDtcbiAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiAyNHB4O1xuICAgICAgICAgIHBhZGRpbmctYm90dG9tOiA0MHB4O1xuICAgICAgICB9XG5cbiAgICAgICAgLmRpdmlkZXIge1xuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgICAgZ3JpZC1hcmVhOiBkaXZpZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLnNpZGUtcGFuZWwge1xuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgICAgZ3JpZC1hcmVhOiBzaWRlUGFuZWw7XG4gICAgICAgIH1cblxuICAgICAgICBAY29udGFpbmVyIGNhcmQtd2lkdGgtY29udGFpbmVyICh3aWR0aCA+IDQwMHB4KSB7XG4gICAgICAgICAgLmNhcmQtaGVpZ2h0LWNvbnRhaW5lciB7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAuY2FyZCB7XG4gICAgICAgICAgICBtYXgtd2lkdGg6IGNhbGMoMTAwdncgLSAycmVtKTtcbiAgICAgICAgICAgIG1heC1oZWlnaHQ6IDQ2MHB4O1xuICAgICAgICAgICAgJHt5KCkgPyBcIlwiIDogXCJ3aWR0aDogMzYwcHg7XCJ9XG4gICAgICAgICAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAke0d9O1xuICAgICAgICAgICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6ICR7R307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLmNhcmQtZ3JpZCB7XG4gICAgICAgICAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6ICR7eSgpID8gXCI1ZnIgYXV0byA0ZnJcIiA6IFwiMWZyXCJ9O1xuICAgICAgICAgICAgZ3JpZC10ZW1wbGF0ZS1hcmVhczogJHt5KCkgPyAnXCJtYWluUGFuZWwgZGl2aWRlciBzaWRlUGFuZWxcIicgOiAnXCJtYWluUGFuZWxcIid9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC5kaXZpZGVyIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC5zaWRlLXBhbmVsIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYCksIGIocCwgZyhoZSwge1xuICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgIHJldHVybiBmKCk7XG4gICAgICB9LFxuICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICB2YXIgSyA9IEFuKCksIEIgPSBLLmZpcnN0Q2hpbGQsIFggPSBCLm5leHRTaWJsaW5nLCBKZSA9IFguZmlyc3RDaGlsZCwgUWUgPSBKZS5maXJzdENoaWxkLCBIID0gUWUuZmlyc3RDaGlsZCwgb2UgPSBILmZpcnN0Q2hpbGQsIGV0ID0gb2UuZmlyc3RDaGlsZCwgbGUgPSBldC5maXJzdENoaWxkLCBhZSA9IGxlLm5leHRTaWJsaW5nLCB0dCA9IGFlLm5leHRTaWJsaW5nLCBudCA9IHR0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHJldHVybiBLLnN0eWxlLnNldFByb3BlcnR5KFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKSwgSy5zdHlsZS5zZXRQcm9wZXJ0eShcImluc2V0XCIsIFwiMFwiKSwgQi5zdHlsZS5zZXRQcm9wZXJ0eShcImJhY2tncm91bmQtY29sb3JcIiwgXCIjRkZGRkZGODBcIiksIEIuc3R5bGUuc2V0UHJvcGVydHkoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpLCBCLnN0eWxlLnNldFByb3BlcnR5KFwiaW5zZXRcIiwgXCIwXCIpLCBYLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLCBcImZsZXhcIiksIFguc3R5bGUuc2V0UHJvcGVydHkoXCJqdXN0aWZ5LWNvbnRlbnRcIiwgXCJjZW50ZXJcIiksIFguc3R5bGUuc2V0UHJvcGVydHkoXCJhbGlnbi1pdGVtc1wiLCBcImNlbnRlclwiKSwgWC5zdHlsZS5zZXRQcm9wZXJ0eShcImhlaWdodFwiLCBcIjEwMCVcIiksIHllKGksIEgpLCBILmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgc2UpLCBiKGxlLCAoKSA9PiB5KCkgPyBcIkNob29zZSB3YWxsZXQgdG8gY29ubmVjdFwiIDogXCJEb24ndCBoYXZlIGEgd2FsbGV0P1wiKSwgYihhZSwgKCkgPT4geSgpID8gXCJTdGFydCBieSBzZWxlY3Rpbmcgd2l0aCBvbmUgb2YgdGhlIHdhbGxldHMgYmVsb3cgYW5kIGNvbmZpcm1pbmcgdGhlIGNvbm5lY3Rpb24uXCIgOiBcIlN0YXJ0IGJ5IGluc3RhbGxpbmcgb25lIG9mIHRoZSB3YWxsZXRzIGJlbG93LlwiKSwgYihudCwgZyhBdCwge1xuICAgICAgICAgIGdldCBlYWNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiAoaykgPT4gZyhFbiwgJHQoaywge1xuICAgICAgICAgICAgb25Qcm92aWRlclNlbGVjdGVkOiBfXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKSwgYihvZSwgZyhoZSwge1xuICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKS50eXBlICE9PSBcIm5vbmVcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgIHJldHVybiBnKGNuLCB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgbnVsbCksIGIob2UsIGcoaGUsIHtcbiAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCkudHlwZSAhPT0gXCJub25lXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICB2YXIgayA9ICRuKCk7XG4gICAgICAgICAgICByZXR1cm4geWUocywgayksIGIoaywgZyhkbiwge1xuICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGcoaG4sIHtcbiAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGcoTHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICBmYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2cocGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgoKS50eXBlID09PSBcImluc3RhbGwtd2FsbGV0LXByb21wdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGcoYm4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBvcHRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoKCkub3B0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgZyhwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaCgpLnR5cGUgPT09IFwiZXhwbGFpbmVyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZyh5biwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgZyhwZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaCgpLnR5cGUgPT09IFwib3BlbmluZy13YWxsZXRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnKFNuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgb3B0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaCgpLm9wdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSwgaztcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBudWxsKSwgYihILCBnKHNuLCB7XG4gICAgICAgICAgb25DbG9zZTogJFxuICAgICAgICB9KSwgbnVsbCksIEEoKGspID0+IHtcbiAgICAgICAgICB2YXIgY2UgPSBvKCkgPyBcIndhbGxldC1zZWxlY3Rvci1ibHVyLWluIDAuMnMgY3ViaWMtYmV6aWVyKC4wNSwgLjcsIC4xLCAxKSBmb3J3YXJkc1wiIDogXCJ3YWxsZXQtc2VsZWN0b3ItYmx1ci1vdXQgMC4ycyBjdWJpYy1iZXppZXIoLjMsIDAsIC44LCAuMTUpIGZvcndhcmRzXCIsIGl0ID0ge1xuICAgICAgICAgICAgLi4ucmUsXG4gICAgICAgICAgICBtYXJnaW46IFwiMFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLXRvcFwiOiBcIjI0cHhcIixcbiAgICAgICAgICAgIFwicGFkZGluZy1sZWZ0XCI6IFwiMjRweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwiMjRweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLWJvdHRvbVwiOiBcIjE2cHhcIlxuICAgICAgICAgIH0sIHJ0ID0ge1xuICAgICAgICAgICAgLi4uVyxcbiAgICAgICAgICAgIFwicGFkZGluZy1sZWZ0XCI6IFwiMjRweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwiMjRweFwiLFxuICAgICAgICAgICAgXCJwYWRkaW5nLWJvdHRvbVwiOiBcIjMwcHhcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGNlICE9PSBrLmUgJiYgKChrLmUgPSBjZSkgIT0gbnVsbCA/IEIuc3R5bGUuc2V0UHJvcGVydHkoXCJhbmltYXRpb25cIiwgY2UpIDogQi5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImFuaW1hdGlvblwiKSksIGsudCA9IEwobGUsIGl0LCBrLnQpLCBrLmEgPSBMKGFlLCBydCwgay5hKSwgaztcbiAgICAgICAgfSwge1xuICAgICAgICAgIGU6IHZvaWQgMCxcbiAgICAgICAgICB0OiB2b2lkIDAsXG4gICAgICAgICAgYTogdm9pZCAwXG4gICAgICAgIH0pLCBLO1xuICAgICAgfVxuICAgIH0pLCBudWxsKSwgQSgoKSA9PiAoZigpID8gXCJmaXhlZFwiIDogXCJzdGF0aWNcIikgIT0gbnVsbCA/IHAuc3R5bGUuc2V0UHJvcGVydHkoXCJwb3NpdGlvblwiLCBmKCkgPyBcImZpeGVkXCIgOiBcInN0YXRpY1wiKSA6IHAuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJwb3NpdGlvblwiKSksIHA7XG4gIH0pKCk7XG59XG5jb25zdCBFZSA9IFwic2F0cy1jb25uZWN0LXdhbGxldC1wcm92aWRlci1zZWxlY3RvclwiLCBnZSA9IEVlO1xuZnVuY3Rpb24gSGUoKSB7XG4gIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChFZSk7XG59XG5mdW5jdGlvbiBObigpIHtcbiAgaWYgKGN1c3RvbUVsZW1lbnRzLmdldChnZSkpXG4gICAgcmV0dXJuO1xuICBKdChnZSwgT24pO1xuICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChnZSk7XG4gIGUuaWQgPSBFZSwgZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIiwgZS5zdHlsZS56SW5kZXggPSBcIjk5OTk5OVwiLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpO1xufVxuZnVuY3Rpb24gem4oKSB7XG4gIGNvbnN0IGUgPSBIZSgpO1xuICBlICYmIGUucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBrZShlKSB7XG4gIHJldHVybiAhIWUuaW5zdGFsbFByb21wdDtcbn1cbmZ1bmN0aW9uIGpuKGUpIHtcbiAgcmV0dXJuICFrZShlKTtcbn1cbmZ1bmN0aW9uIFJuKGUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKCh0LCBuKSA9PiB7XG4gICAgaWYgKCFIZSgpKSB7XG4gICAgICBuKFwiRmFpbGVkIHRvIGRldGVjdCB0aGUgd2FsbGV0IHByb3ZpZGVyIHNlbGVjdG9yLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcigpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKHZlLCBzKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoeGUsIGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzKGMpIHtcbiAgICAgIHQoYy5kZXRhaWwpLCByKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICBuKCksIHIoKTtcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIodmUsIHMpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcih4ZSwgbCk7XG4gICAgY29uc3QgbyA9IG5ldyBDdXN0b21FdmVudChDZSwge1xuICAgICAgZGV0YWlsOiBlXG4gICAgfSk7XG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gSW4oZSkge1xuICBjb25zdCB0ID0gbmV3IEN1c3RvbUV2ZW50KFhlLCB7XG4gICAgZGV0YWlsOiBlXG4gIH0pO1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudCh0KTtcbn1cbmZ1bmN0aW9uIEZuKCkge1xuICBjb25zdCBlID0gbmV3IEN1c3RvbUV2ZW50KHFlKTtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZSk7XG59XG5mdW5jdGlvbiBNbigpIHtcbiAgY29uc3QgZSA9IG5ldyBDdXN0b21FdmVudChQZSk7XG4gIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGUpO1xufVxuZXhwb3J0IHtcbiAgem4gYXMgY2xlYW51cCxcbiAgTW4gYXMgY2xvc2UsXG4gIEVlIGFzIGVsZW1lbnRJZCxcbiAgZ2UgYXMgZWxlbWVudE5hbWUsXG4gIEhlIGFzIGdldFdhbGxldFByb3ZpZGVyU2VsZWN0b3JFbGVtZW50LFxuICBrZSBhcyBoYXNJbnN0YWxsUHJvbXB0LFxuICBqbiBhcyBpc0luc3RhbGxlZCxcbiAgTm4gYXMgbG9hZFNlbGVjdG9yLFxuICBSbiBhcyBzZWxlY3RXYWxsZXRQcm92aWRlcixcbiAgRm4gYXMgd2FsbGV0Q2xvc2UsXG4gIEluIGFzIHdhbGxldE9wZW5cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@sats-connect+ui@0.0.6/node_modules/@sats-connect/ui/dist/index.js\n");

/***/ })

};
;