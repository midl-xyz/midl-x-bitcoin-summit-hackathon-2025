"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@zag-js+focus-trap@1.21.9";
exports.ids = ["vendor-chunks/@zag-js+focus-trap@1.21.9"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@zag-js+focus-trap@1.21.9/node_modules/@zag-js/focus-trap/dist/index.mjs":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@zag-js+focus-trap@1.21.9/node_modules/@zag-js/focus-trap/dist/index.mjs ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FocusTrap: () => (/* binding */ FocusTrap),\n/* harmony export */   trapFocus: () => (/* binding */ trapFocus)\n/* harmony export */ });\n/* harmony import */ var _zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @zag-js/dom-query */ \"(ssr)/./node_modules/.pnpm/@zag-js+dom-query@1.21.9/node_modules/@zag-js/dom-query/dist/index.mjs\");\n\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar activeFocusTraps = {\n  activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      const activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap(trapStack, trap) {\n    const trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar sharedTrapStack = [];\nvar FocusTrap = class {\n  constructor(elements, options) {\n    __publicField(this, \"trapStack\");\n    __publicField(this, \"config\");\n    __publicField(this, \"doc\");\n    __publicField(this, \"state\", {\n      containers: [],\n      containerGroups: [],\n      tabbableGroups: [],\n      nodeFocusedBeforeActivation: null,\n      mostRecentlyFocusedNode: null,\n      active: false,\n      paused: false,\n      delayInitialFocusTimer: void 0,\n      recentNavEvent: void 0\n    });\n    __publicField(this, \"listenerCleanups\", []);\n    __publicField(this, \"handleFocus\", (event) => {\n      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);\n      const targetContained = this.findContainerIndex(target, event) >= 0;\n      if (targetContained || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isDocument)(target)) {\n        if (targetContained) {\n          this.state.mostRecentlyFocusedNode = target;\n        }\n      } else {\n        event.stopImmediatePropagation();\n        let nextNode;\n        let navAcrossContainers = true;\n        if (this.state.mostRecentlyFocusedNode) {\n          if ((0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(this.state.mostRecentlyFocusedNode) > 0) {\n            const mruContainerIdx = this.findContainerIndex(this.state.mostRecentlyFocusedNode);\n            const { tabbableNodes } = this.state.containerGroups[mruContainerIdx];\n            if (tabbableNodes.length > 0) {\n              const mruTabIdx = tabbableNodes.findIndex((node) => node === this.state.mostRecentlyFocusedNode);\n              if (mruTabIdx >= 0) {\n                if (this.config.isKeyForward(this.state.recentNavEvent)) {\n                  if (mruTabIdx + 1 < tabbableNodes.length) {\n                    nextNode = tabbableNodes[mruTabIdx + 1];\n                    navAcrossContainers = false;\n                  }\n                } else {\n                  if (mruTabIdx - 1 >= 0) {\n                    nextNode = tabbableNodes[mruTabIdx - 1];\n                    navAcrossContainers = false;\n                  }\n                }\n              }\n            }\n          } else {\n            if (!this.state.containerGroups.some((g) => g.tabbableNodes.some((n) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(n) > 0))) {\n              navAcrossContainers = false;\n            }\n          }\n        } else {\n          navAcrossContainers = false;\n        }\n        if (navAcrossContainers) {\n          nextNode = this.findNextNavNode({\n            // move FROM the MRU node, not event-related node (which will be the node that is\n            //  outside the trap causing the focus escape we're trying to fix)\n            target: this.state.mostRecentlyFocusedNode,\n            isBackward: this.config.isKeyBackward(this.state.recentNavEvent)\n          });\n        }\n        if (nextNode) {\n          this.tryFocus(nextNode);\n        } else {\n          this.tryFocus(this.state.mostRecentlyFocusedNode || this.getInitialFocusNode());\n        }\n      }\n      this.state.recentNavEvent = void 0;\n    });\n    __publicField(this, \"handlePointerDown\", (event) => {\n      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        this.deactivate({ returnFocus: this.config.returnFocusOnDeactivate });\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n    });\n    __publicField(this, \"handleClick\", (event) => {\n      const target = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);\n      if (this.findContainerIndex(target, event) >= 0) {\n        return;\n      }\n      if (valueOrHandler(this.config.clickOutsideDeactivates, event)) {\n        return;\n      }\n      if (valueOrHandler(this.config.allowOutsideClick, event)) {\n        return;\n      }\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    });\n    __publicField(this, \"handleTabKey\", (event) => {\n      if (this.config.isKeyForward(event) || this.config.isKeyBackward(event)) {\n        this.state.recentNavEvent = event;\n        const isBackward = this.config.isKeyBackward(event);\n        const destinationNode = this.findNextNavNode({ event, isBackward });\n        if (!destinationNode) return;\n        if (isTabEvent(event)) {\n          event.preventDefault();\n        }\n        this.tryFocus(destinationNode);\n      }\n    });\n    __publicField(this, \"handleEscapeKey\", (event) => {\n      if (isEscapeEvent(event) && valueOrHandler(this.config.escapeDeactivates, event) !== false) {\n        event.preventDefault();\n        this.deactivate();\n      }\n    });\n    __publicField(this, \"_mutationObserver\");\n    __publicField(this, \"setupMutationObserver\", () => {\n      const win = this.doc.defaultView || window;\n      this._mutationObserver = new win.MutationObserver((mutations) => {\n        const isFocusedNodeRemoved = mutations.some((mutation) => {\n          const removedNodes = Array.from(mutation.removedNodes);\n          return removedNodes.some((node) => node === this.state.mostRecentlyFocusedNode);\n        });\n        if (isFocusedNodeRemoved) {\n          this.tryFocus(this.getInitialFocusNode());\n        }\n      });\n    });\n    __publicField(this, \"updateObservedNodes\", () => {\n      this._mutationObserver?.disconnect();\n      if (this.state.active && !this.state.paused) {\n        this.state.containers.map((container) => {\n          this._mutationObserver?.observe(container, { subtree: true, childList: true });\n        });\n      }\n    });\n    __publicField(this, \"getInitialFocusNode\", () => {\n      let node = this.getNodeForOption(\"initialFocus\", { hasFallback: true });\n      if (node === false) {\n        return false;\n      }\n      if (node === void 0 || node && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(node)) {\n        if (this.findContainerIndex(this.doc.activeElement) >= 0) {\n          node = this.doc.activeElement;\n        } else {\n          const firstTabbableGroup = this.state.tabbableGroups[0];\n          const firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n          node = firstTabbableNode || this.getNodeForOption(\"fallbackFocus\");\n        }\n      } else if (node === null) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      if (!node) {\n        throw new Error(\"Your focus-trap needs to have at least one focusable element\");\n      }\n      if (!node.isConnected) {\n        node = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return node;\n    });\n    __publicField(this, \"tryFocus\", (node) => {\n      if (node === false) return;\n      if (node === (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getActiveElement)(this.doc)) return;\n      if (!node || !node.focus) {\n        this.tryFocus(this.getInitialFocusNode());\n        return;\n      }\n      node.focus({ preventScroll: !!this.config.preventScroll });\n      this.state.mostRecentlyFocusedNode = node;\n      if (isSelectableInput(node)) {\n        node.select();\n      }\n    });\n    __publicField(this, \"deactivate\", (deactivateOptions) => {\n      if (!this.state.active) return this;\n      const options = {\n        onDeactivate: this.config.onDeactivate,\n        onPostDeactivate: this.config.onPostDeactivate,\n        checkCanReturnFocus: this.config.checkCanReturnFocus,\n        ...deactivateOptions\n      };\n      clearTimeout(this.state.delayInitialFocusTimer);\n      this.state.delayInitialFocusTimer = void 0;\n      this.removeListeners();\n      this.state.active = false;\n      this.state.paused = false;\n      this.updateObservedNodes();\n      activeFocusTraps.deactivateTrap(this.trapStack, this);\n      const onDeactivate = this.getOption(options, \"onDeactivate\");\n      const onPostDeactivate = this.getOption(options, \"onPostDeactivate\");\n      const checkCanReturnFocus = this.getOption(options, \"checkCanReturnFocus\");\n      const returnFocus = this.getOption(options, \"returnFocus\", \"returnFocusOnDeactivate\");\n      onDeactivate?.();\n      const finishDeactivation = () => {\n        delay(() => {\n          if (returnFocus) {\n            const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n            this.tryFocus(returnFocusNode);\n          }\n          onPostDeactivate?.();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        const returnFocusNode = this.getReturnFocusNode(this.state.nodeFocusedBeforeActivation);\n        checkCanReturnFocus(returnFocusNode).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    });\n    __publicField(this, \"pause\", (pauseOptions) => {\n      if (this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onPause = this.getOption(pauseOptions, \"onPause\");\n      const onPostPause = this.getOption(pauseOptions, \"onPostPause\");\n      this.state.paused = true;\n      onPause?.();\n      this.removeListeners();\n      this.updateObservedNodes();\n      onPostPause?.();\n      return this;\n    });\n    __publicField(this, \"unpause\", (unpauseOptions) => {\n      if (!this.state.paused || !this.state.active) {\n        return this;\n      }\n      const onUnpause = this.getOption(unpauseOptions, \"onUnpause\");\n      const onPostUnpause = this.getOption(unpauseOptions, \"onPostUnpause\");\n      this.state.paused = false;\n      onUnpause?.();\n      this.updateTabbableNodes();\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostUnpause?.();\n      return this;\n    });\n    __publicField(this, \"updateContainerElements\", (containerElements) => {\n      this.state.containers = Array.isArray(containerElements) ? containerElements.filter(Boolean) : [containerElements].filter(Boolean);\n      if (this.state.active) {\n        this.updateTabbableNodes();\n      }\n      this.updateObservedNodes();\n      return this;\n    });\n    __publicField(this, \"getReturnFocusNode\", (previousActiveElement) => {\n      const node = this.getNodeForOption(\"setReturnFocus\", {\n        params: [previousActiveElement]\n      });\n      return node ? node : node === false ? false : previousActiveElement;\n    });\n    __publicField(this, \"getOption\", (configOverrideOptions, optionName, configOptionName) => {\n      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : (\n        // @ts-expect-error\n        this.config[configOptionName || optionName]\n      );\n    });\n    __publicField(this, \"getNodeForOption\", (optionName, { hasFallback = false, params = [] } = {}) => {\n      let optionValue = this.config[optionName];\n      if (typeof optionValue === \"function\") optionValue = optionValue(...params);\n      if (optionValue === true) optionValue = void 0;\n      if (!optionValue) {\n        if (optionValue === void 0 || optionValue === false) {\n          return optionValue;\n        }\n        throw new Error(`\\`${optionName}\\` was specified but was not a node, or did not return a node`);\n      }\n      let node = optionValue;\n      if (typeof optionValue === \"string\") {\n        try {\n          node = this.doc.querySelector(optionValue);\n        } catch (err) {\n          throw new Error(`\\`${optionName}\\` appears to be an invalid selector; error=\"${err.message}\"`);\n        }\n        if (!node) {\n          if (!hasFallback) {\n            throw new Error(`\\`${optionName}\\` as selector refers to no known node`);\n          }\n        }\n      }\n      return node;\n    });\n    __publicField(this, \"findNextNavNode\", (opts) => {\n      const { event, isBackward = false } = opts;\n      const target = opts.target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getEventTarget)(event);\n      this.updateTabbableNodes();\n      let destinationNode = null;\n      if (this.state.tabbableGroups.length > 0) {\n        const containerIndex = this.findContainerIndex(target, event);\n        const containerGroup = containerIndex >= 0 ? this.state.containerGroups[containerIndex] : void 0;\n        if (containerIndex < 0) {\n          if (isBackward) {\n            destinationNode = this.state.tabbableGroups[this.state.tabbableGroups.length - 1].lastTabbableNode;\n          } else {\n            destinationNode = this.state.tabbableGroups[0].firstTabbableNode;\n          }\n        } else if (isBackward) {\n          let startOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ firstTabbableNode }) => target === firstTabbableNode\n          );\n          if (startOfGroupIndex < 0 && (containerGroup?.container === target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target) && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target) && !containerGroup?.nextTabbableNode(target, false))) {\n            startOfGroupIndex = containerIndex;\n          }\n          if (startOfGroupIndex >= 0) {\n            const destinationGroupIndex = startOfGroupIndex === 0 ? this.state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target, false);\n          }\n        } else {\n          let lastOfGroupIndex = this.state.tabbableGroups.findIndex(\n            ({ lastTabbableNode }) => target === lastTabbableNode\n          );\n          if (lastOfGroupIndex < 0 && (containerGroup?.container === target || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target) && !(0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target) && !containerGroup?.nextTabbableNode(target))) {\n            lastOfGroupIndex = containerIndex;\n          }\n          if (lastOfGroupIndex >= 0) {\n            const destinationGroupIndex = lastOfGroupIndex === this.state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n            const destinationGroup = this.state.tabbableGroups[destinationGroupIndex];\n            destinationNode = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(target) >= 0 ? destinationGroup.firstTabbableNode : destinationGroup.firstDomTabbableNode;\n          } else if (!isTabEvent(event)) {\n            destinationNode = containerGroup?.nextTabbableNode(target);\n          }\n        }\n      } else {\n        destinationNode = this.getNodeForOption(\"fallbackFocus\");\n      }\n      return destinationNode;\n    });\n    this.trapStack = options.trapStack || sharedTrapStack;\n    const config = {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true,\n      delayInitialFocus: true,\n      isKeyForward(e) {\n        return isTabEvent(e) && !e.shiftKey;\n      },\n      isKeyBackward(e) {\n        return isTabEvent(e) && e.shiftKey;\n      },\n      ...options\n    };\n    this.doc = config.document || (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(Array.isArray(elements) ? elements[0] : elements);\n    this.config = config;\n    this.updateContainerElements(elements);\n    this.setupMutationObserver();\n  }\n  get active() {\n    return this.state.active;\n  }\n  get paused() {\n    return this.state.paused;\n  }\n  findContainerIndex(element, event) {\n    const composedPath = typeof event?.composedPath === \"function\" ? event.composedPath() : void 0;\n    return this.state.containerGroups.findIndex(\n      ({ container, tabbableNodes }) => container.contains(element) || composedPath?.includes(container) || tabbableNodes.find((node) => node === element)\n    );\n  }\n  updateTabbableNodes() {\n    this.state.containerGroups = this.state.containers.map((container) => {\n      const tabbableNodes = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabbables)(container);\n      const focusableNodes = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getFocusables)(container);\n      const firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;\n      const lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;\n      const firstDomTabbableNode = focusableNodes.find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(node));\n      const lastDomTabbableNode = focusableNodes.slice().reverse().find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(node));\n      const posTabIndexesFound = !!tabbableNodes.find((node) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(node) > 0);\n      function nextTabbableNode(node, forward = true) {\n        const nodeIdx = tabbableNodes.indexOf(node);\n        if (nodeIdx < 0) {\n          if (forward) {\n            return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find((el) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(el));\n          }\n          return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find((el) => (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(el));\n        }\n        return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n      }\n      return {\n        container,\n        tabbableNodes,\n        focusableNodes,\n        posTabIndexesFound,\n        firstTabbableNode,\n        lastTabbableNode,\n        firstDomTabbableNode,\n        lastDomTabbableNode,\n        nextTabbableNode\n      };\n    });\n    this.state.tabbableGroups = this.state.containerGroups.filter((group) => group.tabbableNodes.length > 0);\n    if (this.state.tabbableGroups.length <= 0 && !this.getNodeForOption(\"fallbackFocus\")) {\n      throw new Error(\n        \"Your focus-trap must have at least one container with at least one tabbable node in it at all times\"\n      );\n    }\n    if (this.state.containerGroups.find((g) => g.posTabIndexesFound) && this.state.containerGroups.length > 1) {\n      throw new Error(\n        \"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\"\n      );\n    }\n  }\n  addListeners() {\n    if (!this.state.active) return;\n    activeFocusTraps.activateTrap(this.trapStack, this);\n    this.state.delayInitialFocusTimer = this.config.delayInitialFocus ? delay(() => {\n      this.tryFocus(this.getInitialFocusNode());\n    }) : this.tryFocus(this.getInitialFocusNode());\n    this.listenerCleanups.push(\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"focusin\", this.handleFocus, true),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"mousedown\", this.handlePointerDown, { capture: true, passive: false }),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"touchstart\", this.handlePointerDown, { capture: true, passive: false }),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"click\", this.handleClick, { capture: true, passive: false }),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"keydown\", this.handleTabKey, { capture: true, passive: false }),\n      (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.addDomEvent)(this.doc, \"keydown\", this.handleEscapeKey)\n    );\n    return this;\n  }\n  removeListeners() {\n    if (!this.state.active) return;\n    this.listenerCleanups.forEach((cleanup) => cleanup());\n    this.listenerCleanups = [];\n    return this;\n  }\n  activate(activateOptions) {\n    if (this.state.active) {\n      return this;\n    }\n    const onActivate = this.getOption(activateOptions, \"onActivate\");\n    const onPostActivate = this.getOption(activateOptions, \"onPostActivate\");\n    const checkCanFocusTrap = this.getOption(activateOptions, \"checkCanFocusTrap\");\n    if (!checkCanFocusTrap) {\n      this.updateTabbableNodes();\n    }\n    this.state.active = true;\n    this.state.paused = false;\n    this.state.nodeFocusedBeforeActivation = this.doc.activeElement || null;\n    onActivate?.();\n    const finishActivation = () => {\n      if (checkCanFocusTrap) {\n        this.updateTabbableNodes();\n      }\n      this.addListeners();\n      this.updateObservedNodes();\n      onPostActivate?.();\n    };\n    if (checkCanFocusTrap) {\n      checkCanFocusTrap(this.state.containers.concat()).then(finishActivation, finishActivation);\n      return this;\n    }\n    finishActivation();\n    return this;\n  }\n};\nvar isTabEvent = (event) => event.key === \"Tab\";\nvar valueOrHandler = (value, ...params) => typeof value === \"function\" ? value(...params) : value;\nvar isEscapeEvent = (event) => !event.isComposing && event.key === \"Escape\";\nvar delay = (fn) => setTimeout(fn, 0);\nvar isSelectableInput = (node) => node.localName === \"input\" && \"select\" in node && typeof node.select === \"function\";\n\n// src/index.ts\nfunction trapFocus(el, options = {}) {\n  let trap;\n  const cleanup = (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.raf)(() => {\n    const contentEl = typeof el === \"function\" ? el() : el;\n    if (!contentEl) return;\n    trap = new FocusTrap(contentEl, {\n      escapeDeactivates: false,\n      allowOutsideClick: true,\n      preventScroll: true,\n      returnFocusOnDeactivate: true,\n      delayInitialFocus: false,\n      fallbackFocus: contentEl,\n      ...options,\n      document: (0,_zag_js_dom_query__WEBPACK_IMPORTED_MODULE_0__.getDocument)(contentEl)\n    });\n    try {\n      trap.activate();\n    } catch {\n    }\n  });\n  return function destroy() {\n    trap?.deactivate();\n    cleanup();\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHphZy1qcytmb2N1cy10cmFwQDEuMjEuOS9ub2RlX21vZHVsZXMvQHphZy1qcy9mb2N1cy10cmFwL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFtTDs7QUFFbkw7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLGlFQUFjO0FBQ25DO0FBQ0EsNkJBQTZCLDZEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOERBQVc7QUFDekI7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osb0ZBQW9GLDhEQUFXO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixpRUFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrREFBa0Q7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLGlFQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0NBQWdDO0FBQ3ZGLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLHlEQUF5RCxtQkFBbUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhEQUFXO0FBQ2pEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsbUVBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkRBQTJELG1DQUFtQyxJQUFJO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwrQkFBK0IsV0FBVyxzQ0FBc0MsU0FBUyxZQUFZO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYyw0QkFBNEI7QUFDMUMsb0NBQW9DLGlFQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0EsZ0ZBQWdGLDhEQUFXLGFBQWEsNkRBQVU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBVztBQUN6QyxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0EsK0VBQStFLDhEQUFXLGFBQWEsNkRBQVU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBVztBQUN6QyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrQ0FBa0MsOERBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBWTtBQUN4Qyw2QkFBNkIsZ0VBQWE7QUFDMUM7QUFDQTtBQUNBLGlFQUFpRSw2REFBVTtBQUMzRSxrRkFBa0YsNkRBQVU7QUFDNUYsZ0VBQWdFLDhEQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDZEQUFVO0FBQ2pHO0FBQ0EsOEZBQThGLDZEQUFVO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU0sOERBQVc7QUFDakIsTUFBTSw4REFBVyxrREFBa0QsK0JBQStCO0FBQ2xHLE1BQU0sOERBQVcsbURBQW1ELCtCQUErQjtBQUNuRyxNQUFNLDhEQUFXLHdDQUF3QywrQkFBK0I7QUFDeEYsTUFBTSw4REFBVywyQ0FBMkMsK0JBQStCO0FBQzNGLE1BQU0sOERBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLGtCQUFrQixzREFBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4REFBVztBQUMzQixLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQyIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL0B6YWctanMrZm9jdXMtdHJhcEAxLjIxLjkvbm9kZV9tb2R1bGVzL0B6YWctanMvZm9jdXMtdHJhcC9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXREb2N1bWVudCwgZ2V0VGFiYmFibGVzLCBnZXRGb2N1c2FibGVzLCBpc1RhYmJhYmxlLCBnZXRUYWJJbmRleCwgYWRkRG9tRXZlbnQsIHJhZiwgZ2V0RXZlbnRUYXJnZXQsIGlzRG9jdW1lbnQsIGlzRm9jdXNhYmxlLCBnZXRBY3RpdmVFbGVtZW50IH0gZnJvbSAnQHphZy1qcy9kb20tcXVlcnknO1xuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xudmFyIGFjdGl2ZUZvY3VzVHJhcHMgPSB7XG4gIGFjdGl2YXRlVHJhcCh0cmFwU3RhY2ssIHRyYXApIHtcbiAgICBpZiAodHJhcFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGFjdGl2ZVRyYXAgPSB0cmFwU3RhY2tbdHJhcFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGFjdGl2ZVRyYXAgIT09IHRyYXApIHtcbiAgICAgICAgYWN0aXZlVHJhcC5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0cmFwSW5kZXggPSB0cmFwU3RhY2suaW5kZXhPZih0cmFwKTtcbiAgICBpZiAodHJhcEluZGV4ID09PSAtMSkge1xuICAgICAgdHJhcFN0YWNrLnB1c2godHJhcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXBTdGFjay5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICAgIHRyYXBTdGFjay5wdXNoKHRyYXApO1xuICAgIH1cbiAgfSxcbiAgZGVhY3RpdmF0ZVRyYXAodHJhcFN0YWNrLCB0cmFwKSB7XG4gICAgY29uc3QgdHJhcEluZGV4ID0gdHJhcFN0YWNrLmluZGV4T2YodHJhcCk7XG4gICAgaWYgKHRyYXBJbmRleCAhPT0gLTEpIHtcbiAgICAgIHRyYXBTdGFjay5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICB9XG4gICAgaWYgKHRyYXBTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB0cmFwU3RhY2tbdHJhcFN0YWNrLmxlbmd0aCAtIDFdLnVucGF1c2UoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgc2hhcmVkVHJhcFN0YWNrID0gW107XG52YXIgRm9jdXNUcmFwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50cywgb3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0cmFwU3RhY2tcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9jXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBjb250YWluZXJzOiBbXSxcbiAgICAgIGNvbnRhaW5lckdyb3VwczogW10sXG4gICAgICB0YWJiYWJsZUdyb3VwczogW10sXG4gICAgICBub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb246IG51bGwsXG4gICAgICBtb3N0UmVjZW50bHlGb2N1c2VkTm9kZTogbnVsbCxcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgZGVsYXlJbml0aWFsRm9jdXNUaW1lcjogdm9pZCAwLFxuICAgICAgcmVjZW50TmF2RXZlbnQ6IHZvaWQgMFxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsaXN0ZW5lckNsZWFudXBzXCIsIFtdKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlRm9jdXNcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICBjb25zdCB0YXJnZXRDb250YWluZWQgPSB0aGlzLmZpbmRDb250YWluZXJJbmRleCh0YXJnZXQsIGV2ZW50KSA+PSAwO1xuICAgICAgaWYgKHRhcmdldENvbnRhaW5lZCB8fCBpc0RvY3VtZW50KHRhcmdldCkpIHtcbiAgICAgICAgaWYgKHRhcmdldENvbnRhaW5lZCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBsZXQgbmV4dE5vZGU7XG4gICAgICAgIGxldCBuYXZBY3Jvc3NDb250YWluZXJzID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUpIHtcbiAgICAgICAgICBpZiAoZ2V0VGFiSW5kZXgodGhpcy5zdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBtcnVDb250YWluZXJJZHggPSB0aGlzLmZpbmRDb250YWluZXJJbmRleCh0aGlzLnN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdGFiYmFibGVOb2RlcyB9ID0gdGhpcy5zdGF0ZS5jb250YWluZXJHcm91cHNbbXJ1Q29udGFpbmVySWR4XTtcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgbXJ1VGFiSWR4ID0gdGFiYmFibGVOb2Rlcy5maW5kSW5kZXgoKG5vZGUpID0+IG5vZGUgPT09IHRoaXMuc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUpO1xuICAgICAgICAgICAgICBpZiAobXJ1VGFiSWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuaXNLZXlGb3J3YXJkKHRoaXMuc3RhdGUucmVjZW50TmF2RXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobXJ1VGFiSWR4ICsgMSA8IHRhYmJhYmxlTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdGFiYmFibGVOb2Rlc1ttcnVUYWJJZHggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgbmF2QWNyb3NzQ29udGFpbmVycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAobXJ1VGFiSWR4IC0gMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHROb2RlID0gdGFiYmFibGVOb2Rlc1ttcnVUYWJJZHggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbmF2QWNyb3NzQ29udGFpbmVycyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuY29udGFpbmVyR3JvdXBzLnNvbWUoKGcpID0+IGcudGFiYmFibGVOb2Rlcy5zb21lKChuKSA9PiBnZXRUYWJJbmRleChuKSA+IDApKSkge1xuICAgICAgICAgICAgICBuYXZBY3Jvc3NDb250YWluZXJzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hdkFjcm9zc0NvbnRhaW5lcnMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF2QWNyb3NzQ29udGFpbmVycykge1xuICAgICAgICAgIG5leHROb2RlID0gdGhpcy5maW5kTmV4dE5hdk5vZGUoe1xuICAgICAgICAgICAgLy8gbW92ZSBGUk9NIHRoZSBNUlUgbm9kZSwgbm90IGV2ZW50LXJlbGF0ZWQgbm9kZSAod2hpY2ggd2lsbCBiZSB0aGUgbm9kZSB0aGF0IGlzXG4gICAgICAgICAgICAvLyAgb3V0c2lkZSB0aGUgdHJhcCBjYXVzaW5nIHRoZSBmb2N1cyBlc2NhcGUgd2UncmUgdHJ5aW5nIHRvIGZpeClcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5zdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSxcbiAgICAgICAgICAgIGlzQmFja3dhcmQ6IHRoaXMuY29uZmlnLmlzS2V5QmFja3dhcmQodGhpcy5zdGF0ZS5yZWNlbnROYXZFdmVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE5vZGUpIHtcbiAgICAgICAgICB0aGlzLnRyeUZvY3VzKG5leHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRyeUZvY3VzKHRoaXMuc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgfHwgdGhpcy5nZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLnJlY2VudE5hdkV2ZW50ID0gdm9pZCAwO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVQb2ludGVyRG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGlmICh0aGlzLmZpbmRDb250YWluZXJJbmRleCh0YXJnZXQsIGV2ZW50KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZU9ySGFuZGxlcih0aGlzLmNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcywgZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSh7IHJldHVybkZvY3VzOiB0aGlzLmNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlT3JIYW5kbGVyKHRoaXMuY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrLCBldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlQ2xpY2tcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICBpZiAodGhpcy5maW5kQ29udGFpbmVySW5kZXgodGFyZ2V0LCBldmVudCkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVPckhhbmRsZXIodGhpcy5jb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMsIGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVPckhhbmRsZXIodGhpcy5jb25maWcuYWxsb3dPdXRzaWRlQ2xpY2ssIGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhbmRsZVRhYktleVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5pc0tleUZvcndhcmQoZXZlbnQpIHx8IHRoaXMuY29uZmlnLmlzS2V5QmFja3dhcmQoZXZlbnQpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucmVjZW50TmF2RXZlbnQgPSBldmVudDtcbiAgICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IHRoaXMuY29uZmlnLmlzS2V5QmFja3dhcmQoZXZlbnQpO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbk5vZGUgPSB0aGlzLmZpbmROZXh0TmF2Tm9kZSh7IGV2ZW50LCBpc0JhY2t3YXJkIH0pO1xuICAgICAgICBpZiAoIWRlc3RpbmF0aW9uTm9kZSkgcmV0dXJuO1xuICAgICAgICBpZiAoaXNUYWJFdmVudChldmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJ5Rm9jdXMoZGVzdGluYXRpb25Ob2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlRXNjYXBlS2V5XCIsIChldmVudCkgPT4ge1xuICAgICAgaWYgKGlzRXNjYXBlRXZlbnQoZXZlbnQpICYmIHZhbHVlT3JIYW5kbGVyKHRoaXMuY29uZmlnLmVzY2FwZURlYWN0aXZhdGVzLCBldmVudCkgIT09IGZhbHNlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbXV0YXRpb25PYnNlcnZlclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2V0dXBNdXRhdGlvbk9ic2VydmVyXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHdpbiA9IHRoaXMuZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgd2luLk11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBpc0ZvY3VzZWROb2RlUmVtb3ZlZCA9IG11dGF0aW9ucy5zb21lKChtdXRhdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWROb2RlcyA9IEFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKTtcbiAgICAgICAgICByZXR1cm4gcmVtb3ZlZE5vZGVzLnNvbWUoKG5vZGUpID0+IG5vZGUgPT09IHRoaXMuc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzRm9jdXNlZE5vZGVSZW1vdmVkKSB7XG4gICAgICAgICAgdGhpcy50cnlGb2N1cyh0aGlzLmdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ1cGRhdGVPYnNlcnZlZE5vZGVzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmFjdGl2ZSAmJiAhdGhpcy5zdGF0ZS5wYXVzZWQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250YWluZXJzLm1hcCgoY29udGFpbmVyKSA9PiB7XG4gICAgICAgICAgdGhpcy5fbXV0YXRpb25PYnNlcnZlcj8ub2JzZXJ2ZShjb250YWluZXIsIHsgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0SW5pdGlhbEZvY3VzTm9kZVwiLCAoKSA9PiB7XG4gICAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0Tm9kZUZvck9wdGlvbihcImluaXRpYWxGb2N1c1wiLCB7IGhhc0ZhbGxiYWNrOiB0cnVlIH0pO1xuICAgICAgaWYgKG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB2b2lkIDAgfHwgbm9kZSAmJiAhaXNGb2N1c2FibGUobm9kZSkpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZENvbnRhaW5lckluZGV4KHRoaXMuZG9jLmFjdGl2ZUVsZW1lbnQpID49IDApIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5kb2MuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmaXJzdFRhYmJhYmxlR3JvdXAgPSB0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzWzBdO1xuICAgICAgICAgIGNvbnN0IGZpcnN0VGFiYmFibGVOb2RlID0gZmlyc3RUYWJiYWJsZUdyb3VwICYmIGZpcnN0VGFiYmFibGVHcm91cC5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICBub2RlID0gZmlyc3RUYWJiYWJsZU5vZGUgfHwgdGhpcy5nZXROb2RlRm9yT3B0aW9uKFwiZmFsbGJhY2tGb2N1c1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmdldE5vZGVGb3JPcHRpb24oXCJmYWxsYmFja0ZvY3VzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgZm9jdXMtdHJhcCBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBmb2N1c2FibGUgZWxlbWVudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBub2RlID0gdGhpcy5nZXROb2RlRm9yT3B0aW9uKFwiZmFsbGJhY2tGb2N1c1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0cnlGb2N1c1wiLCAobm9kZSkgPT4ge1xuICAgICAgaWYgKG5vZGUgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICBpZiAobm9kZSA9PT0gZ2V0QWN0aXZlRWxlbWVudCh0aGlzLmRvYykpIHJldHVybjtcbiAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykge1xuICAgICAgICB0aGlzLnRyeUZvY3VzKHRoaXMuZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6ICEhdGhpcy5jb25maWcucHJldmVudFNjcm9sbCB9KTtcbiAgICAgIHRoaXMuc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSBub2RlO1xuICAgICAgaWYgKGlzU2VsZWN0YWJsZUlucHV0KG5vZGUpKSB7XG4gICAgICAgIG5vZGUuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRlYWN0aXZhdGVcIiwgKGRlYWN0aXZhdGVPcHRpb25zKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlKSByZXR1cm4gdGhpcztcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG9uRGVhY3RpdmF0ZTogdGhpcy5jb25maWcub25EZWFjdGl2YXRlLFxuICAgICAgICBvblBvc3REZWFjdGl2YXRlOiB0aGlzLmNvbmZpZy5vblBvc3REZWFjdGl2YXRlLFxuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzOiB0aGlzLmNvbmZpZy5jaGVja0NhblJldHVybkZvY3VzLFxuICAgICAgICAuLi5kZWFjdGl2YXRlT3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIpO1xuICAgICAgdGhpcy5zdGF0ZS5kZWxheUluaXRpYWxGb2N1c1RpbWVyID0gdm9pZCAwO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuc3RhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGVPYnNlcnZlZE5vZGVzKCk7XG4gICAgICBhY3RpdmVGb2N1c1RyYXBzLmRlYWN0aXZhdGVUcmFwKHRoaXMudHJhcFN0YWNrLCB0aGlzKTtcbiAgICAgIGNvbnN0IG9uRGVhY3RpdmF0ZSA9IHRoaXMuZ2V0T3B0aW9uKG9wdGlvbnMsIFwib25EZWFjdGl2YXRlXCIpO1xuICAgICAgY29uc3Qgb25Qb3N0RGVhY3RpdmF0ZSA9IHRoaXMuZ2V0T3B0aW9uKG9wdGlvbnMsIFwib25Qb3N0RGVhY3RpdmF0ZVwiKTtcbiAgICAgIGNvbnN0IGNoZWNrQ2FuUmV0dXJuRm9jdXMgPSB0aGlzLmdldE9wdGlvbihvcHRpb25zLCBcImNoZWNrQ2FuUmV0dXJuRm9jdXNcIik7XG4gICAgICBjb25zdCByZXR1cm5Gb2N1cyA9IHRoaXMuZ2V0T3B0aW9uKG9wdGlvbnMsIFwicmV0dXJuRm9jdXNcIiwgXCJyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZVwiKTtcbiAgICAgIG9uRGVhY3RpdmF0ZT8uKCk7XG4gICAgICBjb25zdCBmaW5pc2hEZWFjdGl2YXRpb24gPSAoKSA9PiB7XG4gICAgICAgIGRlbGF5KCgpID0+IHtcbiAgICAgICAgICBpZiAocmV0dXJuRm9jdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHVybkZvY3VzTm9kZSA9IHRoaXMuZ2V0UmV0dXJuRm9jdXNOb2RlKHRoaXMuc3RhdGUubm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudHJ5Rm9jdXMocmV0dXJuRm9jdXNOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb25Qb3N0RGVhY3RpdmF0ZT8uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChyZXR1cm5Gb2N1cyAmJiBjaGVja0NhblJldHVybkZvY3VzKSB7XG4gICAgICAgIGNvbnN0IHJldHVybkZvY3VzTm9kZSA9IHRoaXMuZ2V0UmV0dXJuRm9jdXNOb2RlKHRoaXMuc3RhdGUubm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uKTtcbiAgICAgICAgY2hlY2tDYW5SZXR1cm5Gb2N1cyhyZXR1cm5Gb2N1c05vZGUpLnRoZW4oZmluaXNoRGVhY3RpdmF0aW9uLCBmaW5pc2hEZWFjdGl2YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZpbmlzaERlYWN0aXZhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhdXNlXCIsIChwYXVzZU9wdGlvbnMpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBhdXNlZCB8fCAhdGhpcy5zdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjb25zdCBvblBhdXNlID0gdGhpcy5nZXRPcHRpb24ocGF1c2VPcHRpb25zLCBcIm9uUGF1c2VcIik7XG4gICAgICBjb25zdCBvblBvc3RQYXVzZSA9IHRoaXMuZ2V0T3B0aW9uKHBhdXNlT3B0aW9ucywgXCJvblBvc3RQYXVzZVwiKTtcbiAgICAgIHRoaXMuc3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgICAgIG9uUGF1c2U/LigpO1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMudXBkYXRlT2JzZXJ2ZWROb2RlcygpO1xuICAgICAgb25Qb3N0UGF1c2U/LigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVucGF1c2VcIiwgKHVucGF1c2VPcHRpb25zKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGUucGF1c2VkIHx8ICF0aGlzLnN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uVW5wYXVzZSA9IHRoaXMuZ2V0T3B0aW9uKHVucGF1c2VPcHRpb25zLCBcIm9uVW5wYXVzZVwiKTtcbiAgICAgIGNvbnN0IG9uUG9zdFVucGF1c2UgPSB0aGlzLmdldE9wdGlvbih1bnBhdXNlT3B0aW9ucywgXCJvblBvc3RVbnBhdXNlXCIpO1xuICAgICAgdGhpcy5zdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIG9uVW5wYXVzZT8uKCk7XG4gICAgICB0aGlzLnVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLnVwZGF0ZU9ic2VydmVkTm9kZXMoKTtcbiAgICAgIG9uUG9zdFVucGF1c2U/LigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzXCIsIChjb250YWluZXJFbGVtZW50cykgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5jb250YWluZXJzID0gQXJyYXkuaXNBcnJheShjb250YWluZXJFbGVtZW50cykgPyBjb250YWluZXJFbGVtZW50cy5maWx0ZXIoQm9vbGVhbikgOiBbY29udGFpbmVyRWxlbWVudHNdLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmFjdGl2ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlT2JzZXJ2ZWROb2RlcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFJldHVybkZvY3VzTm9kZVwiLCAocHJldmlvdXNBY3RpdmVFbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlRm9yT3B0aW9uKFwic2V0UmV0dXJuRm9jdXNcIiwge1xuICAgICAgICBwYXJhbXM6IFtwcmV2aW91c0FjdGl2ZUVsZW1lbnRdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlID8gbm9kZSA6IG5vZGUgPT09IGZhbHNlID8gZmFsc2UgOiBwcmV2aW91c0FjdGl2ZUVsZW1lbnQ7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldE9wdGlvblwiLCAoY29uZmlnT3ZlcnJpZGVPcHRpb25zLCBvcHRpb25OYW1lLCBjb25maWdPcHRpb25OYW1lKSA9PiB7XG4gICAgICByZXR1cm4gY29uZmlnT3ZlcnJpZGVPcHRpb25zICYmIGNvbmZpZ092ZXJyaWRlT3B0aW9uc1tvcHRpb25OYW1lXSAhPT0gdm9pZCAwID8gY29uZmlnT3ZlcnJpZGVPcHRpb25zW29wdGlvbk5hbWVdIDogKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHRoaXMuY29uZmlnW2NvbmZpZ09wdGlvbk5hbWUgfHwgb3B0aW9uTmFtZV1cbiAgICAgICk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldE5vZGVGb3JPcHRpb25cIiwgKG9wdGlvbk5hbWUsIHsgaGFzRmFsbGJhY2sgPSBmYWxzZSwgcGFyYW1zID0gW10gfSA9IHt9KSA9PiB7XG4gICAgICBsZXQgb3B0aW9uVmFsdWUgPSB0aGlzLmNvbmZpZ1tvcHRpb25OYW1lXTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09IFwiZnVuY3Rpb25cIikgb3B0aW9uVmFsdWUgPSBvcHRpb25WYWx1ZSguLi5wYXJhbXMpO1xuICAgICAgaWYgKG9wdGlvblZhbHVlID09PSB0cnVlKSBvcHRpb25WYWx1ZSA9IHZvaWQgMDtcbiAgICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgICAgaWYgKG9wdGlvblZhbHVlID09PSB2b2lkIDAgfHwgb3B0aW9uVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtvcHRpb25OYW1lfVxcYCB3YXMgc3BlY2lmaWVkIGJ1dCB3YXMgbm90IGEgbm9kZSwgb3IgZGlkIG5vdCByZXR1cm4gYSBub2RlYCk7XG4gICAgICB9XG4gICAgICBsZXQgbm9kZSA9IG9wdGlvblZhbHVlO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmRvYy5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke29wdGlvbk5hbWV9XFxgIGFwcGVhcnMgdG8gYmUgYW4gaW52YWxpZCBzZWxlY3RvcjsgZXJyb3I9XCIke2Vyci5tZXNzYWdlfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgaWYgKCFoYXNGYWxsYmFjaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke29wdGlvbk5hbWV9XFxgIGFzIHNlbGVjdG9yIHJlZmVycyB0byBubyBrbm93biBub2RlYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmluZE5leHROYXZOb2RlXCIsIChvcHRzKSA9PiB7XG4gICAgICBjb25zdCB7IGV2ZW50LCBpc0JhY2t3YXJkID0gZmFsc2UgfSA9IG9wdHM7XG4gICAgICBjb25zdCB0YXJnZXQgPSBvcHRzLnRhcmdldCB8fCBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICB0aGlzLnVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgIGxldCBkZXN0aW5hdGlvbk5vZGUgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjb250YWluZXJJbmRleCA9IHRoaXMuZmluZENvbnRhaW5lckluZGV4KHRhcmdldCwgZXZlbnQpO1xuICAgICAgICBjb25zdCBjb250YWluZXJHcm91cCA9IGNvbnRhaW5lckluZGV4ID49IDAgPyB0aGlzLnN0YXRlLmNvbnRhaW5lckdyb3Vwc1tjb250YWluZXJJbmRleF0gOiB2b2lkIDA7XG4gICAgICAgIGlmIChjb250YWluZXJJbmRleCA8IDApIHtcbiAgICAgICAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gdGhpcy5zdGF0ZS50YWJiYWJsZUdyb3Vwc1t0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCAtIDFdLmxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IHRoaXMuc3RhdGUudGFiYmFibGVHcm91cHNbMF0uZmlyc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgICBsZXQgc3RhcnRPZkdyb3VwSW5kZXggPSB0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzLmZpbmRJbmRleChcbiAgICAgICAgICAgICh7IGZpcnN0VGFiYmFibGVOb2RlIH0pID0+IHRhcmdldCA9PT0gZmlyc3RUYWJiYWJsZU5vZGVcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChzdGFydE9mR3JvdXBJbmRleCA8IDAgJiYgKGNvbnRhaW5lckdyb3VwPy5jb250YWluZXIgPT09IHRhcmdldCB8fCBpc0ZvY3VzYWJsZSh0YXJnZXQpICYmICFpc1RhYmJhYmxlKHRhcmdldCkgJiYgIWNvbnRhaW5lckdyb3VwPy5uZXh0VGFiYmFibGVOb2RlKHRhcmdldCwgZmFsc2UpKSkge1xuICAgICAgICAgICAgc3RhcnRPZkdyb3VwSW5kZXggPSBjb250YWluZXJJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0T2ZHcm91cEluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uR3JvdXBJbmRleCA9IHN0YXJ0T2ZHcm91cEluZGV4ID09PSAwID8gdGhpcy5zdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxIDogc3RhcnRPZkdyb3VwSW5kZXggLSAxO1xuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25Hcm91cCA9IHRoaXMuc3RhdGUudGFiYmFibGVHcm91cHNbZGVzdGluYXRpb25Hcm91cEluZGV4XTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IGdldFRhYkluZGV4KHRhcmdldCkgPj0gMCA/IGRlc3RpbmF0aW9uR3JvdXAubGFzdFRhYmJhYmxlTm9kZSA6IGRlc3RpbmF0aW9uR3JvdXAubGFzdERvbVRhYmJhYmxlTm9kZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc1RhYkV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gY29udGFpbmVyR3JvdXA/Lm5leHRUYWJiYWJsZU5vZGUodGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBsYXN0T2ZHcm91cEluZGV4ID0gdGhpcy5zdGF0ZS50YWJiYWJsZUdyb3Vwcy5maW5kSW5kZXgoXG4gICAgICAgICAgICAoeyBsYXN0VGFiYmFibGVOb2RlIH0pID0+IHRhcmdldCA9PT0gbGFzdFRhYmJhYmxlTm9kZVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGxhc3RPZkdyb3VwSW5kZXggPCAwICYmIChjb250YWluZXJHcm91cD8uY29udGFpbmVyID09PSB0YXJnZXQgfHwgaXNGb2N1c2FibGUodGFyZ2V0KSAmJiAhaXNUYWJiYWJsZSh0YXJnZXQpICYmICFjb250YWluZXJHcm91cD8ubmV4dFRhYmJhYmxlTm9kZSh0YXJnZXQpKSkge1xuICAgICAgICAgICAgbGFzdE9mR3JvdXBJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdE9mR3JvdXBJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkdyb3VwSW5kZXggPSBsYXN0T2ZHcm91cEluZGV4ID09PSB0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCAtIDEgPyAwIDogbGFzdE9mR3JvdXBJbmRleCArIDE7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkdyb3VwID0gdGhpcy5zdGF0ZS50YWJiYWJsZUdyb3Vwc1tkZXN0aW5hdGlvbkdyb3VwSW5kZXhdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gZ2V0VGFiSW5kZXgodGFyZ2V0KSA+PSAwID8gZGVzdGluYXRpb25Hcm91cC5maXJzdFRhYmJhYmxlTm9kZSA6IGRlc3RpbmF0aW9uR3JvdXAuZmlyc3REb21UYWJiYWJsZU5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmICghaXNUYWJFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IGNvbnRhaW5lckdyb3VwPy5uZXh0VGFiYmFibGVOb2RlKHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSB0aGlzLmdldE5vZGVGb3JPcHRpb24oXCJmYWxsYmFja0ZvY3VzXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uTm9kZTtcbiAgICB9KTtcbiAgICB0aGlzLnRyYXBTdGFjayA9IG9wdGlvbnMudHJhcFN0YWNrIHx8IHNoYXJlZFRyYXBTdGFjaztcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogdHJ1ZSxcbiAgICAgIGVzY2FwZURlYWN0aXZhdGVzOiB0cnVlLFxuICAgICAgZGVsYXlJbml0aWFsRm9jdXM6IHRydWUsXG4gICAgICBpc0tleUZvcndhcmQoZSkge1xuICAgICAgICByZXR1cm4gaXNUYWJFdmVudChlKSAmJiAhZS5zaGlmdEtleTtcbiAgICAgIH0sXG4gICAgICBpc0tleUJhY2t3YXJkKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzVGFiRXZlbnQoZSkgJiYgZS5zaGlmdEtleTtcbiAgICAgIH0sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICB0aGlzLmRvYyA9IGNvbmZpZy5kb2N1bWVudCB8fCBnZXREb2N1bWVudChBcnJheS5pc0FycmF5KGVsZW1lbnRzKSA/IGVsZW1lbnRzWzBdIDogZWxlbWVudHMpO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyRWxlbWVudHMoZWxlbWVudHMpO1xuICAgIHRoaXMuc2V0dXBNdXRhdGlvbk9ic2VydmVyKCk7XG4gIH1cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5hY3RpdmU7XG4gIH1cbiAgZ2V0IHBhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXVzZWQ7XG4gIH1cbiAgZmluZENvbnRhaW5lckluZGV4KGVsZW1lbnQsIGV2ZW50KSB7XG4gICAgY29uc3QgY29tcG9zZWRQYXRoID0gdHlwZW9mIGV2ZW50Py5jb21wb3NlZFBhdGggPT09IFwiZnVuY3Rpb25cIiA/IGV2ZW50LmNvbXBvc2VkUGF0aCgpIDogdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnRhaW5lckdyb3Vwcy5maW5kSW5kZXgoXG4gICAgICAoeyBjb250YWluZXIsIHRhYmJhYmxlTm9kZXMgfSkgPT4gY29udGFpbmVyLmNvbnRhaW5zKGVsZW1lbnQpIHx8IGNvbXBvc2VkUGF0aD8uaW5jbHVkZXMoY29udGFpbmVyKSB8fCB0YWJiYWJsZU5vZGVzLmZpbmQoKG5vZGUpID0+IG5vZGUgPT09IGVsZW1lbnQpXG4gICAgKTtcbiAgfVxuICB1cGRhdGVUYWJiYWJsZU5vZGVzKCkge1xuICAgIHRoaXMuc3RhdGUuY29udGFpbmVyR3JvdXBzID0gdGhpcy5zdGF0ZS5jb250YWluZXJzLm1hcCgoY29udGFpbmVyKSA9PiB7XG4gICAgICBjb25zdCB0YWJiYWJsZU5vZGVzID0gZ2V0VGFiYmFibGVzKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBmb2N1c2FibGVOb2RlcyA9IGdldEZvY3VzYWJsZXMoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGZpcnN0VGFiYmFibGVOb2RlID0gdGFiYmFibGVOb2Rlcy5sZW5ndGggPiAwID8gdGFiYmFibGVOb2Rlc1swXSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGxhc3RUYWJiYWJsZU5vZGUgPSB0YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDAgPyB0YWJiYWJsZU5vZGVzW3RhYmJhYmxlTm9kZXMubGVuZ3RoIC0gMV0gOiB2b2lkIDA7XG4gICAgICBjb25zdCBmaXJzdERvbVRhYmJhYmxlTm9kZSA9IGZvY3VzYWJsZU5vZGVzLmZpbmQoKG5vZGUpID0+IGlzVGFiYmFibGUobm9kZSkpO1xuICAgICAgY29uc3QgbGFzdERvbVRhYmJhYmxlTm9kZSA9IGZvY3VzYWJsZU5vZGVzLnNsaWNlKCkucmV2ZXJzZSgpLmZpbmQoKG5vZGUpID0+IGlzVGFiYmFibGUobm9kZSkpO1xuICAgICAgY29uc3QgcG9zVGFiSW5kZXhlc0ZvdW5kID0gISF0YWJiYWJsZU5vZGVzLmZpbmQoKG5vZGUpID0+IGdldFRhYkluZGV4KG5vZGUpID4gMCk7XG4gICAgICBmdW5jdGlvbiBuZXh0VGFiYmFibGVOb2RlKG5vZGUsIGZvcndhcmQgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGVJZHggPSB0YWJiYWJsZU5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIGlmIChub2RlSWR4IDwgMCkge1xuICAgICAgICAgIGlmIChmb3J3YXJkKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlTm9kZXMuc2xpY2UoZm9jdXNhYmxlTm9kZXMuaW5kZXhPZihub2RlKSArIDEpLmZpbmQoKGVsKSA9PiBpc1RhYmJhYmxlKGVsKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmb2N1c2FibGVOb2Rlcy5zbGljZSgwLCBmb2N1c2FibGVOb2Rlcy5pbmRleE9mKG5vZGUpKS5yZXZlcnNlKCkuZmluZCgoZWwpID0+IGlzVGFiYmFibGUoZWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFiYmFibGVOb2Rlc1tub2RlSWR4ICsgKGZvcndhcmQgPyAxIDogLTEpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgdGFiYmFibGVOb2RlcyxcbiAgICAgICAgZm9jdXNhYmxlTm9kZXMsXG4gICAgICAgIHBvc1RhYkluZGV4ZXNGb3VuZCxcbiAgICAgICAgZmlyc3RUYWJiYWJsZU5vZGUsXG4gICAgICAgIGxhc3RUYWJiYWJsZU5vZGUsXG4gICAgICAgIGZpcnN0RG9tVGFiYmFibGVOb2RlLFxuICAgICAgICBsYXN0RG9tVGFiYmFibGVOb2RlLFxuICAgICAgICBuZXh0VGFiYmFibGVOb2RlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMuc3RhdGUudGFiYmFibGVHcm91cHMgPSB0aGlzLnN0YXRlLmNvbnRhaW5lckdyb3Vwcy5maWx0ZXIoKGdyb3VwKSA9PiBncm91cC50YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDApO1xuICAgIGlmICh0aGlzLnN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCA8PSAwICYmICF0aGlzLmdldE5vZGVGb3JPcHRpb24oXCJmYWxsYmFja0ZvY3VzXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiWW91ciBmb2N1cy10cmFwIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgY29udGFpbmVyIHdpdGggYXQgbGVhc3Qgb25lIHRhYmJhYmxlIG5vZGUgaW4gaXQgYXQgYWxsIHRpbWVzXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlLmNvbnRhaW5lckdyb3Vwcy5maW5kKChnKSA9PiBnLnBvc1RhYkluZGV4ZXNGb3VuZCkgJiYgdGhpcy5zdGF0ZS5jb250YWluZXJHcm91cHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkF0IGxlYXN0IG9uZSBub2RlIHdpdGggYSBwb3NpdGl2ZSB0YWJpbmRleCB3YXMgZm91bmQgaW4gb25lIG9mIHlvdXIgZm9jdXMtdHJhcCdzIG11bHRpcGxlIGNvbnRhaW5lcnMuIFBvc2l0aXZlIHRhYmluZGV4ZXMgYXJlIG9ubHkgc3VwcG9ydGVkIGluIHNpbmdsZS1jb250YWluZXIgZm9jdXMtdHJhcHMuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGFkZExpc3RlbmVycygpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlKSByZXR1cm47XG4gICAgYWN0aXZlRm9jdXNUcmFwcy5hY3RpdmF0ZVRyYXAodGhpcy50cmFwU3RhY2ssIHRoaXMpO1xuICAgIHRoaXMuc3RhdGUuZGVsYXlJbml0aWFsRm9jdXNUaW1lciA9IHRoaXMuY29uZmlnLmRlbGF5SW5pdGlhbEZvY3VzID8gZGVsYXkoKCkgPT4ge1xuICAgICAgdGhpcy50cnlGb2N1cyh0aGlzLmdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgfSkgOiB0aGlzLnRyeUZvY3VzKHRoaXMuZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICB0aGlzLmxpc3RlbmVyQ2xlYW51cHMucHVzaChcbiAgICAgIGFkZERvbUV2ZW50KHRoaXMuZG9jLCBcImZvY3VzaW5cIiwgdGhpcy5oYW5kbGVGb2N1cywgdHJ1ZSksXG4gICAgICBhZGREb21FdmVudCh0aGlzLmRvYywgXCJtb3VzZWRvd25cIiwgdGhpcy5oYW5kbGVQb2ludGVyRG93biwgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZSB9KSxcbiAgICAgIGFkZERvbUV2ZW50KHRoaXMuZG9jLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5oYW5kbGVQb2ludGVyRG93biwgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiBmYWxzZSB9KSxcbiAgICAgIGFkZERvbUV2ZW50KHRoaXMuZG9jLCBcImNsaWNrXCIsIHRoaXMuaGFuZGxlQ2xpY2ssIHsgY2FwdHVyZTogdHJ1ZSwgcGFzc2l2ZTogZmFsc2UgfSksXG4gICAgICBhZGREb21FdmVudCh0aGlzLmRvYywgXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlVGFiS2V5LCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IGZhbHNlIH0pLFxuICAgICAgYWRkRG9tRXZlbnQodGhpcy5kb2MsIFwia2V5ZG93blwiLCB0aGlzLmhhbmRsZUVzY2FwZUtleSlcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5saXN0ZW5lckNsZWFudXBzLmZvckVhY2goKGNsZWFudXApID0+IGNsZWFudXAoKSk7XG4gICAgdGhpcy5saXN0ZW5lckNsZWFudXBzID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWN0aXZhdGUoYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuYWN0aXZlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qgb25BY3RpdmF0ZSA9IHRoaXMuZ2V0T3B0aW9uKGFjdGl2YXRlT3B0aW9ucywgXCJvbkFjdGl2YXRlXCIpO1xuICAgIGNvbnN0IG9uUG9zdEFjdGl2YXRlID0gdGhpcy5nZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCBcIm9uUG9zdEFjdGl2YXRlXCIpO1xuICAgIGNvbnN0IGNoZWNrQ2FuRm9jdXNUcmFwID0gdGhpcy5nZXRPcHRpb24oYWN0aXZhdGVPcHRpb25zLCBcImNoZWNrQ2FuRm9jdXNUcmFwXCIpO1xuICAgIGlmICghY2hlY2tDYW5Gb2N1c1RyYXApIHtcbiAgICAgIHRoaXMudXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5zdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IHRoaXMuZG9jLmFjdGl2ZUVsZW1lbnQgfHwgbnVsbDtcbiAgICBvbkFjdGl2YXRlPy4oKTtcbiAgICBjb25zdCBmaW5pc2hBY3RpdmF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKGNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMudXBkYXRlT2JzZXJ2ZWROb2RlcygpO1xuICAgICAgb25Qb3N0QWN0aXZhdGU/LigpO1xuICAgIH07XG4gICAgaWYgKGNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICBjaGVja0NhbkZvY3VzVHJhcCh0aGlzLnN0YXRlLmNvbnRhaW5lcnMuY29uY2F0KCkpLnRoZW4oZmluaXNoQWN0aXZhdGlvbiwgZmluaXNoQWN0aXZhdGlvbik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoQWN0aXZhdGlvbigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIGlzVGFiRXZlbnQgPSAoZXZlbnQpID0+IGV2ZW50LmtleSA9PT0gXCJUYWJcIjtcbnZhciB2YWx1ZU9ySGFuZGxlciA9ICh2YWx1ZSwgLi4ucGFyYW1zKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlKC4uLnBhcmFtcykgOiB2YWx1ZTtcbnZhciBpc0VzY2FwZUV2ZW50ID0gKGV2ZW50KSA9PiAhZXZlbnQuaXNDb21wb3NpbmcgJiYgZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiO1xudmFyIGRlbGF5ID0gKGZuKSA9PiBzZXRUaW1lb3V0KGZuLCAwKTtcbnZhciBpc1NlbGVjdGFibGVJbnB1dCA9IChub2RlKSA9PiBub2RlLmxvY2FsTmFtZSA9PT0gXCJpbnB1dFwiICYmIFwic2VsZWN0XCIgaW4gbm9kZSAmJiB0eXBlb2Ygbm9kZS5zZWxlY3QgPT09IFwiZnVuY3Rpb25cIjtcblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiB0cmFwRm9jdXMoZWwsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgdHJhcDtcbiAgY29uc3QgY2xlYW51cCA9IHJhZigoKSA9PiB7XG4gICAgY29uc3QgY29udGVudEVsID0gdHlwZW9mIGVsID09PSBcImZ1bmN0aW9uXCIgPyBlbCgpIDogZWw7XG4gICAgaWYgKCFjb250ZW50RWwpIHJldHVybjtcbiAgICB0cmFwID0gbmV3IEZvY3VzVHJhcChjb250ZW50RWwsIHtcbiAgICAgIGVzY2FwZURlYWN0aXZhdGVzOiBmYWxzZSxcbiAgICAgIGFsbG93T3V0c2lkZUNsaWNrOiB0cnVlLFxuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgIHJldHVybkZvY3VzT25EZWFjdGl2YXRlOiB0cnVlLFxuICAgICAgZGVsYXlJbml0aWFsRm9jdXM6IGZhbHNlLFxuICAgICAgZmFsbGJhY2tGb2N1czogY29udGVudEVsLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGRvY3VtZW50OiBnZXREb2N1bWVudChjb250ZW50RWwpXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHRyYXAuYWN0aXZhdGUoKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0cmFwPy5kZWFjdGl2YXRlKCk7XG4gICAgY2xlYW51cCgpO1xuICB9O1xufVxuXG5leHBvcnQgeyBGb2N1c1RyYXAsIHRyYXBGb2N1cyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@zag-js+focus-trap@1.21.9/node_modules/@zag-js/focus-trap/dist/index.mjs\n");

/***/ })

};
;