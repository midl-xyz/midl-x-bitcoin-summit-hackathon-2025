"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uint8array-tools@0.0.9";
exports.ids = ["vendor-chunks/uint8array-tools@0.0.9"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/uint8array-tools@0.0.9/node_modules/uint8array-tools/src/mjs/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/uint8array-tools@0.0.9/node_modules/uint8array-tools/src/mjs/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   fromBase64: () => (/* binding */ fromBase64),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromUtf8: () => (/* binding */ fromUtf8),\n/* harmony export */   readInt16: () => (/* binding */ readInt16),\n/* harmony export */   readInt32: () => (/* binding */ readInt32),\n/* harmony export */   readInt64: () => (/* binding */ readInt64),\n/* harmony export */   readInt8: () => (/* binding */ readInt8),\n/* harmony export */   readUInt16: () => (/* binding */ readUInt16),\n/* harmony export */   readUInt32: () => (/* binding */ readUInt32),\n/* harmony export */   readUInt64: () => (/* binding */ readUInt64),\n/* harmony export */   readUInt8: () => (/* binding */ readUInt8),\n/* harmony export */   toBase64: () => (/* binding */ toBase64),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toUtf8: () => (/* binding */ toUtf8),\n/* harmony export */   writeInt16: () => (/* binding */ writeInt16),\n/* harmony export */   writeInt32: () => (/* binding */ writeInt32),\n/* harmony export */   writeInt64: () => (/* binding */ writeInt64),\n/* harmony export */   writeInt8: () => (/* binding */ writeInt8),\n/* harmony export */   writeUInt16: () => (/* binding */ writeUInt16),\n/* harmony export */   writeUInt32: () => (/* binding */ writeUInt32),\n/* harmony export */   writeUInt64: () => (/* binding */ writeUInt64),\n/* harmony export */   writeUInt8: () => (/* binding */ writeUInt8)\n/* harmony export */ });\nfunction toUtf8(bytes) {\n    return Buffer.from(bytes || []).toString();\n}\nfunction fromUtf8(s) {\n    return Uint8Array.from(Buffer.from(s || \"\", \"utf8\"));\n}\nfunction concat(arrays) {\n    return Uint8Array.from(Buffer.concat(arrays));\n}\nfunction toHex(bytes) {\n    return Buffer.from(bytes || []).toString(\"hex\");\n}\nfunction fromHex(hexString) {\n    return Uint8Array.from(Buffer.from(hexString || \"\", \"hex\"));\n}\nfunction toBase64(bytes) {\n    return Buffer.from(bytes).toString(\"base64\");\n}\nfunction fromBase64(base64) {\n    return Uint8Array.from(Buffer.from(base64 || \"\", \"base64\"));\n}\nfunction compare(v1, v2) {\n    return Buffer.from(v1).compare(Buffer.from(v2));\n}\nfunction writeUInt8(buffer, offset, value) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    const buf = Buffer.alloc(1);\n    buf.writeUInt8(value, 0);\n    buffer.set(Uint8Array.from(buf), offset);\n    return offset + 1;\n}\nfunction writeUInt16(buffer, offset, value, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.alloc(2);\n    if (littleEndian === \"LE\") {\n        buf.writeUInt16LE(value, 0);\n    }\n    else {\n        buf.writeUInt16BE(value, 0);\n    }\n    buffer.set(Uint8Array.from(buf), offset);\n    return offset + 2;\n}\nfunction writeUInt32(buffer, offset, value, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.alloc(4);\n    if (littleEndian === \"LE\") {\n        buf.writeUInt32LE(value, 0);\n    }\n    else {\n        buf.writeUInt32BE(value, 0);\n    }\n    buffer.set(Uint8Array.from(buf), offset);\n    return offset + 4;\n}\nfunction writeUInt64(buffer, offset, value, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.alloc(8);\n    if (value > 0xffffffffffffffffn) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= 0 and <= ${0xffffffffffffffffn}. Received ${value}`);\n    }\n    if (littleEndian === \"LE\") {\n        buf.writeBigUInt64LE(value, 0);\n    }\n    else {\n        buf.writeBigUInt64BE(value, 0);\n    }\n    buffer.set(Uint8Array.from(buf), offset);\n    return offset + 8;\n}\nfunction readUInt8(buffer, offset) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    const buf = Buffer.from(buffer);\n    return buf.readUInt8(offset);\n}\nfunction readUInt16(buffer, offset, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.from(buffer);\n    if (littleEndian === \"LE\") {\n        return buf.readUInt16LE(offset);\n    }\n    else {\n        return buf.readUInt16BE(offset);\n    }\n}\nfunction readUInt32(buffer, offset, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.from(buffer);\n    if (littleEndian === \"LE\") {\n        return buf.readUInt32LE(offset);\n    }\n    else {\n        return buf.readUInt32BE(offset);\n    }\n}\nfunction readUInt64(buffer, offset, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.from(buffer);\n    if (littleEndian === \"LE\") {\n        return buf.readBigUInt64LE(offset);\n    }\n    else {\n        return buf.readBigUInt64BE(offset);\n    }\n}\nfunction writeInt8(buffer, offset, value) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    const buf = Buffer.alloc(1);\n    buf.writeInt8(value, 0);\n    buffer.set(Uint8Array.from(buf), offset);\n    return offset + 1;\n}\nfunction writeInt16(buffer, offset, value, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.alloc(2);\n    if (littleEndian === \"LE\") {\n        buf.writeInt16LE(value, 0);\n    }\n    else {\n        buf.writeInt16BE(value, 0);\n    }\n    buffer.set(Uint8Array.from(buf), offset);\n    return offset + 2;\n}\nfunction writeInt32(buffer, offset, value, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.alloc(4);\n    if (littleEndian === \"LE\") {\n        buf.writeInt32LE(value, 0);\n    }\n    else {\n        buf.writeInt32BE(value, 0);\n    }\n    buffer.set(Uint8Array.from(buf), offset);\n    return offset + 4;\n}\nfunction writeInt64(buffer, offset, value, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    if (value > 0x7fffffffffffffffn || value < -0x8000000000000000n) {\n        throw new Error(`The value of \"value\" is out of range. It must be >= ${-0x8000000000000000n} and <= ${0x7fffffffffffffffn}. Received ${value}`);\n    }\n    littleEndian = littleEndian.toUpperCase();\n    const buf = Buffer.alloc(8);\n    if (littleEndian === \"LE\") {\n        buf.writeBigInt64LE(value, 0);\n    }\n    else {\n        buf.writeBigInt64BE(value, 0);\n    }\n    buffer.set(Uint8Array.from(buf), offset);\n    return offset + 8;\n}\nfunction readInt8(buffer, offset) {\n    if (offset + 1 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    const buf = Buffer.from(buffer);\n    return buf.readInt8(offset);\n}\nfunction readInt16(buffer, offset, littleEndian) {\n    if (offset + 2 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        return Buffer.from(buffer).readInt16LE(offset);\n    }\n    else {\n        return Buffer.from(buffer).readInt16BE(offset);\n    }\n}\nfunction readInt32(buffer, offset, littleEndian) {\n    if (offset + 4 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        return Buffer.from(buffer).readInt32LE(offset);\n    }\n    else {\n        return Buffer.from(buffer).readInt32BE(offset);\n    }\n}\nfunction readInt64(buffer, offset, littleEndian) {\n    if (offset + 8 > buffer.length) {\n        throw new Error(\"Offset is outside the bounds of Uint8Array\");\n    }\n    littleEndian = littleEndian.toUpperCase();\n    if (littleEndian === \"LE\") {\n        return Buffer.from(buffer).readBigInt64LE(offset);\n    }\n    else {\n        return Buffer.from(buffer).readBigInt64BE(offset);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdWludDhhcnJheS10b29sc0AwLjAuOS9ub2RlX21vZHVsZXMvdWludDhhcnJheS10b29scy9zcmMvbWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLG9CQUFvQixhQUFhLE1BQU07QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0Usc0JBQXNCLFNBQVMsb0JBQW9CLGFBQWEsTUFBTTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL3VpbnQ4YXJyYXktdG9vbHNAMC4wLjkvbm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXktdG9vbHMvc3JjL21qcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdG9VdGY4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzIHx8IFtdKS50b1N0cmluZygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZyb21VdGY4KHMpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKEJ1ZmZlci5mcm9tKHMgfHwgXCJcIiwgXCJ1dGY4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoYXJyYXlzKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShCdWZmZXIuY29uY2F0KGFycmF5cykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzIHx8IFtdKS50b1N0cmluZyhcImhleFwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleFN0cmluZykge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oQnVmZmVyLmZyb20oaGV4U3RyaW5nIHx8IFwiXCIsIFwiaGV4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0Jhc2U2NChieXRlcykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShieXRlcykudG9TdHJpbmcoXCJiYXNlNjRcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKEJ1ZmZlci5mcm9tKGJhc2U2NCB8fCBcIlwiLCBcImJhc2U2NFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZSh2MSwgdjIpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odjEpLmNvbXBhcmUoQnVmZmVyLmZyb20odjIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVJbnQ4KGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgIGlmIChvZmZzZXQgKyAxID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPZmZzZXQgaXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIFVpbnQ4QXJyYXlcIik7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICBidWYud3JpdGVVSW50OCh2YWx1ZSwgMCk7XG4gICAgYnVmZmVyLnNldChVaW50OEFycmF5LmZyb20oYnVmKSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIG9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPZmZzZXQgaXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIFVpbnQ4QXJyYXlcIik7XG4gICAgfVxuICAgIGxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbi50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5hbGxvYygyKTtcbiAgICBpZiAobGl0dGxlRW5kaWFuID09PSBcIkxFXCIpIHtcbiAgICAgICAgYnVmLndyaXRlVUludDE2TEUodmFsdWUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnVmLndyaXRlVUludDE2QkUodmFsdWUsIDApO1xuICAgIH1cbiAgICBidWZmZXIuc2V0KFVpbnQ4QXJyYXkuZnJvbShidWYpLCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQgKyAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDQgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZnNldCBpcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgVWludDhBcnJheVwiKTtcbiAgICB9XG4gICAgbGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIGlmIChsaXR0bGVFbmRpYW4gPT09IFwiTEVcIikge1xuICAgICAgICBidWYud3JpdGVVSW50MzJMRSh2YWx1ZSwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWYud3JpdGVVSW50MzJCRSh2YWx1ZSwgMCk7XG4gICAgfVxuICAgIGJ1ZmZlci5zZXQoVWludDhBcnJheS5mcm9tKGJ1ZiksIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldCArIDQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVVSW50NjQoYnVmZmVyLCBvZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgOCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2Zmc2V0IGlzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiBVaW50OEFycmF5XCIpO1xuICAgIH1cbiAgICBsaXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW4udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoOCk7XG4gICAgaWYgKHZhbHVlID4gMHhmZmZmZmZmZmZmZmZmZmZmbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB2YWx1ZSBvZiBcInZhbHVlXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlID49IDAgYW5kIDw9ICR7MHhmZmZmZmZmZmZmZmZmZmZmbn0uIFJlY2VpdmVkICR7dmFsdWV9YCk7XG4gICAgfVxuICAgIGlmIChsaXR0bGVFbmRpYW4gPT09IFwiTEVcIikge1xuICAgICAgICBidWYud3JpdGVCaWdVSW50NjRMRSh2YWx1ZSwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWYud3JpdGVCaWdVSW50NjRCRSh2YWx1ZSwgMCk7XG4gICAgfVxuICAgIGJ1ZmZlci5zZXQoVWludDhBcnJheS5mcm9tKGJ1ZiksIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldCArIDg7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVJbnQ4KGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCArIDEgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZnNldCBpcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgVWludDhBcnJheVwiKTtcbiAgICB9XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgICByZXR1cm4gYnVmLnJlYWRVSW50OChvZmZzZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPZmZzZXQgaXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIFVpbnQ4QXJyYXlcIik7XG4gICAgfVxuICAgIGxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbi50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZmZlcik7XG4gICAgaWYgKGxpdHRsZUVuZGlhbiA9PT0gXCJMRVwiKSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkxFKG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgNCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2Zmc2V0IGlzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiBVaW50OEFycmF5XCIpO1xuICAgIH1cbiAgICBsaXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW4udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICAgIGlmIChsaXR0bGVFbmRpYW4gPT09IFwiTEVcIikge1xuICAgICAgICByZXR1cm4gYnVmLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZFVJbnQ2NChidWZmZXIsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZnNldCBpcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgVWludDhBcnJheVwiKTtcbiAgICB9XG4gICAgbGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgICBpZiAobGl0dGxlRW5kaWFuID09PSBcIkxFXCIpIHtcbiAgICAgICAgcmV0dXJuIGJ1Zi5yZWFkQmlnVUludDY0TEUob2Zmc2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBidWYucmVhZEJpZ1VJbnQ2NEJFKG9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlSW50OChidWZmZXIsIG9mZnNldCwgdmFsdWUpIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2Zmc2V0IGlzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiBVaW50OEFycmF5XCIpO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgYnVmLndyaXRlSW50OCh2YWx1ZSwgMCk7XG4gICAgYnVmZmVyLnNldChVaW50OEFycmF5LmZyb20oYnVmKSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgb2Zmc2V0LCB2YWx1ZSwgbGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZnNldCBpcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgVWludDhBcnJheVwiKTtcbiAgICB9XG4gICAgbGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKDIpO1xuICAgIGlmIChsaXR0bGVFbmRpYW4gPT09IFwiTEVcIikge1xuICAgICAgICBidWYud3JpdGVJbnQxNkxFKHZhbHVlLCAwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1Zi53cml0ZUludDE2QkUodmFsdWUsIDApO1xuICAgIH1cbiAgICBidWZmZXIuc2V0KFVpbnQ4QXJyYXkuZnJvbShidWYpLCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQgKyAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCBvZmZzZXQsIHZhbHVlLCBsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgNCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2Zmc2V0IGlzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiBVaW50OEFycmF5XCIpO1xuICAgIH1cbiAgICBsaXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW4udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgaWYgKGxpdHRsZUVuZGlhbiA9PT0gXCJMRVwiKSB7XG4gICAgICAgIGJ1Zi53cml0ZUludDMyTEUodmFsdWUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnVmLndyaXRlSW50MzJCRSh2YWx1ZSwgMCk7XG4gICAgfVxuICAgIGJ1ZmZlci5zZXQoVWludDhBcnJheS5mcm9tKGJ1ZiksIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldCArIDQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JpdGVJbnQ2NChidWZmZXIsIG9mZnNldCwgdmFsdWUsIGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyA4ID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPZmZzZXQgaXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIFVpbnQ4QXJyYXlcIik7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA+IDB4N2ZmZmZmZmZmZmZmZmZmZm4gfHwgdmFsdWUgPCAtMHg4MDAwMDAwMDAwMDAwMDAwbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB2YWx1ZSBvZiBcInZhbHVlXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlID49ICR7LTB4ODAwMDAwMDAwMDAwMDAwMG59IGFuZCA8PSAkezB4N2ZmZmZmZmZmZmZmZmZmZm59LiBSZWNlaXZlZCAke3ZhbHVlfWApO1xuICAgIH1cbiAgICBsaXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW4udG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2MoOCk7XG4gICAgaWYgKGxpdHRsZUVuZGlhbiA9PT0gXCJMRVwiKSB7XG4gICAgICAgIGJ1Zi53cml0ZUJpZ0ludDY0TEUodmFsdWUsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnVmLndyaXRlQmlnSW50NjRCRSh2YWx1ZSwgMCk7XG4gICAgfVxuICAgIGJ1ZmZlci5zZXQoVWludDhBcnJheS5mcm9tKGJ1ZiksIG9mZnNldCk7XG4gICAgcmV0dXJuIG9mZnNldCArIDg7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZEludDgoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2Zmc2V0IGlzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiBVaW50OEFycmF5XCIpO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICAgIHJldHVybiBidWYucmVhZEludDgob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPZmZzZXQgaXMgb3V0c2lkZSB0aGUgYm91bmRzIG9mIFVpbnQ4QXJyYXlcIik7XG4gICAgfVxuICAgIGxpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbi50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChsaXR0bGVFbmRpYW4gPT09IFwiTEVcIikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKS5yZWFkSW50MTZMRShvZmZzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZmZlcikucmVhZEludDE2QkUob2Zmc2V0KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcmVhZEludDMyKGJ1ZmZlciwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgNCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT2Zmc2V0IGlzIG91dHNpZGUgdGhlIGJvdW5kcyBvZiBVaW50OEFycmF5XCIpO1xuICAgIH1cbiAgICBsaXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW4udG9VcHBlckNhc2UoKTtcbiAgICBpZiAobGl0dGxlRW5kaWFuID09PSBcIkxFXCIpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1ZmZlcikucmVhZEludDMyTEUob2Zmc2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpLnJlYWRJbnQzMkJFKG9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRJbnQ2NChidWZmZXIsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9mZnNldCBpcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgVWludDhBcnJheVwiKTtcbiAgICB9XG4gICAgbGl0dGxlRW5kaWFuID0gbGl0dGxlRW5kaWFuLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGxpdHRsZUVuZGlhbiA9PT0gXCJMRVwiKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpLnJlYWRCaWdJbnQ2NExFKG9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYnVmZmVyKS5yZWFkQmlnSW50NjRCRShvZmZzZXQpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/uint8array-tools@0.0.9/node_modules/uint8array-tools/src/mjs/index.js\n");

/***/ })

};
;