"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@bitcoinerlab+secp256k1@1.2.0";
exports.ids = ["vendor-chunks/@bitcoinerlab+secp256k1@1.2.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@bitcoinerlab+secp256k1@1.2.0/node_modules/@bitcoinerlab/secp256k1/dist/index.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@bitcoinerlab+secp256k1@1.2.0/node_modules/@bitcoinerlab/secp256k1/dist/index.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar secp256k1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/secp256k1.js\");\nvar mod = __webpack_require__(/*! @noble/curves/abstract/modular */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/modular.js\");\nvar utils = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/utils.js\");\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar mod__namespace = /*#__PURE__*/_interopNamespaceDefault(mod);\nvar utils__namespace = /*#__PURE__*/_interopNamespaceDefault(utils);\n\n/*\n * Copyright (c) 2023 Jose-Luis Landabaso\n * Distributed under the MIT software license.\n *\n * This file includes code from the following sources:\n *  * Paul Miller's @noble/secp256k1 (specifically, the privateAdd,\n *    privateNegate, pointAddScalar, and pointMultiply functions).\n *  * Some pieces from tiny-secp256k1\n *    (https://github.com/bitcoinjs/tiny-secp256k1)\n *  * It also uses code from BitGo's BitGoJS library\n *    (https://github.com/BitGo/BitGoJS)\n *\n * This package's tests are based on modified versions of tests from\n * tiny-secp256k1 (https://github.com/bitcoinjs/tiny-secp256k1/tests).\n */\n\nconst Point = secp256k1.secp256k1.ProjectivePoint;\n\nconst THROW_BAD_PRIVATE = \"Expected Private\";\nconst THROW_BAD_POINT = \"Expected Point\";\nconst THROW_BAD_TWEAK = \"Expected Tweak\";\nconst THROW_BAD_HASH = \"Expected Hash\";\nconst THROW_BAD_SIGNATURE = \"Expected Signature\";\nconst THROW_BAD_EXTRA_DATA = \"Expected Extra Data (32 bytes)\";\nconst THROW_BAD_SCALAR = \"Expected Scalar\";\nconst THROW_BAD_RECOVERY_ID = \"Bad Recovery Id\";\n\nconst HASH_SIZE = 32;\nconst TWEAK_SIZE = 32;\nconst BN32_N = new Uint8Array([\n  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n  254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65,\n]);\nconst EXTRA_DATA_SIZE = 32;\nconst BN32_ZERO = new Uint8Array(32);\nconst BN32_P_MINUS_N = new Uint8Array([\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 69, 81, 35, 25, 80, 183, 95,\n  196, 64, 45, 161, 114, 47, 201, 186, 238,\n]);\nconst _1n = BigInt(1);\n\nfunction isUint8Array(value) {\n  return value instanceof Uint8Array;\n}\n\nfunction cmpBN32(data1, data2) {\n  for (let i = 0; i < 32; ++i) {\n    if (data1[i] !== data2[i]) {\n      return data1[i] < data2[i] ? -1 : 1;\n    }\n  }\n  return 0;\n}\n\nfunction isZero(x) {\n  return cmpBN32(x, BN32_ZERO) === 0;\n}\n\nfunction isTweak(tweak) {\n  if (\n    !(tweak instanceof Uint8Array) ||\n    tweak.length !== TWEAK_SIZE ||\n    cmpBN32(tweak, BN32_N) >= 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isSignature(signature) {\n  return (\n    signature instanceof Uint8Array &&\n    signature.length === 64 &&\n    cmpBN32(signature.subarray(0, 32), BN32_N) < 0 &&\n    cmpBN32(signature.subarray(32, 64), BN32_N) < 0\n  );\n}\n\nfunction isSigrLessThanPMinusN(signature) {\n  return (\n    isUint8Array(signature) &&\n    signature.length === 64 &&\n    cmpBN32(signature.subarray(0, 32), BN32_P_MINUS_N) < 0\n  );\n}\n\nfunction isSignatureNonzeroRS(signature) {\n  return !(\n    isZero(signature.subarray(0, 32)) || isZero(signature.subarray(32, 64))\n  );\n}\n\nfunction isHash(h) {\n  return h instanceof Uint8Array && h.length === HASH_SIZE;\n}\n\nfunction isExtraData(e) {\n  return (\n    e === undefined || (e instanceof Uint8Array && e.length === EXTRA_DATA_SIZE)\n  );\n}\n\nfunction normalizeScalar(scalar) {\n  let num;\n  if (typeof scalar === \"bigint\") {\n    num = scalar;\n  } else if (\n    typeof scalar === \"number\" &&\n    Number.isSafeInteger(scalar) &&\n    scalar >= 0\n  ) {\n    num = BigInt(scalar);\n  } else if (typeof scalar === \"string\") {\n    if (scalar.length !== 64)\n      throw new Error(\"Expected 32 bytes of private scalar\");\n    num = utils__namespace.hexToNumber(scalar);\n  } else if (scalar instanceof Uint8Array) {\n    if (scalar.length !== 32)\n      throw new Error(\"Expected 32 bytes of private scalar\");\n    num = utils__namespace.bytesToNumberBE(scalar);\n  } else {\n    throw new TypeError(\"Expected valid private scalar\");\n  }\n  if (num < 0) throw new Error(\"Expected private scalar >= 0\");\n  return num;\n}\n\nfunction normalizePrivateKey(privateKey) {\n  return secp256k1.secp256k1.utils.normPrivateKeyToScalar(privateKey);\n}\n\nfunction _privateAdd(privateKey, tweak) {\n  const p = normalizePrivateKey(privateKey);\n  const t = normalizeScalar(tweak);\n  const add = utils__namespace.numberToBytesBE(mod__namespace.mod(p + t, secp256k1.secp256k1.CURVE.n), 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(add) ? add : null;\n}\n\nfunction _privateSub(privateKey, tweak) {\n  const p = normalizePrivateKey(privateKey);\n  const t = normalizeScalar(tweak);\n  const sub = utils__namespace.numberToBytesBE(mod__namespace.mod(p - t, secp256k1.secp256k1.CURVE.n), 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(sub) ? sub : null;\n}\n\nfunction _privateNegate(privateKey) {\n  const p = normalizePrivateKey(privateKey);\n  const not = utils__namespace.numberToBytesBE(secp256k1.secp256k1.CURVE.n - p, 32);\n  return secp256k1.secp256k1.utils.isValidPrivateKey(not) ? not : null;\n}\n\nfunction _pointAddScalar(p, tweak, isCompressed) {\n  const P = fromHex(p);\n  const t = normalizeScalar(tweak);\n  // multiplyAndAddUnsafe(P, scalar, 1) = P + scalar*G\n  const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);\n  if (!Q) throw new Error(\"Tweaked point at infinity\");\n  return Q.toRawBytes(isCompressed);\n}\n\nfunction _pointMultiply(p, tweak, isCompressed) {\n  const P = fromHex(p);\n  const h = typeof tweak === \"string\" ? tweak : utils__namespace.bytesToHex(tweak);\n  const t = utils__namespace.hexToNumber(h);\n  return P.multiply(t).toRawBytes(isCompressed);\n}\n\nfunction assumeCompression(compressed, p) {\n  if (compressed === undefined) {\n    return p !== undefined ? isPointCompressed(p) : true;\n  }\n  return !!compressed;\n}\n\nfunction throwToNull(fn) {\n  try {\n    return fn();\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction fromXOnly(bytes) {\n  return secp256k1.schnorr.utils.lift_x(utils__namespace.bytesToNumberBE(bytes));\n}\n\nfunction fromHex(bytes) {\n  return bytes.length === 32 ? fromXOnly(bytes) : Point.fromHex(bytes);\n}\n\nfunction _isPoint(p, xOnly) {\n  if ((p.length === 32) !== xOnly) return false;\n  try {\n    if (xOnly) return !!fromXOnly(p);\n    else return !!Point.fromHex(p);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction isPoint(p) {\n  return _isPoint(p, false);\n}\n\nfunction isPointCompressed(p) {\n  const PUBLIC_KEY_COMPRESSED_SIZE = 33;\n  return _isPoint(p, false) && p.length === PUBLIC_KEY_COMPRESSED_SIZE;\n}\n\nfunction isPrivate(d) {\n  return secp256k1.secp256k1.utils.isValidPrivateKey(d);\n}\n\nfunction isXOnlyPoint(p) {\n  return _isPoint(p, true);\n}\n\nfunction xOnlyPointAddTweak(p, tweak) {\n  if (!isXOnlyPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => {\n    const P = _pointAddScalar(p, tweak, true);\n    const parity = P[0] % 2 === 1 ? 1 : 0;\n    return { parity, xOnlyPubkey: P.slice(1) };\n  });\n}\n\nfunction xOnlyPointFromPoint(p) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return p.slice(1, 33);\n}\n\nfunction pointFromScalar(sk, compressed) {\n  if (!isPrivate(sk)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return throwToNull(() =>\n    secp256k1.secp256k1.getPublicKey(sk, assumeCompression(compressed)),\n  );\n}\n\nfunction xOnlyPointFromScalar(d) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return xOnlyPointFromPoint(pointFromScalar(d));\n}\n\nfunction pointCompress(p, compressed) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return fromHex(p).toRawBytes(assumeCompression(compressed, p));\n}\n\nfunction pointMultiply(a, tweak, compressed) {\n  if (!isPoint(a)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() =>\n    _pointMultiply(a, tweak, assumeCompression(compressed, a)),\n  );\n}\n\nfunction pointAdd(a, b, compressed) {\n  if (!isPoint(a) || !isPoint(b)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  return throwToNull(() => {\n    const A = fromHex(a);\n    const B = fromHex(b);\n    if (A.equals(B.negate())) {\n      return null;\n    } else {\n      return A.add(B).toRawBytes(assumeCompression(compressed, a));\n    }\n  });\n}\n\nfunction pointAddScalar(p, tweak, compressed) {\n  if (!isPoint(p)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() =>\n    _pointAddScalar(p, tweak, assumeCompression(compressed, p)),\n  );\n}\n\nfunction privateAdd(d, tweak) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => _privateAdd(d, tweak));\n}\n\nfunction privateSub(d, tweak) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isTweak(tweak)) {\n    throw new Error(THROW_BAD_TWEAK);\n  }\n  return throwToNull(() => _privateSub(d, tweak));\n}\n\nfunction privateNegate(d) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  return _privateNegate(d);\n}\n\nfunction sign(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  return secp256k1.secp256k1.sign(h, d, { extraEntropy: e }).toCompactRawBytes();\n}\n\nfunction signRecoverable(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  const sig = secp256k1.secp256k1.sign(h, d, { extraEntropy: e });\n  return {\n    signature: sig.toCompactRawBytes(),\n    recoveryId: sig.recovery,\n  };\n}\n\nfunction signSchnorr(h, d, e) {\n  if (!isPrivate(d)) {\n    throw new Error(THROW_BAD_PRIVATE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  if (!isExtraData(e)) {\n    throw new Error(THROW_BAD_EXTRA_DATA);\n  }\n  return secp256k1.schnorr.sign(h, d, e);\n}\n\nfunction recover(h, signature, recoveryId, compressed) {\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_HASH);\n  }\n\n  if (!isSignature(signature) || !isSignatureNonzeroRS(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n\n  if (recoveryId & 2) {\n    if (!isSigrLessThanPMinusN(signature))\n      throw new Error(THROW_BAD_RECOVERY_ID);\n  }\n  if (!isXOnlyPoint(signature.subarray(0, 32))) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n\n  const s =\n    secp256k1.secp256k1.Signature.fromCompact(signature).addRecoveryBit(recoveryId);\n  const Q = s.recoverPublicKey(h);\n  if (!Q) throw new Error(THROW_BAD_SIGNATURE);\n  return Q.toRawBytes(assumeCompression(compressed));\n}\n\nfunction verify(h, Q, signature, strict) {\n  if (!isPoint(Q)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isSignature(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  return secp256k1.secp256k1.verify(signature, h, Q, { lowS: strict });\n}\n\nfunction verifySchnorr(h, Q, signature) {\n  if (!isXOnlyPoint(Q)) {\n    throw new Error(THROW_BAD_POINT);\n  }\n  if (!isSignature(signature)) {\n    throw new Error(THROW_BAD_SIGNATURE);\n  }\n  if (!isHash(h)) {\n    throw new Error(THROW_BAD_SCALAR);\n  }\n  return secp256k1.schnorr.verify(signature, h, Q);\n}\n\nexports.isPoint = isPoint;\nexports.isPointCompressed = isPointCompressed;\nexports.isPrivate = isPrivate;\nexports.isXOnlyPoint = isXOnlyPoint;\nexports.pointAdd = pointAdd;\nexports.pointAddScalar = pointAddScalar;\nexports.pointCompress = pointCompress;\nexports.pointFromScalar = pointFromScalar;\nexports.pointMultiply = pointMultiply;\nexports.privateAdd = privateAdd;\nexports.privateNegate = privateNegate;\nexports.privateSub = privateSub;\nexports.recover = recover;\nexports.sign = sign;\nexports.signRecoverable = signRecoverable;\nexports.signSchnorr = signSchnorr;\nexports.verify = verify;\nexports.verifySchnorr = verifySchnorr;\nexports.xOnlyPointAddTweak = xOnlyPointAddTweak;\nexports.xOnlyPointFromPoint = xOnlyPointFromPoint;\nexports.xOnlyPointFromScalar = xOnlyPointFromScalar;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGJpdGNvaW5lcmxhYitzZWNwMjU2azFAMS4yLjAvbm9kZV9tb2R1bGVzL0BiaXRjb2luZXJsYWIvc2VjcDI1NmsxL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsdUhBQXlCO0FBQ2pELFVBQVUsbUJBQU8sQ0FBQyxxSUFBZ0M7QUFDbEQsWUFBWSxtQkFBTyxDQUFDLGlJQUE4Qjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlCQUFpQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsWUFBWTtBQUNaLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLDRCQUE0QiIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL0BiaXRjb2luZXJsYWIrc2VjcDI1NmsxQDEuMi4wL25vZGVfbW9kdWxlcy9AYml0Y29pbmVybGFiL3NlY3AyNTZrMS9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJyk7XG52YXIgbW9kID0gcmVxdWlyZSgnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIG1vZF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChtb2QpO1xudmFyIHV0aWxzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KHV0aWxzKTtcblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAyMyBKb3NlLUx1aXMgTGFuZGFiYXNvXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UuXG4gKlxuICogVGhpcyBmaWxlIGluY2x1ZGVzIGNvZGUgZnJvbSB0aGUgZm9sbG93aW5nIHNvdXJjZXM6XG4gKiAgKiBQYXVsIE1pbGxlcidzIEBub2JsZS9zZWNwMjU2azEgKHNwZWNpZmljYWxseSwgdGhlIHByaXZhdGVBZGQsXG4gKiAgICBwcml2YXRlTmVnYXRlLCBwb2ludEFkZFNjYWxhciwgYW5kIHBvaW50TXVsdGlwbHkgZnVuY3Rpb25zKS5cbiAqICAqIFNvbWUgcGllY2VzIGZyb20gdGlueS1zZWNwMjU2azFcbiAqICAgIChodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL3Rpbnktc2VjcDI1NmsxKVxuICogICogSXQgYWxzbyB1c2VzIGNvZGUgZnJvbSBCaXRHbydzIEJpdEdvSlMgbGlicmFyeVxuICogICAgKGh0dHBzOi8vZ2l0aHViLmNvbS9CaXRHby9CaXRHb0pTKVxuICpcbiAqIFRoaXMgcGFja2FnZSdzIHRlc3RzIGFyZSBiYXNlZCBvbiBtb2RpZmllZCB2ZXJzaW9ucyBvZiB0ZXN0cyBmcm9tXG4gKiB0aW55LXNlY3AyNTZrMSAoaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy90aW55LXNlY3AyNTZrMS90ZXN0cykuXG4gKi9cblxuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcblxuY29uc3QgVEhST1dfQkFEX1BSSVZBVEUgPSBcIkV4cGVjdGVkIFByaXZhdGVcIjtcbmNvbnN0IFRIUk9XX0JBRF9QT0lOVCA9IFwiRXhwZWN0ZWQgUG9pbnRcIjtcbmNvbnN0IFRIUk9XX0JBRF9UV0VBSyA9IFwiRXhwZWN0ZWQgVHdlYWtcIjtcbmNvbnN0IFRIUk9XX0JBRF9IQVNIID0gXCJFeHBlY3RlZCBIYXNoXCI7XG5jb25zdCBUSFJPV19CQURfU0lHTkFUVVJFID0gXCJFeHBlY3RlZCBTaWduYXR1cmVcIjtcbmNvbnN0IFRIUk9XX0JBRF9FWFRSQV9EQVRBID0gXCJFeHBlY3RlZCBFeHRyYSBEYXRhICgzMiBieXRlcylcIjtcbmNvbnN0IFRIUk9XX0JBRF9TQ0FMQVIgPSBcIkV4cGVjdGVkIFNjYWxhclwiO1xuY29uc3QgVEhST1dfQkFEX1JFQ09WRVJZX0lEID0gXCJCYWQgUmVjb3ZlcnkgSWRcIjtcblxuY29uc3QgSEFTSF9TSVpFID0gMzI7XG5jb25zdCBUV0VBS19TSVpFID0gMzI7XG5jb25zdCBCTjMyX04gPSBuZXcgVWludDhBcnJheShbXG4gIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsXG4gIDI1NCwgMTg2LCAxNzQsIDIyMCwgMjMwLCAxNzUsIDcyLCAxNjAsIDU5LCAxOTEsIDIxMCwgOTQsIDE0MCwgMjA4LCA1NCwgNjUsIDY1LFxuXSk7XG5jb25zdCBFWFRSQV9EQVRBX1NJWkUgPSAzMjtcbmNvbnN0IEJOMzJfWkVSTyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbmNvbnN0IEJOMzJfUF9NSU5VU19OID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCA2OSwgODEsIDM1LCAyNSwgODAsIDE4MywgOTUsXG4gIDE5NiwgNjQsIDQ1LCAxNjEsIDExNCwgNDcsIDIwMSwgMTg2LCAyMzgsXG5dKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcblxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGNtcEJOMzIoZGF0YTEsIGRhdGEyKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkge1xuICAgIGlmIChkYXRhMVtpXSAhPT0gZGF0YTJbaV0pIHtcbiAgICAgIHJldHVybiBkYXRhMVtpXSA8IGRhdGEyW2ldID8gLTEgOiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaXNaZXJvKHgpIHtcbiAgcmV0dXJuIGNtcEJOMzIoeCwgQk4zMl9aRVJPKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNUd2Vhayh0d2Vhaykge1xuICBpZiAoXG4gICAgISh0d2VhayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8XG4gICAgdHdlYWsubGVuZ3RoICE9PSBUV0VBS19TSVpFIHx8XG4gICAgY21wQk4zMih0d2VhaywgQk4zMl9OKSA+PSAwXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiAoXG4gICAgc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJlxuICAgIHNpZ25hdHVyZS5sZW5ndGggPT09IDY0ICYmXG4gICAgY21wQk4zMihzaWduYXR1cmUuc3ViYXJyYXkoMCwgMzIpLCBCTjMyX04pIDwgMCAmJlxuICAgIGNtcEJOMzIoc2lnbmF0dXJlLnN1YmFycmF5KDMyLCA2NCksIEJOMzJfTikgPCAwXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzU2lnckxlc3NUaGFuUE1pbnVzTihzaWduYXR1cmUpIHtcbiAgcmV0dXJuIChcbiAgICBpc1VpbnQ4QXJyYXkoc2lnbmF0dXJlKSAmJlxuICAgIHNpZ25hdHVyZS5sZW5ndGggPT09IDY0ICYmXG4gICAgY21wQk4zMihzaWduYXR1cmUuc3ViYXJyYXkoMCwgMzIpLCBCTjMyX1BfTUlOVVNfTikgPCAwXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzU2lnbmF0dXJlTm9uemVyb1JTKHNpZ25hdHVyZSkge1xuICByZXR1cm4gIShcbiAgICBpc1plcm8oc2lnbmF0dXJlLnN1YmFycmF5KDAsIDMyKSkgfHwgaXNaZXJvKHNpZ25hdHVyZS5zdWJhcnJheSgzMiwgNjQpKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0hhc2goaCkge1xuICByZXR1cm4gaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaC5sZW5ndGggPT09IEhBU0hfU0laRTtcbn1cblxuZnVuY3Rpb24gaXNFeHRyYURhdGEoZSkge1xuICByZXR1cm4gKFxuICAgIGUgPT09IHVuZGVmaW5lZCB8fCAoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgZS5sZW5ndGggPT09IEVYVFJBX0RBVEFfU0laRSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NhbGFyKHNjYWxhcikge1xuICBsZXQgbnVtO1xuICBpZiAodHlwZW9mIHNjYWxhciA9PT0gXCJiaWdpbnRcIikge1xuICAgIG51bSA9IHNjYWxhcjtcbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlb2Ygc2NhbGFyID09PSBcIm51bWJlclwiICYmXG4gICAgTnVtYmVyLmlzU2FmZUludGVnZXIoc2NhbGFyKSAmJlxuICAgIHNjYWxhciA+PSAwXG4gICkge1xuICAgIG51bSA9IEJpZ0ludChzY2FsYXIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzY2FsYXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoc2NhbGFyLmxlbmd0aCAhPT0gNjQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCAzMiBieXRlcyBvZiBwcml2YXRlIHNjYWxhclwiKTtcbiAgICBudW0gPSB1dGlsc19fbmFtZXNwYWNlLmhleFRvTnVtYmVyKHNjYWxhcik7XG4gIH0gZWxzZSBpZiAoc2NhbGFyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGlmIChzY2FsYXIubGVuZ3RoICE9PSAzMilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIDMyIGJ5dGVzIG9mIHByaXZhdGUgc2NhbGFyXCIpO1xuICAgIG51bSA9IHV0aWxzX19uYW1lc3BhY2UuYnl0ZXNUb051bWJlckJFKHNjYWxhcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHZhbGlkIHByaXZhdGUgc2NhbGFyXCIpO1xuICB9XG4gIGlmIChudW0gPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwcml2YXRlIHNjYWxhciA+PSAwXCIpO1xuICByZXR1cm4gbnVtO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIHNlY3AyNTZrMS5zZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbn1cblxuZnVuY3Rpb24gX3ByaXZhdGVBZGQocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgY29uc3QgcCA9IG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gIGNvbnN0IHQgPSBub3JtYWxpemVTY2FsYXIodHdlYWspO1xuICBjb25zdCBhZGQgPSB1dGlsc19fbmFtZXNwYWNlLm51bWJlclRvQnl0ZXNCRShtb2RfX25hbWVzcGFjZS5tb2QocCArIHQsIHNlY3AyNTZrMS5zZWNwMjU2azEuQ1VSVkUubiksIDMyKTtcbiAgcmV0dXJuIHNlY3AyNTZrMS5zZWNwMjU2azEudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoYWRkKSA/IGFkZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIF9wcml2YXRlU3ViKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIGNvbnN0IHAgPSBub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICBjb25zdCB0ID0gbm9ybWFsaXplU2NhbGFyKHR3ZWFrKTtcbiAgY29uc3Qgc3ViID0gdXRpbHNfX25hbWVzcGFjZS5udW1iZXJUb0J5dGVzQkUobW9kX19uYW1lc3BhY2UubW9kKHAgLSB0LCBzZWNwMjU2azEuc2VjcDI1NmsxLkNVUlZFLm4pLCAzMik7XG4gIHJldHVybiBzZWNwMjU2azEuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KHN1YikgPyBzdWIgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBfcHJpdmF0ZU5lZ2F0ZShwcml2YXRlS2V5KSB7XG4gIGNvbnN0IHAgPSBub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICBjb25zdCBub3QgPSB1dGlsc19fbmFtZXNwYWNlLm51bWJlclRvQnl0ZXNCRShzZWNwMjU2azEuc2VjcDI1NmsxLkNVUlZFLm4gLSBwLCAzMik7XG4gIHJldHVybiBzZWNwMjU2azEuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KG5vdCkgPyBub3QgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBfcG9pbnRBZGRTY2FsYXIocCwgdHdlYWssIGlzQ29tcHJlc3NlZCkge1xuICBjb25zdCBQID0gZnJvbUhleChwKTtcbiAgY29uc3QgdCA9IG5vcm1hbGl6ZVNjYWxhcih0d2Vhayk7XG4gIC8vIG11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHNjYWxhciwgMSkgPSBQICsgc2NhbGFyKkdcbiAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdCwgXzFuKTtcbiAgaWYgKCFRKSB0aHJvdyBuZXcgRXJyb3IoXCJUd2Vha2VkIHBvaW50IGF0IGluZmluaXR5XCIpO1xuICByZXR1cm4gUS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5cbmZ1bmN0aW9uIF9wb2ludE11bHRpcGx5KHAsIHR3ZWFrLCBpc0NvbXByZXNzZWQpIHtcbiAgY29uc3QgUCA9IGZyb21IZXgocCk7XG4gIGNvbnN0IGggPSB0eXBlb2YgdHdlYWsgPT09IFwic3RyaW5nXCIgPyB0d2VhayA6IHV0aWxzX19uYW1lc3BhY2UuYnl0ZXNUb0hleCh0d2Vhayk7XG4gIGNvbnN0IHQgPSB1dGlsc19fbmFtZXNwYWNlLmhleFRvTnVtYmVyKGgpO1xuICByZXR1cm4gUC5tdWx0aXBseSh0KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG59XG5cbmZ1bmN0aW9uIGFzc3VtZUNvbXByZXNzaW9uKGNvbXByZXNzZWQsIHApIHtcbiAgaWYgKGNvbXByZXNzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwICE9PSB1bmRlZmluZWQgPyBpc1BvaW50Q29tcHJlc3NlZChwKSA6IHRydWU7XG4gIH1cbiAgcmV0dXJuICEhY29tcHJlc3NlZDtcbn1cblxuZnVuY3Rpb24gdGhyb3dUb051bGwoZm4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZyb21YT25seShieXRlcykge1xuICByZXR1cm4gc2VjcDI1NmsxLnNjaG5vcnIudXRpbHMubGlmdF94KHV0aWxzX19uYW1lc3BhY2UuYnl0ZXNUb051bWJlckJFKGJ5dGVzKSk7XG59XG5cbmZ1bmN0aW9uIGZyb21IZXgoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzLmxlbmd0aCA9PT0gMzIgPyBmcm9tWE9ubHkoYnl0ZXMpIDogUG9pbnQuZnJvbUhleChieXRlcyk7XG59XG5cbmZ1bmN0aW9uIF9pc1BvaW50KHAsIHhPbmx5KSB7XG4gIGlmICgocC5sZW5ndGggPT09IDMyKSAhPT0geE9ubHkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBpZiAoeE9ubHkpIHJldHVybiAhIWZyb21YT25seShwKTtcbiAgICBlbHNlIHJldHVybiAhIVBvaW50LmZyb21IZXgocCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQb2ludChwKSB7XG4gIHJldHVybiBfaXNQb2ludChwLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRDb21wcmVzc2VkKHApIHtcbiAgY29uc3QgUFVCTElDX0tFWV9DT01QUkVTU0VEX1NJWkUgPSAzMztcbiAgcmV0dXJuIF9pc1BvaW50KHAsIGZhbHNlKSAmJiBwLmxlbmd0aCA9PT0gUFVCTElDX0tFWV9DT01QUkVTU0VEX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGlzUHJpdmF0ZShkKSB7XG4gIHJldHVybiBzZWNwMjU2azEuc2VjcDI1NmsxLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KGQpO1xufVxuXG5mdW5jdGlvbiBpc1hPbmx5UG9pbnQocCkge1xuICByZXR1cm4gX2lzUG9pbnQocCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHhPbmx5UG9pbnRBZGRUd2VhayhwLCB0d2Vhaykge1xuICBpZiAoIWlzWE9ubHlQb2ludChwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUE9JTlQpO1xuICB9XG4gIGlmICghaXNUd2Vhayh0d2VhaykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1RXRUFLKTtcbiAgfVxuICByZXR1cm4gdGhyb3dUb051bGwoKCkgPT4ge1xuICAgIGNvbnN0IFAgPSBfcG9pbnRBZGRTY2FsYXIocCwgdHdlYWssIHRydWUpO1xuICAgIGNvbnN0IHBhcml0eSA9IFBbMF0gJSAyID09PSAxID8gMSA6IDA7XG4gICAgcmV0dXJuIHsgcGFyaXR5LCB4T25seVB1YmtleTogUC5zbGljZSgxKSB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24geE9ubHlQb2ludEZyb21Qb2ludChwKSB7XG4gIGlmICghaXNQb2ludChwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUE9JTlQpO1xuICB9XG4gIHJldHVybiBwLnNsaWNlKDEsIDMzKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRGcm9tU2NhbGFyKHNrLCBjb21wcmVzc2VkKSB7XG4gIGlmICghaXNQcml2YXRlKHNrKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUFJJVkFURSk7XG4gIH1cbiAgcmV0dXJuIHRocm93VG9OdWxsKCgpID0+XG4gICAgc2VjcDI1NmsxLnNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoc2ssIGFzc3VtZUNvbXByZXNzaW9uKGNvbXByZXNzZWQpKSxcbiAgKTtcbn1cblxuZnVuY3Rpb24geE9ubHlQb2ludEZyb21TY2FsYXIoZCkge1xuICBpZiAoIWlzUHJpdmF0ZShkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUFJJVkFURSk7XG4gIH1cbiAgcmV0dXJuIHhPbmx5UG9pbnRGcm9tUG9pbnQocG9pbnRGcm9tU2NhbGFyKGQpKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRDb21wcmVzcyhwLCBjb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUE9JTlQpO1xuICB9XG4gIHJldHVybiBmcm9tSGV4KHApLnRvUmF3Qnl0ZXMoYXNzdW1lQ29tcHJlc3Npb24oY29tcHJlc3NlZCwgcCkpO1xufVxuXG5mdW5jdGlvbiBwb2ludE11bHRpcGx5KGEsIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUE9JTlQpO1xuICB9XG4gIGlmICghaXNUd2Vhayh0d2VhaykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1RXRUFLKTtcbiAgfVxuICByZXR1cm4gdGhyb3dUb051bGwoKCkgPT5cbiAgICBfcG9pbnRNdWx0aXBseShhLCB0d2VhaywgYXNzdW1lQ29tcHJlc3Npb24oY29tcHJlc3NlZCwgYSkpLFxuICApO1xufVxuXG5mdW5jdGlvbiBwb2ludEFkZChhLCBiLCBjb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChhKSB8fCAhaXNQb2ludChiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUE9JTlQpO1xuICB9XG4gIHJldHVybiB0aHJvd1RvTnVsbCgoKSA9PiB7XG4gICAgY29uc3QgQSA9IGZyb21IZXgoYSk7XG4gICAgY29uc3QgQiA9IGZyb21IZXgoYik7XG4gICAgaWYgKEEuZXF1YWxzKEIubmVnYXRlKCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEEuYWRkKEIpLnRvUmF3Qnl0ZXMoYXNzdW1lQ29tcHJlc3Npb24oY29tcHJlc3NlZCwgYSkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvaW50QWRkU2NhbGFyKHAsIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUE9JTlQpO1xuICB9XG4gIGlmICghaXNUd2Vhayh0d2VhaykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1RXRUFLKTtcbiAgfVxuICByZXR1cm4gdGhyb3dUb051bGwoKCkgPT5cbiAgICBfcG9pbnRBZGRTY2FsYXIocCwgdHdlYWssIGFzc3VtZUNvbXByZXNzaW9uKGNvbXByZXNzZWQsIHApKSxcbiAgKTtcbn1cblxuZnVuY3Rpb24gcHJpdmF0ZUFkZChkLCB0d2Vhaykge1xuICBpZiAoIWlzUHJpdmF0ZShkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUFJJVkFURSk7XG4gIH1cbiAgaWYgKCFpc1R3ZWFrKHR3ZWFrKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfVFdFQUspO1xuICB9XG4gIHJldHVybiB0aHJvd1RvTnVsbCgoKSA9PiBfcHJpdmF0ZUFkZChkLCB0d2VhaykpO1xufVxuXG5mdW5jdGlvbiBwcml2YXRlU3ViKGQsIHR3ZWFrKSB7XG4gIGlmICghaXNQcml2YXRlKGQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFRIUk9XX0JBRF9QUklWQVRFKTtcbiAgfVxuICBpZiAoIWlzVHdlYWsodHdlYWspKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFRIUk9XX0JBRF9UV0VBSyk7XG4gIH1cbiAgcmV0dXJuIHRocm93VG9OdWxsKCgpID0+IF9wcml2YXRlU3ViKGQsIHR3ZWFrKSk7XG59XG5cbmZ1bmN0aW9uIHByaXZhdGVOZWdhdGUoZCkge1xuICBpZiAoIWlzUHJpdmF0ZShkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUFJJVkFURSk7XG4gIH1cbiAgcmV0dXJuIF9wcml2YXRlTmVnYXRlKGQpO1xufVxuXG5mdW5jdGlvbiBzaWduKGgsIGQsIGUpIHtcbiAgaWYgKCFpc1ByaXZhdGUoZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1BSSVZBVEUpO1xuICB9XG4gIGlmICghaXNIYXNoKGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFRIUk9XX0JBRF9TQ0FMQVIpO1xuICB9XG4gIGlmICghaXNFeHRyYURhdGEoZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX0VYVFJBX0RBVEEpO1xuICB9XG4gIHJldHVybiBzZWNwMjU2azEuc2VjcDI1NmsxLnNpZ24oaCwgZCwgeyBleHRyYUVudHJvcHk6IGUgfSkudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbn1cblxuZnVuY3Rpb24gc2lnblJlY292ZXJhYmxlKGgsIGQsIGUpIHtcbiAgaWYgKCFpc1ByaXZhdGUoZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1BSSVZBVEUpO1xuICB9XG4gIGlmICghaXNIYXNoKGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFRIUk9XX0JBRF9TQ0FMQVIpO1xuICB9XG4gIGlmICghaXNFeHRyYURhdGEoZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX0VYVFJBX0RBVEEpO1xuICB9XG4gIGNvbnN0IHNpZyA9IHNlY3AyNTZrMS5zZWNwMjU2azEuc2lnbihoLCBkLCB7IGV4dHJhRW50cm9weTogZSB9KTtcbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IHNpZy50b0NvbXBhY3RSYXdCeXRlcygpLFxuICAgIHJlY292ZXJ5SWQ6IHNpZy5yZWNvdmVyeSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2lnblNjaG5vcnIoaCwgZCwgZSkge1xuICBpZiAoIWlzUHJpdmF0ZShkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUFJJVkFURSk7XG4gIH1cbiAgaWYgKCFpc0hhc2goaCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1NDQUxBUik7XG4gIH1cbiAgaWYgKCFpc0V4dHJhRGF0YShlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfRVhUUkFfREFUQSk7XG4gIH1cbiAgcmV0dXJuIHNlY3AyNTZrMS5zY2hub3JyLnNpZ24oaCwgZCwgZSk7XG59XG5cbmZ1bmN0aW9uIHJlY292ZXIoaCwgc2lnbmF0dXJlLCByZWNvdmVyeUlkLCBjb21wcmVzc2VkKSB7XG4gIGlmICghaXNIYXNoKGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFRIUk9XX0JBRF9IQVNIKTtcbiAgfVxuXG4gIGlmICghaXNTaWduYXR1cmUoc2lnbmF0dXJlKSB8fCAhaXNTaWduYXR1cmVOb256ZXJvUlMoc2lnbmF0dXJlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfU0lHTkFUVVJFKTtcbiAgfVxuXG4gIGlmIChyZWNvdmVyeUlkICYgMikge1xuICAgIGlmICghaXNTaWdyTGVzc1RoYW5QTWludXNOKHNpZ25hdHVyZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1JFQ09WRVJZX0lEKTtcbiAgfVxuICBpZiAoIWlzWE9ubHlQb2ludChzaWduYXR1cmUuc3ViYXJyYXkoMCwgMzIpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfU0lHTkFUVVJFKTtcbiAgfVxuXG4gIGNvbnN0IHMgPVxuICAgIHNlY3AyNTZrMS5zZWNwMjU2azEuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSkuYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnlJZCk7XG4gIGNvbnN0IFEgPSBzLnJlY292ZXJQdWJsaWNLZXkoaCk7XG4gIGlmICghUSkgdGhyb3cgbmV3IEVycm9yKFRIUk9XX0JBRF9TSUdOQVRVUkUpO1xuICByZXR1cm4gUS50b1Jhd0J5dGVzKGFzc3VtZUNvbXByZXNzaW9uKGNvbXByZXNzZWQpKTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5KGgsIFEsIHNpZ25hdHVyZSwgc3RyaWN0KSB7XG4gIGlmICghaXNQb2ludChRKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfUE9JTlQpO1xuICB9XG4gIGlmICghaXNTaWduYXR1cmUoc2lnbmF0dXJlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfU0lHTkFUVVJFKTtcbiAgfVxuICBpZiAoIWlzSGFzaChoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihUSFJPV19CQURfU0NBTEFSKTtcbiAgfVxuICByZXR1cm4gc2VjcDI1NmsxLnNlY3AyNTZrMS52ZXJpZnkoc2lnbmF0dXJlLCBoLCBRLCB7IGxvd1M6IHN0cmljdCB9KTtcbn1cblxuZnVuY3Rpb24gdmVyaWZ5U2Nobm9ycihoLCBRLCBzaWduYXR1cmUpIHtcbiAgaWYgKCFpc1hPbmx5UG9pbnQoUSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1BPSU5UKTtcbiAgfVxuICBpZiAoIWlzU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1NJR05BVFVSRSk7XG4gIH1cbiAgaWYgKCFpc0hhc2goaCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoVEhST1dfQkFEX1NDQUxBUik7XG4gIH1cbiAgcmV0dXJuIHNlY3AyNTZrMS5zY2hub3JyLnZlcmlmeShzaWduYXR1cmUsIGgsIFEpO1xufVxuXG5leHBvcnRzLmlzUG9pbnQgPSBpc1BvaW50O1xuZXhwb3J0cy5pc1BvaW50Q29tcHJlc3NlZCA9IGlzUG9pbnRDb21wcmVzc2VkO1xuZXhwb3J0cy5pc1ByaXZhdGUgPSBpc1ByaXZhdGU7XG5leHBvcnRzLmlzWE9ubHlQb2ludCA9IGlzWE9ubHlQb2ludDtcbmV4cG9ydHMucG9pbnRBZGQgPSBwb2ludEFkZDtcbmV4cG9ydHMucG9pbnRBZGRTY2FsYXIgPSBwb2ludEFkZFNjYWxhcjtcbmV4cG9ydHMucG9pbnRDb21wcmVzcyA9IHBvaW50Q29tcHJlc3M7XG5leHBvcnRzLnBvaW50RnJvbVNjYWxhciA9IHBvaW50RnJvbVNjYWxhcjtcbmV4cG9ydHMucG9pbnRNdWx0aXBseSA9IHBvaW50TXVsdGlwbHk7XG5leHBvcnRzLnByaXZhdGVBZGQgPSBwcml2YXRlQWRkO1xuZXhwb3J0cy5wcml2YXRlTmVnYXRlID0gcHJpdmF0ZU5lZ2F0ZTtcbmV4cG9ydHMucHJpdmF0ZVN1YiA9IHByaXZhdGVTdWI7XG5leHBvcnRzLnJlY292ZXIgPSByZWNvdmVyO1xuZXhwb3J0cy5zaWduID0gc2lnbjtcbmV4cG9ydHMuc2lnblJlY292ZXJhYmxlID0gc2lnblJlY292ZXJhYmxlO1xuZXhwb3J0cy5zaWduU2Nobm9yciA9IHNpZ25TY2hub3JyO1xuZXhwb3J0cy52ZXJpZnkgPSB2ZXJpZnk7XG5leHBvcnRzLnZlcmlmeVNjaG5vcnIgPSB2ZXJpZnlTY2hub3JyO1xuZXhwb3J0cy54T25seVBvaW50QWRkVHdlYWsgPSB4T25seVBvaW50QWRkVHdlYWs7XG5leHBvcnRzLnhPbmx5UG9pbnRGcm9tUG9pbnQgPSB4T25seVBvaW50RnJvbVBvaW50O1xuZXhwb3J0cy54T25seVBvaW50RnJvbVNjYWxhciA9IHhPbmx5UG9pbnRGcm9tU2NhbGFyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@bitcoinerlab+secp256k1@1.2.0/node_modules/@bitcoinerlab/secp256k1/dist/index.js\n");

/***/ })

};
;