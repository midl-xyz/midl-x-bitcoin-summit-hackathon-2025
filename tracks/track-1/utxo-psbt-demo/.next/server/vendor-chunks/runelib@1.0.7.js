"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/runelib@1.0.7";
exports.ids = ["vendor-chunks/runelib@1.0.7"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/base26.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/base26.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.base26Decode = exports.base26Encode = void 0;\nfunction base26Encode(input) {\n    let result = 0n;\n    for (let i = 0; i < input.length; i++) {\n        const charCode = BigInt(input.charCodeAt(i) - 'A'.charCodeAt(0));\n        const iInv = BigInt(input.length) - 1n - BigInt(i);\n        if (iInv == 0n) {\n            result += charCode;\n        }\n        else {\n            const base = 26n ** iInv;\n            result += base * (charCode + 1n);\n        }\n    }\n    return result;\n}\nexports.base26Encode = base26Encode;\nfunction base26Decode(s) {\n    if (s === 340282366920938463463374607431768211455n) {\n        return \"BCGDENLQRQWDSLRUGSNLBTMFIJAV\";\n    }\n    s += 1n;\n    let symbol = [];\n    while (s > 0) {\n        const i = (s - 1n) % 26n;\n        symbol.push(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".charAt(Number(i)));\n        s = (s - 1n) / 26n;\n    }\n    return symbol.reverse().join('');\n}\nexports.base26Decode = base26Decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWxpYkAxLjAuNy9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2Jhc2UyNi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0M7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyIvVXNlcnMvYnRjL21pZGwteC1iaXRjb2luLXN1bW1pdC1oYWNrYXRob24tMjAyNS91dHhvLXBzYnQtZGVtby9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWxpYkAxLjAuNy9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2Jhc2UyNi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTI2RGVjb2RlID0gZXhwb3J0cy5iYXNlMjZFbmNvZGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBiYXNlMjZFbmNvZGUoaW5wdXQpIHtcbiAgICBsZXQgcmVzdWx0ID0gMG47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IEJpZ0ludChpbnB1dC5jaGFyQ29kZUF0KGkpIC0gJ0EnLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICBjb25zdCBpSW52ID0gQmlnSW50KGlucHV0Lmxlbmd0aCkgLSAxbiAtIEJpZ0ludChpKTtcbiAgICAgICAgaWYgKGlJbnYgPT0gMG4pIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2UgPSAyNm4gKiogaUludjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBiYXNlICogKGNoYXJDb2RlICsgMW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmJhc2UyNkVuY29kZSA9IGJhc2UyNkVuY29kZTtcbmZ1bmN0aW9uIGJhc2UyNkRlY29kZShzKSB7XG4gICAgaWYgKHMgPT09IDM0MDI4MjM2NjkyMDkzODQ2MzQ2MzM3NDYwNzQzMTc2ODIxMTQ1NW4pIHtcbiAgICAgICAgcmV0dXJuIFwiQkNHREVOTFFSUVdEU0xSVUdTTkxCVE1GSUpBVlwiO1xuICAgIH1cbiAgICBzICs9IDFuO1xuICAgIGxldCBzeW1ib2wgPSBbXTtcbiAgICB3aGlsZSAocyA+IDApIHtcbiAgICAgICAgY29uc3QgaSA9IChzIC0gMW4pICUgMjZuO1xuICAgICAgICBzeW1ib2wucHVzaChcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIuY2hhckF0KE51bWJlcihpKSkpO1xuICAgICAgICBzID0gKHMgLSAxbikgLyAyNm47XG4gICAgfVxuICAgIHJldHVybiBzeW1ib2wucmV2ZXJzZSgpLmpvaW4oJycpO1xufVxuZXhwb3J0cy5iYXNlMjZEZWNvZGUgPSBiYXNlMjZEZWNvZGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/base26.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/fts.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/fts.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.none = exports.some = void 0;\nclass None {\n    constructor() { }\n    isSome() {\n        return false;\n    }\n    map(f) {\n        return new None();\n    }\n    value() {\n        return null;\n    }\n}\nclass Some {\n    constructor(value) {\n        this._value = value;\n    }\n    isSome() {\n        return true;\n    }\n    map(f) {\n        return new Some(f(this.value()));\n    }\n    value() {\n        return this._value;\n    }\n}\nfunction some(t) {\n    return new Some(t);\n}\nexports.some = some;\nfunction none() {\n    return new None();\n}\nexports.none = none;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWxpYkAxLjAuNy9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2Z0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9ydW5lbGliQDEuMC43L25vZGVfbW9kdWxlcy9ydW5lbGliL2Rpc3QvZnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub25lID0gZXhwb3J0cy5zb21lID0gdm9pZCAwO1xuY2xhc3MgTm9uZSB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICBpc1NvbWUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbWFwKGYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb25lKCk7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBTb21lIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc1NvbWUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBtYXAoZikge1xuICAgICAgICByZXR1cm4gbmV3IFNvbWUoZih0aGlzLnZhbHVlKCkpKTtcbiAgICB9XG4gICAgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBzb21lKHQpIHtcbiAgICByZXR1cm4gbmV3IFNvbWUodCk7XG59XG5leHBvcnRzLnNvbWUgPSBzb21lO1xuZnVuY3Rpb24gbm9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE5vbmUoKTtcbn1cbmV4cG9ydHMubm9uZSA9IG5vbmU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/fts.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeSpacers = exports.getSpacersVal = exports.applySpacers = exports.some = exports.none = void 0;\n__exportStar(__webpack_require__(/*! ./runestones */ \"(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/runestones.js\"), exports);\nvar fts_1 = __webpack_require__(/*! ./fts */ \"(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/fts.js\");\nObject.defineProperty(exports, \"none\", ({ enumerable: true, get: function () { return fts_1.none; } }));\nObject.defineProperty(exports, \"some\", ({ enumerable: true, get: function () { return fts_1.some; } }));\nvar spacers_1 = __webpack_require__(/*! ./spacers */ \"(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/spacers.js\");\nObject.defineProperty(exports, \"applySpacers\", ({ enumerable: true, get: function () { return spacers_1.applySpacers; } }));\nObject.defineProperty(exports, \"getSpacersVal\", ({ enumerable: true, get: function () { return spacers_1.getSpacersVal; } }));\nObject.defineProperty(exports, \"removeSpacers\", ({ enumerable: true, get: function () { return spacers_1.removeSpacers; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWxpYkAxLjAuNy9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQixHQUFHLFlBQVksR0FBRyxZQUFZO0FBQ2xHLGFBQWEsbUJBQU8sQ0FBQyxzR0FBYztBQUNuQyxZQUFZLG1CQUFPLENBQUMsd0ZBQU87QUFDM0Isd0NBQXVDLEVBQUUscUNBQXFDLHNCQUFzQixFQUFDO0FBQ3JHLHdDQUF1QyxFQUFFLHFDQUFxQyxzQkFBc0IsRUFBQztBQUNyRyxnQkFBZ0IsbUJBQU8sQ0FBQyxnR0FBVztBQUNuQyxnREFBK0MsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDekgsaURBQWdELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzNILGlEQUFnRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL3J1bmVsaWJAMS4wLjcvbm9kZV9tb2R1bGVzL3J1bmVsaWIvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZW1vdmVTcGFjZXJzID0gZXhwb3J0cy5nZXRTcGFjZXJzVmFsID0gZXhwb3J0cy5hcHBseVNwYWNlcnMgPSBleHBvcnRzLnNvbWUgPSBleHBvcnRzLm5vbmUgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcnVuZXN0b25lc1wiKSwgZXhwb3J0cyk7XG52YXIgZnRzXzEgPSByZXF1aXJlKFwiLi9mdHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub25lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmdHNfMS5ub25lOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic29tZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZnRzXzEuc29tZTsgfSB9KTtcbnZhciBzcGFjZXJzXzEgPSByZXF1aXJlKFwiLi9zcGFjZXJzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBwbHlTcGFjZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzcGFjZXJzXzEuYXBwbHlTcGFjZXJzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0U3BhY2Vyc1ZhbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3BhY2Vyc18xLmdldFNwYWNlcnNWYWw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVTcGFjZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzcGFjZXJzXzEucmVtb3ZlU3BhY2VyczsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/leb128.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/leb128.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeLEB128 = exports.encodeLEB128 = void 0;\nfunction encodeLEB128(value) {\n    const bytes = [];\n    let more = true;\n    while (more) {\n        let byte = Number(value & BigInt(0x7F)); // Get the lowest 7 bits\n        value >>= BigInt(7);\n        if (value === BigInt(0)) { // No more data to encode\n            more = false;\n        }\n        else { // More bytes to come\n            byte |= 0x80; // Set the continuation bit\n        }\n        bytes.push(byte);\n    }\n    // Convert array to Buffer\n    return bytes;\n}\nexports.encodeLEB128 = encodeLEB128;\nfunction decodeLEB128(buf) {\n    let n = BigInt(0);\n    for (let i = 0; i < buf.length; i++) {\n        const byte = BigInt(buf[i]);\n        if (i > 18) {\n            throw new Error(\"Overlong\");\n        }\n        let value = byte & BigInt(127);\n        if ((i == 18) && ((value & BigInt(124)) != BigInt(0))) {\n            throw new Error(\"Overflow\");\n        }\n        n |= value << (BigInt(7) * BigInt(i));\n        if ((byte & BigInt(128)) == BigInt(0)) {\n            return {\n                n,\n                len: i + 1\n            };\n        }\n    }\n    throw new Error(\"Unterminated\");\n}\nexports.decodeLEB128 = decodeLEB128;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWxpYkAxLjAuNy9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L2xlYjEyOC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLGVBQWU7QUFDZiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL2J0Yy9taWRsLXgtYml0Y29pbi1zdW1taXQtaGFja2F0aG9uLTIwMjUvdXR4by1wc2J0LWRlbW8vbm9kZV9tb2R1bGVzLy5wbnBtL3J1bmVsaWJAMS4wLjcvbm9kZV9tb2R1bGVzL3J1bmVsaWIvZGlzdC9sZWIxMjguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUxFQjEyOCA9IGV4cG9ydHMuZW5jb2RlTEVCMTI4ID0gdm9pZCAwO1xuZnVuY3Rpb24gZW5jb2RlTEVCMTI4KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgICBsZXQgbW9yZSA9IHRydWU7XG4gICAgd2hpbGUgKG1vcmUpIHtcbiAgICAgICAgbGV0IGJ5dGUgPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHg3RikpOyAvLyBHZXQgdGhlIGxvd2VzdCA3IGJpdHNcbiAgICAgICAgdmFsdWUgPj49IEJpZ0ludCg3KTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBCaWdJbnQoMCkpIHsgLy8gTm8gbW9yZSBkYXRhIHRvIGVuY29kZVxuICAgICAgICAgICAgbW9yZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNb3JlIGJ5dGVzIHRvIGNvbWVcbiAgICAgICAgICAgIGJ5dGUgfD0gMHg4MDsgLy8gU2V0IHRoZSBjb250aW51YXRpb24gYml0XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBhcnJheSB0byBCdWZmZXJcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLmVuY29kZUxFQjEyOCA9IGVuY29kZUxFQjEyODtcbmZ1bmN0aW9uIGRlY29kZUxFQjEyOChidWYpIHtcbiAgICBsZXQgbiA9IEJpZ0ludCgwKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBieXRlID0gQmlnSW50KGJ1ZltpXSk7XG4gICAgICAgIGlmIChpID4gMTgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk92ZXJsb25nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZSA9IGJ5dGUgJiBCaWdJbnQoMTI3KTtcbiAgICAgICAgaWYgKChpID09IDE4KSAmJiAoKHZhbHVlICYgQmlnSW50KDEyNCkpICE9IEJpZ0ludCgwKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIG4gfD0gdmFsdWUgPDwgKEJpZ0ludCg3KSAqIEJpZ0ludChpKSk7XG4gICAgICAgIGlmICgoYnl0ZSAmIEJpZ0ludCgxMjgpKSA9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICBsZW46IGkgKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVudGVybWluYXRlZFwiKTtcbn1cbmV4cG9ydHMuZGVjb2RlTEVCMTI4ID0gZGVjb2RlTEVCMTI4O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/leb128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/runestones.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/runestones.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EtchInscription = exports.Message = exports.Runestone = exports.Etching = exports.Rune = exports.Terms = exports.Range = exports.Flaw = exports.Tag = exports.Flag = exports.Edict = exports.RuneId = void 0;\nconst bitcoinjs_lib_1 = __webpack_require__(/*! bitcoinjs-lib */ \"(ssr)/./node_modules/.pnpm/bitcoinjs-lib@6.1.7/node_modules/bitcoinjs-lib/src/index.js\");\nconst base26_1 = __webpack_require__(/*! ./base26 */ \"(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/base26.js\");\nconst fts_1 = __webpack_require__(/*! ./fts */ \"(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/fts.js\");\nconst leb128_1 = __webpack_require__(/*! ./leb128 */ \"(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/leb128.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/utils.js\");\nconst spacers_1 = __webpack_require__(/*! ./spacers */ \"(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/spacers.js\");\n/**\n * Rune IDs are represented in text as BLOCK:TX.\n */\nclass RuneId {\n    constructor(block, idx) {\n        this.block = block;\n        this.idx = idx;\n    }\n    next(block, idx) {\n        if (block > BigInt(Number.MAX_SAFE_INTEGER)) {\n            return (0, fts_1.none)();\n        }\n        if (idx > BigInt(Number.MAX_SAFE_INTEGER)) {\n            return (0, fts_1.none)();\n        }\n        let b = BigInt(this.block) + block;\n        if (b > BigInt(Number.MAX_SAFE_INTEGER)) {\n            return (0, fts_1.none)();\n        }\n        let i = block === 0n ? BigInt(this.idx) + idx : idx;\n        if (i > BigInt(Number.MAX_SAFE_INTEGER)) {\n            return (0, fts_1.none)();\n        }\n        return (0, fts_1.some)(new RuneId(Number(b), Number(i)));\n    }\n}\nexports.RuneId = RuneId;\n/**\n * Rune ID block heights and transaction indices in edicts are delta encoded.\n * Edict rune ID decoding starts with a base block height and transaction index of zero.\n * When decoding each rune ID, first the encoded block height delta is added to the base block height.\n * If the block height delta is zero, the next integer is a transaction index delta.\n * If the block height delta is greater than zero, the next integer is instead an absolute transaction index.\n */\nclass Edict {\n    constructor(id, amount, output) {\n        this.id = id;\n        this.amount = amount;\n        this.output = output;\n    }\n    static from_integers(tx, id, amount, output) {\n        if (output > 4294967295n || output < 0n) {\n            return (0, fts_1.none)();\n        }\n        if (Number(output) > tx.outs.length) {\n            return (0, fts_1.none)();\n        }\n        return (0, fts_1.some)(new Edict(id, amount, Number(output)));\n    }\n}\nexports.Edict = Edict;\nvar Flag;\n(function (Flag) {\n    /** The Etching flag marks this transaction as containing an etching. */\n    Flag[Flag[\"Etching\"] = 0] = \"Etching\";\n    /** The Terms flag marks this transaction's etching as having open mint terms. */\n    Flag[Flag[\"Terms\"] = 1] = \"Terms\";\n    /** The Turbo flag marks this transaction's etching as opting into future protocol changes. These protocol changes may increase light client validation costs, or just be highly degenerate. */\n    Flag[Flag[\"Turbo\"] = 2] = \"Turbo\";\n    /** The Cenotaph flag is unrecognized. */\n    Flag[Flag[\"Cenotaph\"] = 127] = \"Cenotaph\";\n})(Flag || (exports.Flag = Flag = {}));\nvar Tag;\n(function (Tag) {\n    /** The Body tag marks the end of the runestone's fields, causing all following integers to be interpreted as edicts. */\n    Tag[Tag[\"Body\"] = 0] = \"Body\";\n    /** The Flag field contains a bitmap of flags, whose position is 1 << FLAG_VALUE: */\n    Tag[Tag[\"Flags\"] = 2] = \"Flags\";\n    /** The Rune field contains the name of the rune being etched. If the Etching flag is set but the Rune field is omitted, a reserved rune name is allocated. */\n    Tag[Tag[\"Rune\"] = 4] = \"Rune\";\n    /** The Premine field contains the amount of premined runes. */\n    Tag[Tag[\"Premine\"] = 6] = \"Premine\";\n    /** The Cap field contains the allowed number of mints. */\n    Tag[Tag[\"Cap\"] = 8] = \"Cap\";\n    /** The Amount field contains the amount of runes each mint transaction receives. */\n    Tag[Tag[\"Amount\"] = 10] = \"Amount\";\n    /** The HeightStart and HeightEnd fields contain the mint's starting and ending absolute block heights, respectively. The mint is open starting in the block with height HeightStart, and closes in the block with height HeightEnd. */\n    Tag[Tag[\"HeightStart\"] = 12] = \"HeightStart\";\n    Tag[Tag[\"HeightEnd\"] = 14] = \"HeightEnd\";\n    /** The OffsetStart and OffsetEnd fields contain the mint's starting and ending block heights, relative to the block in which the etching is mined. The mint is open starting in the block with height OffsetStart + ETCHING_HEIGHT, and closes in the block with height OffsetEnd + ETCHING_HEIGHT. */\n    Tag[Tag[\"OffsetStart\"] = 16] = \"OffsetStart\";\n    Tag[Tag[\"OffsetEnd\"] = 18] = \"OffsetEnd\";\n    /** The Mint field contains the Rune ID of the rune to be minted in this transaction. */\n    Tag[Tag[\"Mint\"] = 20] = \"Mint\";\n    /** The Pointer field contains the index of the output to which runes unallocated by edicts should be transferred. If the Pointer field is absent, unallocated runes are transferred to the first non-OP_RETURN output. */\n    Tag[Tag[\"Pointer\"] = 22] = \"Pointer\";\n    /** The Cenotaph field is unrecognized. */\n    Tag[Tag[\"Cenotaph\"] = 126] = \"Cenotaph\";\n    /** The Divisibility field, raised to the power of ten, is the number of subunits in a super unit of runes. */\n    Tag[Tag[\"Divisibility\"] = 1] = \"Divisibility\";\n    /** The Spacers field is a bitfield of • spacers that should be displayed between the letters of the rune's name. Trailing spacers are ignored. */\n    Tag[Tag[\"Spacers\"] = 3] = \"Spacers\";\n    /** The Symbol field is the Unicode codepoint of the Rune's currency symbol,\n     * which should be displayed after amounts of that rune. If a rune does not have a currency symbol,\n     * the generic currency character ¤ should be used.\n     * For example, if the Symbol is # and the divisibility is 2,\n     * the amount of 1234 units should be displayed as 12.34 #.\n     */\n    Tag[Tag[\"Symbol\"] = 5] = \"Symbol\";\n    /** The Nop field is unrecognized. */\n    Tag[Tag[\"Nop\"] = 127] = \"Nop\";\n})(Tag || (exports.Tag = Tag = {}));\nvar Flaw;\n(function (Flaw) {\n    Flaw[Flaw[\"EdictOutput\"] = 0] = \"EdictOutput\";\n    Flaw[Flaw[\"EdictRuneId\"] = 1] = \"EdictRuneId\";\n    Flaw[Flaw[\"InvalidScript\"] = 2] = \"InvalidScript\";\n    Flaw[Flaw[\"Opcode\"] = 3] = \"Opcode\";\n    Flaw[Flaw[\"SupplyOverflow\"] = 4] = \"SupplyOverflow\";\n    Flaw[Flaw[\"TrailingIntegers\"] = 5] = \"TrailingIntegers\";\n    Flaw[Flaw[\"TruncatedField\"] = 6] = \"TruncatedField\";\n    Flaw[Flaw[\"UnrecognizedEvenTag\"] = 7] = \"UnrecognizedEvenTag\";\n    Flaw[Flaw[\"UnrecognizedFlag\"] = 8] = \"UnrecognizedFlag\";\n    Flaw[Flaw[\"Varint\"] = 9] = \"Varint\";\n})(Flaw || (exports.Flaw = Flaw = {}));\nclass Range {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\nexports.Range = Range;\nclass Terms {\n    constructor(amount, cap, height, offset) {\n        this.amount = amount;\n        this.cap = cap;\n        this.height = height;\n        this.offset = offset;\n    }\n}\nexports.Terms = Terms;\nclass Rune {\n    constructor(value) {\n        this.value = value;\n    }\n    get name() {\n        return Rune.toName(this.value);\n    }\n    static toName(s) {\n        return (0, base26_1.base26Decode)(s);\n    }\n    static fromName(name) {\n        return new Rune((0, base26_1.base26Encode)((0, spacers_1.removeSpacers)(name)));\n    }\n    toString() {\n        return this.name;\n    }\n}\nexports.Rune = Rune;\nclass Etching {\n    constructor(divisibility, premine, rune, spacers, symbol, terms, turbo) {\n        this.divisibility = divisibility;\n        this.premine = premine;\n        this.rune = rune;\n        this.spacers = spacers;\n        this.symbol = symbol;\n        this.terms = terms;\n        this.turbo = turbo;\n    }\n}\nexports.Etching = Etching;\nEtching.MAX_DIVISIBILITY = 38;\nEtching.MAX_SPACERS = 134217727;\nclass Runestone {\n    constructor(edicts = [], etching, mint, pointer) {\n        this.edicts = edicts;\n        this.etching = etching;\n        this.mint = mint;\n        this.pointer = pointer;\n    }\n    static create(json, type = 'etch') {\n        if (type === 'etch') {\n            json = json;\n            const runename = Rune.fromName(json.name);\n            const terms = new Terms(json.amount, json.cap, new Range(json.startHeight ? (0, fts_1.some)(json.startHeight) : (0, fts_1.none)(), json.endHeight ? (0, fts_1.some)(json.endHeight) : (0, fts_1.none)()), new Range(json.startOffset ? (0, fts_1.some)(json.startOffset) : (0, fts_1.none)(), json.endOffset ? (0, fts_1.some)(json.endOffset) : (0, fts_1.none)()));\n            const divisibility = json.divisibility ? (0, fts_1.some)(json.divisibility) : (0, fts_1.none)();\n            const premine = json.premine ? (0, fts_1.some)(json.premine) : (0, fts_1.none)();\n            const spacers = json.name.indexOf('•') > -1 ? (0, fts_1.some)((0, spacers_1.getSpacersVal)(json.name)) : (0, fts_1.none)();\n            const symbol = json.symbol ? (0, fts_1.some)(json.symbol) : (0, fts_1.none)();\n            const pointer = typeof json.pointer === 'number' ? (0, fts_1.some)(json.pointer) : (0, fts_1.none)();\n            const etching = new Etching(divisibility, premine, (0, fts_1.some)(runename), spacers, symbol, (0, fts_1.some)(terms), true);\n            return new Runestone([], (0, fts_1.some)(etching), (0, fts_1.none)(), pointer);\n        }\n        else if (type === 'mint') {\n            json = json;\n            const pointer = typeof json.pointer === 'number' ? (0, fts_1.some)(json.pointer) : (0, fts_1.none)();\n            return new Runestone([], (0, fts_1.none)(), (0, fts_1.some)(new RuneId(json.block, json.txIdx)), pointer);\n        }\n        else {\n            throw new Error(`not ${type} support now`);\n        }\n    }\n    static decipher(rawTx) {\n        const tx = bitcoinjs_lib_1.Transaction.fromHex(rawTx);\n        const payload = Runestone.payload(tx);\n        if (payload.isSome()) {\n            const integers = Runestone.integers(payload.value());\n            const message = Message.from_integers(tx, integers.value());\n            const etching = message.getEtching();\n            const mint = message.getMint();\n            const pointer = message.getPointer();\n            return (0, fts_1.some)(new Runestone(message.edicts, etching, mint, pointer));\n        }\n        return (0, fts_1.none)();\n    }\n    encipher() {\n        const msg = this.toMessage();\n        const msgBuff = msg.toBuffer();\n        const prefix = Buffer.from('6a5d', 'hex'); // OP_RETURN OP_13\n        let pushNum;\n        if (msgBuff.length < 0x4c) {\n            pushNum = Buffer.alloc(1);\n            pushNum.writeUint8(msgBuff.length);\n        }\n        else if (msgBuff.length < 0x100) {\n            pushNum = Buffer.alloc(2);\n            pushNum.writeUint8(0x4c);\n            pushNum.writeUint8(msgBuff.length);\n        }\n        else if (msgBuff.length < 0x10000) {\n            pushNum = Buffer.alloc(3);\n            pushNum.writeUint8(0x4d);\n            pushNum.writeUint16LE(msgBuff.length);\n        }\n        else if (msgBuff.length < 0x100000000) {\n            pushNum = Buffer.alloc(5);\n            pushNum.writeUint8(0x4e);\n            pushNum.writeUint32LE(msgBuff.length);\n        }\n        else {\n            throw new Error(\"runestone too big!\");\n        }\n        return Buffer.concat([prefix, pushNum, msgBuff]);\n    }\n    static payload(tx) {\n        for (const output of tx.outs) {\n            //script.fromASM\n            const ls = bitcoinjs_lib_1.script.decompile(output.script);\n            if (ls[0] !== bitcoinjs_lib_1.script.OPS.OP_RETURN) {\n                continue;\n            }\n            if (ls[1] !== Runestone.MAGIC_NUMBER) {\n                continue;\n            }\n            for (let i = 2; i < ls.length; i++) {\n                const element = ls[i];\n                if (element instanceof Uint8Array) {\n                    return (0, fts_1.some)(Array.from(element));\n                }\n                return (0, fts_1.none)();\n            }\n            return (0, fts_1.none)();\n        }\n        return (0, fts_1.none)();\n    }\n    static integers(payload) {\n        let integers = [];\n        let i = 0;\n        while (i < payload.length) {\n            let { n, len } = (0, leb128_1.decodeLEB128)(payload.slice(i));\n            integers.push(n);\n            i += len;\n        }\n        return (0, fts_1.some)(integers);\n    }\n    toMessage() {\n        let fields = new Map();\n        const etching = this.etching.value();\n        if (etching) {\n            let flags = 1;\n            if (etching.terms.isSome()) {\n                let mask = 1 << Flag.Terms;\n                flags |= mask;\n            }\n            if (etching.turbo) {\n                let mask = 1 << Flag.Turbo;\n                flags |= mask;\n            }\n            fields.set(Tag.Flags, [BigInt(flags)]);\n            const rune = etching.rune.value();\n            if (rune !== null) {\n                fields.set(Tag.Rune, [BigInt(rune.value)]);\n            }\n            const divisibility = etching.divisibility.value();\n            if (divisibility !== null) {\n                fields.set(Tag.Divisibility, [BigInt(divisibility)]);\n            }\n            const spacers = etching.spacers.value();\n            if (spacers !== null) {\n                fields.set(Tag.Spacers, [BigInt(spacers)]);\n            }\n            const symbol = etching.symbol.value();\n            if (symbol !== null) {\n                fields.set(Tag.Symbol, [BigInt(symbol.charCodeAt(0))]);\n            }\n            const premine = etching.premine.value();\n            if (premine !== null) {\n                fields.set(Tag.Premine, [BigInt(premine)]);\n            }\n            const terms = etching.terms.value();\n            if (terms !== null) {\n                fields.set(Tag.Amount, [BigInt(terms.amount)]);\n                fields.set(Tag.Cap, [BigInt(terms.cap)]);\n                const heightStart = terms.height.start.value();\n                if (heightStart) {\n                    fields.set(Tag.HeightStart, [BigInt(heightStart)]);\n                }\n                const heightEnd = terms.height.end.value();\n                if (heightEnd) {\n                    fields.set(Tag.HeightEnd, [BigInt(heightEnd)]);\n                }\n                const offsetStart = terms.offset.start.value();\n                if (offsetStart) {\n                    fields.set(Tag.OffsetStart, [BigInt(offsetStart)]);\n                }\n                const offsetEnd = terms.offset.end.value();\n                if (offsetEnd) {\n                    fields.set(Tag.OffsetEnd, [BigInt(offsetEnd)]);\n                }\n            }\n        }\n        const mint = this.mint.value();\n        if (mint !== null) {\n            fields.set(Tag.Mint, [BigInt(mint.block), BigInt(mint.idx)]);\n        }\n        const pointer = this.pointer.value();\n        if (pointer !== null) {\n            fields.set(Tag.Pointer, [BigInt(pointer)]);\n        }\n        return new Message(fields, this.edicts, 0);\n    }\n}\nexports.Runestone = Runestone;\nRunestone.MAGIC_NUMBER = 93;\nclass Message {\n    constructor(fields = new Map(), edicts = [], flaws = 0) {\n        this.fields = fields;\n        this.edicts = edicts;\n        this.flaws = flaws;\n    }\n    static from_integers(tx, integers) {\n        let fields = new Map();\n        let edicts = [];\n        let flaws = 0;\n        let isBody = false;\n        for (let i = 0; i < integers.length;) {\n            let tag = integers[i];\n            if (Number(tag) === Tag.Body) {\n                isBody = true;\n                i += 1;\n                continue;\n            }\n            if (!isBody) {\n                // Fields:\n                let val = integers[i + 1];\n                const vals = fields.get(Number(tag)) || [];\n                vals.push(val);\n                fields.set(Number(tag), vals);\n                i += 2;\n            }\n            else {\n                // Edicts:\n                let id = new RuneId(0, 0);\n                for (const chunk of (0, utils_1.chunks)(integers.slice(i), 4)) {\n                    if (chunk.length != 4) {\n                        flaws |= Flaw.TrailingIntegers;\n                        break;\n                    }\n                    let next = id.next(chunk[0], chunk[1]);\n                    if (!next.isSome()) {\n                        flaws |= Flaw.EdictRuneId;\n                        break;\n                    }\n                    const edict = Edict.from_integers(tx, next.value(), chunk[2], chunk[3]);\n                    if (!edict.isSome()) {\n                        flaws |= Flaw.EdictOutput;\n                        break;\n                    }\n                    id = next.value();\n                    edicts.push(edict.value());\n                }\n                i += 4;\n            }\n        }\n        return new Message(fields, edicts, flaws);\n    }\n    addFieldVal(tag, val) {\n        const vals = this.fields.get(Number(tag)) || [];\n        vals.push(val);\n        this.fields.set(Number(tag), vals);\n    }\n    addEdict(edict) {\n        this.edicts.push(edict);\n    }\n    toBuffer() {\n        const buffArr = [];\n        // Serialize fields.\n        for (const [tag, vals] of this.fields) {\n            for (const val of vals) {\n                const tagBuff = Buffer.alloc(1);\n                tagBuff.writeUInt8(tag);\n                buffArr.push(tagBuff);\n                buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(val)));\n            }\n        }\n        // Serialize edicts.\n        if (this.edicts.length > 0) {\n            buffArr.push(Buffer.from('00', 'hex'));\n            // 1) Sort by block height\n            // 2) Sort by tx idx\n            this.edicts.sort((a, b) => {\n                if (a.id.block == b.id.block) {\n                    return a.id.idx - b.id.idx;\n                }\n                return a.id.block - b.id.block;\n            });\n            // 3) Delta encode\n            let lastBlockHeight = 0n;\n            let lastTxIdx = 0n;\n            for (let i = 0; i < this.edicts.length; i++) {\n                const edict = this.edicts[i];\n                if (i == 0) {\n                    lastBlockHeight = BigInt(edict.id.block);\n                    lastTxIdx = BigInt(edict.id.idx);\n                    buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(lastBlockHeight)));\n                    buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(lastTxIdx)));\n                }\n                else {\n                    const currBlockHeight = BigInt(edict.id.block);\n                    const currTxIdx = BigInt(edict.id.idx);\n                    if (currBlockHeight == lastBlockHeight) {\n                        const deltaTxIdx = currTxIdx - lastTxIdx;\n                        lastTxIdx = currTxIdx;\n                        buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(0n)));\n                        buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(deltaTxIdx)));\n                    }\n                    else {\n                        const deltaBlockHeight = currBlockHeight - lastBlockHeight;\n                        lastBlockHeight = currBlockHeight;\n                        lastTxIdx = currTxIdx;\n                        buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(deltaBlockHeight)));\n                        buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(currTxIdx)));\n                    }\n                }\n                buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(BigInt(edict.amount))));\n                buffArr.push(Buffer.from((0, leb128_1.encodeLEB128)(BigInt(edict.output))));\n            }\n        }\n        return Buffer.concat(buffArr);\n    }\n    getFlags() {\n        return Number(this.fields.get(Tag.Flags));\n    }\n    hasFlags(flag) {\n        const flags = this.getFlags();\n        const mask = 1 << flag;\n        return (flags & mask) != 0;\n    }\n    getMint() {\n        if (!this.fields.has(Tag.Mint)) {\n            return (0, fts_1.none)();\n        }\n        const [block, tx] = this.fields.get(Tag.Mint);\n        return (0, fts_1.some)(new RuneId(Number(block), Number(tx)));\n    }\n    getEtching() {\n        if (!this.hasFlags(Flag.Etching)) {\n            return (0, fts_1.none)();\n        }\n        const divisibility = this.getDivisibility();\n        const premine = this.getPremine();\n        const rune = this.getRune();\n        const spacers = this.getSpacers();\n        const symbol = this.getSymbol();\n        const terms = this.getTerms();\n        const turbo = this.hasFlags(Flag.Turbo);\n        return (0, fts_1.some)(new Etching(divisibility, premine, rune, spacers, symbol, terms, turbo));\n    }\n    getDivisibility() {\n        if (!this.fields.has(Tag.Divisibility)) {\n            return (0, fts_1.none)();\n        }\n        const [divisibility] = this.fields.get(Tag.Divisibility);\n        if (divisibility > Etching.MAX_DIVISIBILITY) {\n            throw new Error(\"invalid divisibility\");\n        }\n        return (0, fts_1.some)(Number(divisibility));\n    }\n    getPremine() {\n        if (!this.fields.has(Tag.Premine)) {\n            return (0, fts_1.none)();\n        }\n        const [premine] = this.fields.get(Tag.Premine);\n        return (0, fts_1.some)(Number(premine));\n    }\n    getRune() {\n        if (!this.fields.has(Tag.Rune)) {\n            return (0, fts_1.none)();\n        }\n        const [rune] = this.fields.get(Tag.Rune);\n        return (0, fts_1.some)(new Rune(rune));\n    }\n    getSpacers() {\n        if (!this.fields.has(Tag.Spacers)) {\n            return (0, fts_1.none)();\n        }\n        const [spacers] = this.fields.get(Tag.Spacers);\n        if (spacers > Etching.MAX_SPACERS) {\n            throw new Error(\"invalid spacers\");\n        }\n        return (0, fts_1.some)(Number(spacers));\n    }\n    getHeightStart() {\n        if (!this.fields.has(Tag.HeightStart)) {\n            return (0, fts_1.none)();\n        }\n        const [heightStart] = this.fields.get(Tag.HeightStart);\n        return (0, fts_1.some)(Number(heightStart));\n    }\n    getHeightEnd() {\n        if (!this.fields.has(Tag.HeightEnd)) {\n            return (0, fts_1.none)();\n        }\n        const [heightEnd] = this.fields.get(Tag.HeightEnd);\n        return (0, fts_1.some)(Number(heightEnd));\n    }\n    getOffsetStart() {\n        if (!this.fields.has(Tag.OffsetStart)) {\n            return (0, fts_1.none)();\n        }\n        const [offsetStart] = this.fields.get(Tag.OffsetStart);\n        return (0, fts_1.some)(Number(offsetStart));\n    }\n    getOffsetEnd() {\n        if (!this.fields.has(Tag.OffsetEnd)) {\n            return (0, fts_1.none)();\n        }\n        const [offsetEnd] = this.fields.get(Tag.OffsetEnd);\n        return (0, fts_1.some)(Number(offsetEnd));\n    }\n    getCap() {\n        if (!this.fields.has(Tag.Cap)) {\n            return (0, fts_1.none)();\n        }\n        const [cap] = this.fields.get(Tag.Cap);\n        return (0, fts_1.some)(Number(cap));\n    }\n    getAmount() {\n        if (!this.fields.has(Tag.Amount)) {\n            return (0, fts_1.none)();\n        }\n        const [amount] = this.fields.get(Tag.Amount);\n        return (0, fts_1.some)(Number(amount));\n    }\n    getSymbol() {\n        if (!this.fields.has(Tag.Symbol)) {\n            return (0, fts_1.none)();\n        }\n        const [symbol] = this.fields.get(Tag.Symbol);\n        return (0, fts_1.some)(String.fromCharCode(Number(symbol)));\n    }\n    getTerms() {\n        if (!this.hasFlags(Flag.Terms)) {\n            return (0, fts_1.none)();\n        }\n        const cap = this.getCap();\n        if (!cap.isSome()) {\n            throw new Error(\"no cap field\");\n        }\n        const amount = this.getAmount();\n        if (!amount.isSome()) {\n            throw new Error(\"no amount field\");\n        }\n        const heightStart = this.getHeightStart();\n        const heightEnd = this.getHeightEnd();\n        const offsetStart = this.getOffsetStart();\n        const offsetEnd = this.getOffsetEnd();\n        const height = new Range(heightStart, heightEnd);\n        const offset = new Range(offsetStart, offsetEnd);\n        return (0, fts_1.some)(new Terms(amount.value(), cap.value(), height, offset));\n    }\n    getPointer() {\n        if (!this.fields.has(Tag.Pointer)) {\n            return (0, fts_1.none)();\n        }\n        const [pointer] = this.fields.get(Tag.Pointer);\n        return (0, fts_1.some)(Number(pointer));\n    }\n}\nexports.Message = Message;\nclass EtchInscription {\n    constructor(fields = new Map(), data = Buffer.alloc(0)) {\n        this.fields = fields;\n        this.data = data;\n    }\n    setContent(contentType, data) {\n        this.fields.set(1, Buffer.from(contentType, 'utf8'));\n        this.data = data;\n    }\n    setRune(rune) {\n        const n = (0, base26_1.base26Encode)((0, spacers_1.removeSpacers)(rune));\n        let nstr = n.toString(16);\n        if (nstr.length % 2 === 1) {\n            nstr = '0' + nstr;\n        }\n        this.setField(EtchInscription.Tag.RUNE, Buffer.from(nstr, 'hex').reverse());\n    }\n    setField(field, val) {\n        this.fields.set(field, val);\n    }\n    static decipher(rawTx, inputIdx) {\n        const tx = bitcoinjs_lib_1.Transaction.fromHex(rawTx);\n        const witness = tx.ins[inputIdx].witness;\n        const tapscript = witness[1];\n        const ls = bitcoinjs_lib_1.script.decompile(tapscript);\n        const fields = new Map();\n        const dataChunks = [];\n        let isData = false;\n        for (let i = 5; i < ls.length - 1;) {\n            const chunk = ls[i];\n            if (chunk === 0) {\n                isData = true;\n                i++;\n                continue;\n            }\n            else if (isData) {\n                // Data\n                dataChunks.push(chunk);\n                i++;\n            }\n            else {\n                // Fields\n                const tag = chunk - 80;\n                const val = ls[i + 1];\n                if (typeof val == 'number') {\n                    const buff = Buffer.alloc(1);\n                    buff.writeUint8(val);\n                    fields.set(tag, buff);\n                }\n                else {\n                    fields.set(tag, val);\n                }\n                i += 2;\n            }\n        }\n        return new EtchInscription(fields, Buffer.concat(dataChunks));\n    }\n    encipher() {\n        const res = [];\n        if (this.data && this.data.length > 0) {\n            res.push(Buffer.from('0063036f7264', 'hex') // 0 OP_IF \"ord\"\n            );\n            Array.from(this.fields.entries())\n                .sort((a, b) => a[0] - b[0]) // Sorting by tag in ascending order\n                .forEach(([tag, val]) => {\n                const tagBuff = Buffer.alloc(1);\n                tagBuff.writeUInt8(tag);\n                res.push(Buffer.from('01', 'hex'));\n                res.push(tagBuff);\n                if (val.length != 1 || val[0] != 0x00) {\n                    res.push((0, utils_1.toPushData)(val));\n                }\n                else {\n                    res.push(val);\n                }\n            });\n            res.push(Buffer.from('00', 'hex'));\n            const dataChunks = (0, utils_1.chunks)(Array.from(this.data), 520);\n            for (const chunk of dataChunks) {\n                res.push((0, utils_1.toPushData)(Buffer.from(chunk)));\n            }\n        }\n        else {\n            res.push(Buffer.from('0063', 'hex') // 0 OP_IF\n            );\n            const rune = this.fields.get(EtchInscription.Tag.RUNE);\n            if (!rune) {\n                throw new Error(`No rune found!`);\n            }\n            res.push((0, utils_1.toPushData)(rune));\n        }\n        res.push(Buffer.from('68', 'hex')); // OP_ENDIF\n        return Buffer.concat(res);\n    }\n}\nexports.EtchInscription = EtchInscription;\nEtchInscription.Tag = {\n    CONTENT_TYPE: 1,\n    POINTER: 2,\n    PARENT: 3,\n    METADATA: 5,\n    METAPROTOCOL: 7,\n    CONTENT_ENCODING: 9,\n    DELEGATE: 11,\n    RUNE: 13\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWxpYkAxLjAuNy9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L3J1bmVzdG9uZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxhQUFhLEdBQUcsY0FBYztBQUMzTSx3QkFBd0IsbUJBQU8sQ0FBQyw2R0FBZTtBQUMvQyxpQkFBaUIsbUJBQU8sQ0FBQyw4RkFBVTtBQUNuQyxjQUFjLG1CQUFPLENBQUMsd0ZBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsOEZBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsNEZBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsZ0dBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxXQUFXLFlBQVksWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVUsV0FBVyxXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsV0FBVyxZQUFZLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9ydW5lbGliQDEuMC43L25vZGVfbW9kdWxlcy9ydW5lbGliL2Rpc3QvcnVuZXN0b25lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXRjaEluc2NyaXB0aW9uID0gZXhwb3J0cy5NZXNzYWdlID0gZXhwb3J0cy5SdW5lc3RvbmUgPSBleHBvcnRzLkV0Y2hpbmcgPSBleHBvcnRzLlJ1bmUgPSBleHBvcnRzLlRlcm1zID0gZXhwb3J0cy5SYW5nZSA9IGV4cG9ydHMuRmxhdyA9IGV4cG9ydHMuVGFnID0gZXhwb3J0cy5GbGFnID0gZXhwb3J0cy5FZGljdCA9IGV4cG9ydHMuUnVuZUlkID0gdm9pZCAwO1xuY29uc3QgYml0Y29pbmpzX2xpYl8xID0gcmVxdWlyZShcImJpdGNvaW5qcy1saWJcIik7XG5jb25zdCBiYXNlMjZfMSA9IHJlcXVpcmUoXCIuL2Jhc2UyNlwiKTtcbmNvbnN0IGZ0c18xID0gcmVxdWlyZShcIi4vZnRzXCIpO1xuY29uc3QgbGViMTI4XzEgPSByZXF1aXJlKFwiLi9sZWIxMjhcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBzcGFjZXJzXzEgPSByZXF1aXJlKFwiLi9zcGFjZXJzXCIpO1xuLyoqXG4gKiBSdW5lIElEcyBhcmUgcmVwcmVzZW50ZWQgaW4gdGV4dCBhcyBCTE9DSzpUWC5cbiAqL1xuY2xhc3MgUnVuZUlkIHtcbiAgICBjb25zdHJ1Y3RvcihibG9jaywgaWR4KSB7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgfVxuICAgIG5leHQoYmxvY2ssIGlkeCkge1xuICAgICAgICBpZiAoYmxvY2sgPiBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkeCA+IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYiA9IEJpZ0ludCh0aGlzLmJsb2NrKSArIGJsb2NrO1xuICAgICAgICBpZiAoYiA+IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IGJsb2NrID09PSAwbiA/IEJpZ0ludCh0aGlzLmlkeCkgKyBpZHggOiBpZHg7XG4gICAgICAgIGlmIChpID4gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkobmV3IFJ1bmVJZChOdW1iZXIoYiksIE51bWJlcihpKSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVuZUlkID0gUnVuZUlkO1xuLyoqXG4gKiBSdW5lIElEIGJsb2NrIGhlaWdodHMgYW5kIHRyYW5zYWN0aW9uIGluZGljZXMgaW4gZWRpY3RzIGFyZSBkZWx0YSBlbmNvZGVkLlxuICogRWRpY3QgcnVuZSBJRCBkZWNvZGluZyBzdGFydHMgd2l0aCBhIGJhc2UgYmxvY2sgaGVpZ2h0IGFuZCB0cmFuc2FjdGlvbiBpbmRleCBvZiB6ZXJvLlxuICogV2hlbiBkZWNvZGluZyBlYWNoIHJ1bmUgSUQsIGZpcnN0IHRoZSBlbmNvZGVkIGJsb2NrIGhlaWdodCBkZWx0YSBpcyBhZGRlZCB0byB0aGUgYmFzZSBibG9jayBoZWlnaHQuXG4gKiBJZiB0aGUgYmxvY2sgaGVpZ2h0IGRlbHRhIGlzIHplcm8sIHRoZSBuZXh0IGludGVnZXIgaXMgYSB0cmFuc2FjdGlvbiBpbmRleCBkZWx0YS5cbiAqIElmIHRoZSBibG9jayBoZWlnaHQgZGVsdGEgaXMgZ3JlYXRlciB0aGFuIHplcm8sIHRoZSBuZXh0IGludGVnZXIgaXMgaW5zdGVhZCBhbiBhYnNvbHV0ZSB0cmFuc2FjdGlvbiBpbmRleC5cbiAqL1xuY2xhc3MgRWRpY3Qge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBhbW91bnQsIG91dHB1dCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICAgICAgICB0aGlzLm91dHB1dCA9IG91dHB1dDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21faW50ZWdlcnModHgsIGlkLCBhbW91bnQsIG91dHB1dCkge1xuICAgICAgICBpZiAob3V0cHV0ID4gNDI5NDk2NzI5NW4gfHwgb3V0cHV0IDwgMG4pIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyKG91dHB1dCkgPiB0eC5vdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkobmV3IEVkaWN0KGlkLCBhbW91bnQsIE51bWJlcihvdXRwdXQpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5FZGljdCA9IEVkaWN0O1xudmFyIEZsYWc7XG4oZnVuY3Rpb24gKEZsYWcpIHtcbiAgICAvKiogVGhlIEV0Y2hpbmcgZmxhZyBtYXJrcyB0aGlzIHRyYW5zYWN0aW9uIGFzIGNvbnRhaW5pbmcgYW4gZXRjaGluZy4gKi9cbiAgICBGbGFnW0ZsYWdbXCJFdGNoaW5nXCJdID0gMF0gPSBcIkV0Y2hpbmdcIjtcbiAgICAvKiogVGhlIFRlcm1zIGZsYWcgbWFya3MgdGhpcyB0cmFuc2FjdGlvbidzIGV0Y2hpbmcgYXMgaGF2aW5nIG9wZW4gbWludCB0ZXJtcy4gKi9cbiAgICBGbGFnW0ZsYWdbXCJUZXJtc1wiXSA9IDFdID0gXCJUZXJtc1wiO1xuICAgIC8qKiBUaGUgVHVyYm8gZmxhZyBtYXJrcyB0aGlzIHRyYW5zYWN0aW9uJ3MgZXRjaGluZyBhcyBvcHRpbmcgaW50byBmdXR1cmUgcHJvdG9jb2wgY2hhbmdlcy4gVGhlc2UgcHJvdG9jb2wgY2hhbmdlcyBtYXkgaW5jcmVhc2UgbGlnaHQgY2xpZW50IHZhbGlkYXRpb24gY29zdHMsIG9yIGp1c3QgYmUgaGlnaGx5IGRlZ2VuZXJhdGUuICovXG4gICAgRmxhZ1tGbGFnW1wiVHVyYm9cIl0gPSAyXSA9IFwiVHVyYm9cIjtcbiAgICAvKiogVGhlIENlbm90YXBoIGZsYWcgaXMgdW5yZWNvZ25pemVkLiAqL1xuICAgIEZsYWdbRmxhZ1tcIkNlbm90YXBoXCJdID0gMTI3XSA9IFwiQ2Vub3RhcGhcIjtcbn0pKEZsYWcgfHwgKGV4cG9ydHMuRmxhZyA9IEZsYWcgPSB7fSkpO1xudmFyIFRhZztcbihmdW5jdGlvbiAoVGFnKSB7XG4gICAgLyoqIFRoZSBCb2R5IHRhZyBtYXJrcyB0aGUgZW5kIG9mIHRoZSBydW5lc3RvbmUncyBmaWVsZHMsIGNhdXNpbmcgYWxsIGZvbGxvd2luZyBpbnRlZ2VycyB0byBiZSBpbnRlcnByZXRlZCBhcyBlZGljdHMuICovXG4gICAgVGFnW1RhZ1tcIkJvZHlcIl0gPSAwXSA9IFwiQm9keVwiO1xuICAgIC8qKiBUaGUgRmxhZyBmaWVsZCBjb250YWlucyBhIGJpdG1hcCBvZiBmbGFncywgd2hvc2UgcG9zaXRpb24gaXMgMSA8PCBGTEFHX1ZBTFVFOiAqL1xuICAgIFRhZ1tUYWdbXCJGbGFnc1wiXSA9IDJdID0gXCJGbGFnc1wiO1xuICAgIC8qKiBUaGUgUnVuZSBmaWVsZCBjb250YWlucyB0aGUgbmFtZSBvZiB0aGUgcnVuZSBiZWluZyBldGNoZWQuIElmIHRoZSBFdGNoaW5nIGZsYWcgaXMgc2V0IGJ1dCB0aGUgUnVuZSBmaWVsZCBpcyBvbWl0dGVkLCBhIHJlc2VydmVkIHJ1bmUgbmFtZSBpcyBhbGxvY2F0ZWQuICovXG4gICAgVGFnW1RhZ1tcIlJ1bmVcIl0gPSA0XSA9IFwiUnVuZVwiO1xuICAgIC8qKiBUaGUgUHJlbWluZSBmaWVsZCBjb250YWlucyB0aGUgYW1vdW50IG9mIHByZW1pbmVkIHJ1bmVzLiAqL1xuICAgIFRhZ1tUYWdbXCJQcmVtaW5lXCJdID0gNl0gPSBcIlByZW1pbmVcIjtcbiAgICAvKiogVGhlIENhcCBmaWVsZCBjb250YWlucyB0aGUgYWxsb3dlZCBudW1iZXIgb2YgbWludHMuICovXG4gICAgVGFnW1RhZ1tcIkNhcFwiXSA9IDhdID0gXCJDYXBcIjtcbiAgICAvKiogVGhlIEFtb3VudCBmaWVsZCBjb250YWlucyB0aGUgYW1vdW50IG9mIHJ1bmVzIGVhY2ggbWludCB0cmFuc2FjdGlvbiByZWNlaXZlcy4gKi9cbiAgICBUYWdbVGFnW1wiQW1vdW50XCJdID0gMTBdID0gXCJBbW91bnRcIjtcbiAgICAvKiogVGhlIEhlaWdodFN0YXJ0IGFuZCBIZWlnaHRFbmQgZmllbGRzIGNvbnRhaW4gdGhlIG1pbnQncyBzdGFydGluZyBhbmQgZW5kaW5nIGFic29sdXRlIGJsb2NrIGhlaWdodHMsIHJlc3BlY3RpdmVseS4gVGhlIG1pbnQgaXMgb3BlbiBzdGFydGluZyBpbiB0aGUgYmxvY2sgd2l0aCBoZWlnaHQgSGVpZ2h0U3RhcnQsIGFuZCBjbG9zZXMgaW4gdGhlIGJsb2NrIHdpdGggaGVpZ2h0IEhlaWdodEVuZC4gKi9cbiAgICBUYWdbVGFnW1wiSGVpZ2h0U3RhcnRcIl0gPSAxMl0gPSBcIkhlaWdodFN0YXJ0XCI7XG4gICAgVGFnW1RhZ1tcIkhlaWdodEVuZFwiXSA9IDE0XSA9IFwiSGVpZ2h0RW5kXCI7XG4gICAgLyoqIFRoZSBPZmZzZXRTdGFydCBhbmQgT2Zmc2V0RW5kIGZpZWxkcyBjb250YWluIHRoZSBtaW50J3Mgc3RhcnRpbmcgYW5kIGVuZGluZyBibG9jayBoZWlnaHRzLCByZWxhdGl2ZSB0byB0aGUgYmxvY2sgaW4gd2hpY2ggdGhlIGV0Y2hpbmcgaXMgbWluZWQuIFRoZSBtaW50IGlzIG9wZW4gc3RhcnRpbmcgaW4gdGhlIGJsb2NrIHdpdGggaGVpZ2h0IE9mZnNldFN0YXJ0ICsgRVRDSElOR19IRUlHSFQsIGFuZCBjbG9zZXMgaW4gdGhlIGJsb2NrIHdpdGggaGVpZ2h0IE9mZnNldEVuZCArIEVUQ0hJTkdfSEVJR0hULiAqL1xuICAgIFRhZ1tUYWdbXCJPZmZzZXRTdGFydFwiXSA9IDE2XSA9IFwiT2Zmc2V0U3RhcnRcIjtcbiAgICBUYWdbVGFnW1wiT2Zmc2V0RW5kXCJdID0gMThdID0gXCJPZmZzZXRFbmRcIjtcbiAgICAvKiogVGhlIE1pbnQgZmllbGQgY29udGFpbnMgdGhlIFJ1bmUgSUQgb2YgdGhlIHJ1bmUgdG8gYmUgbWludGVkIGluIHRoaXMgdHJhbnNhY3Rpb24uICovXG4gICAgVGFnW1RhZ1tcIk1pbnRcIl0gPSAyMF0gPSBcIk1pbnRcIjtcbiAgICAvKiogVGhlIFBvaW50ZXIgZmllbGQgY29udGFpbnMgdGhlIGluZGV4IG9mIHRoZSBvdXRwdXQgdG8gd2hpY2ggcnVuZXMgdW5hbGxvY2F0ZWQgYnkgZWRpY3RzIHNob3VsZCBiZSB0cmFuc2ZlcnJlZC4gSWYgdGhlIFBvaW50ZXIgZmllbGQgaXMgYWJzZW50LCB1bmFsbG9jYXRlZCBydW5lcyBhcmUgdHJhbnNmZXJyZWQgdG8gdGhlIGZpcnN0IG5vbi1PUF9SRVRVUk4gb3V0cHV0LiAqL1xuICAgIFRhZ1tUYWdbXCJQb2ludGVyXCJdID0gMjJdID0gXCJQb2ludGVyXCI7XG4gICAgLyoqIFRoZSBDZW5vdGFwaCBmaWVsZCBpcyB1bnJlY29nbml6ZWQuICovXG4gICAgVGFnW1RhZ1tcIkNlbm90YXBoXCJdID0gMTI2XSA9IFwiQ2Vub3RhcGhcIjtcbiAgICAvKiogVGhlIERpdmlzaWJpbGl0eSBmaWVsZCwgcmFpc2VkIHRvIHRoZSBwb3dlciBvZiB0ZW4sIGlzIHRoZSBudW1iZXIgb2Ygc3VidW5pdHMgaW4gYSBzdXBlciB1bml0IG9mIHJ1bmVzLiAqL1xuICAgIFRhZ1tUYWdbXCJEaXZpc2liaWxpdHlcIl0gPSAxXSA9IFwiRGl2aXNpYmlsaXR5XCI7XG4gICAgLyoqIFRoZSBTcGFjZXJzIGZpZWxkIGlzIGEgYml0ZmllbGQgb2Yg4oCiIHNwYWNlcnMgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIGJldHdlZW4gdGhlIGxldHRlcnMgb2YgdGhlIHJ1bmUncyBuYW1lLiBUcmFpbGluZyBzcGFjZXJzIGFyZSBpZ25vcmVkLiAqL1xuICAgIFRhZ1tUYWdbXCJTcGFjZXJzXCJdID0gM10gPSBcIlNwYWNlcnNcIjtcbiAgICAvKiogVGhlIFN5bWJvbCBmaWVsZCBpcyB0aGUgVW5pY29kZSBjb2RlcG9pbnQgb2YgdGhlIFJ1bmUncyBjdXJyZW5jeSBzeW1ib2wsXG4gICAgICogd2hpY2ggc2hvdWxkIGJlIGRpc3BsYXllZCBhZnRlciBhbW91bnRzIG9mIHRoYXQgcnVuZS4gSWYgYSBydW5lIGRvZXMgbm90IGhhdmUgYSBjdXJyZW5jeSBzeW1ib2wsXG4gICAgICogdGhlIGdlbmVyaWMgY3VycmVuY3kgY2hhcmFjdGVyIMKkIHNob3VsZCBiZSB1c2VkLlxuICAgICAqIEZvciBleGFtcGxlLCBpZiB0aGUgU3ltYm9sIGlzICMgYW5kIHRoZSBkaXZpc2liaWxpdHkgaXMgMixcbiAgICAgKiB0aGUgYW1vdW50IG9mIDEyMzQgdW5pdHMgc2hvdWxkIGJlIGRpc3BsYXllZCBhcyAxMi4zNCAjLlxuICAgICAqL1xuICAgIFRhZ1tUYWdbXCJTeW1ib2xcIl0gPSA1XSA9IFwiU3ltYm9sXCI7XG4gICAgLyoqIFRoZSBOb3AgZmllbGQgaXMgdW5yZWNvZ25pemVkLiAqL1xuICAgIFRhZ1tUYWdbXCJOb3BcIl0gPSAxMjddID0gXCJOb3BcIjtcbn0pKFRhZyB8fCAoZXhwb3J0cy5UYWcgPSBUYWcgPSB7fSkpO1xudmFyIEZsYXc7XG4oZnVuY3Rpb24gKEZsYXcpIHtcbiAgICBGbGF3W0ZsYXdbXCJFZGljdE91dHB1dFwiXSA9IDBdID0gXCJFZGljdE91dHB1dFwiO1xuICAgIEZsYXdbRmxhd1tcIkVkaWN0UnVuZUlkXCJdID0gMV0gPSBcIkVkaWN0UnVuZUlkXCI7XG4gICAgRmxhd1tGbGF3W1wiSW52YWxpZFNjcmlwdFwiXSA9IDJdID0gXCJJbnZhbGlkU2NyaXB0XCI7XG4gICAgRmxhd1tGbGF3W1wiT3Bjb2RlXCJdID0gM10gPSBcIk9wY29kZVwiO1xuICAgIEZsYXdbRmxhd1tcIlN1cHBseU92ZXJmbG93XCJdID0gNF0gPSBcIlN1cHBseU92ZXJmbG93XCI7XG4gICAgRmxhd1tGbGF3W1wiVHJhaWxpbmdJbnRlZ2Vyc1wiXSA9IDVdID0gXCJUcmFpbGluZ0ludGVnZXJzXCI7XG4gICAgRmxhd1tGbGF3W1wiVHJ1bmNhdGVkRmllbGRcIl0gPSA2XSA9IFwiVHJ1bmNhdGVkRmllbGRcIjtcbiAgICBGbGF3W0ZsYXdbXCJVbnJlY29nbml6ZWRFdmVuVGFnXCJdID0gN10gPSBcIlVucmVjb2duaXplZEV2ZW5UYWdcIjtcbiAgICBGbGF3W0ZsYXdbXCJVbnJlY29nbml6ZWRGbGFnXCJdID0gOF0gPSBcIlVucmVjb2duaXplZEZsYWdcIjtcbiAgICBGbGF3W0ZsYXdbXCJWYXJpbnRcIl0gPSA5XSA9IFwiVmFyaW50XCI7XG59KShGbGF3IHx8IChleHBvcnRzLkZsYXcgPSBGbGF3ID0ge30pKTtcbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxufVxuZXhwb3J0cy5SYW5nZSA9IFJhbmdlO1xuY2xhc3MgVGVybXMge1xuICAgIGNvbnN0cnVjdG9yKGFtb3VudCwgY2FwLCBoZWlnaHQsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICAgICAgdGhpcy5jYXAgPSBjYXA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG59XG5leHBvcnRzLlRlcm1zID0gVGVybXM7XG5jbGFzcyBSdW5lIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gUnVuZS50b05hbWUodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b05hbWUocykge1xuICAgICAgICByZXR1cm4gKDAsIGJhc2UyNl8xLmJhc2UyNkRlY29kZSkocyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVuZSgoMCwgYmFzZTI2XzEuYmFzZTI2RW5jb2RlKSgoMCwgc3BhY2Vyc18xLnJlbW92ZVNwYWNlcnMpKG5hbWUpKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVuZSA9IFJ1bmU7XG5jbGFzcyBFdGNoaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihkaXZpc2liaWxpdHksIHByZW1pbmUsIHJ1bmUsIHNwYWNlcnMsIHN5bWJvbCwgdGVybXMsIHR1cmJvKSB7XG4gICAgICAgIHRoaXMuZGl2aXNpYmlsaXR5ID0gZGl2aXNpYmlsaXR5O1xuICAgICAgICB0aGlzLnByZW1pbmUgPSBwcmVtaW5lO1xuICAgICAgICB0aGlzLnJ1bmUgPSBydW5lO1xuICAgICAgICB0aGlzLnNwYWNlcnMgPSBzcGFjZXJzO1xuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcbiAgICAgICAgdGhpcy50ZXJtcyA9IHRlcm1zO1xuICAgICAgICB0aGlzLnR1cmJvID0gdHVyYm87XG4gICAgfVxufVxuZXhwb3J0cy5FdGNoaW5nID0gRXRjaGluZztcbkV0Y2hpbmcuTUFYX0RJVklTSUJJTElUWSA9IDM4O1xuRXRjaGluZy5NQVhfU1BBQ0VSUyA9IDEzNDIxNzcyNztcbmNsYXNzIFJ1bmVzdG9uZSB7XG4gICAgY29uc3RydWN0b3IoZWRpY3RzID0gW10sIGV0Y2hpbmcsIG1pbnQsIHBvaW50ZXIpIHtcbiAgICAgICAgdGhpcy5lZGljdHMgPSBlZGljdHM7XG4gICAgICAgIHRoaXMuZXRjaGluZyA9IGV0Y2hpbmc7XG4gICAgICAgIHRoaXMubWludCA9IG1pbnQ7XG4gICAgICAgIHRoaXMucG9pbnRlciA9IHBvaW50ZXI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoanNvbiwgdHlwZSA9ICdldGNoJykge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2V0Y2gnKSB7XG4gICAgICAgICAgICBqc29uID0ganNvbjtcbiAgICAgICAgICAgIGNvbnN0IHJ1bmVuYW1lID0gUnVuZS5mcm9tTmFtZShqc29uLm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgdGVybXMgPSBuZXcgVGVybXMoanNvbi5hbW91bnQsIGpzb24uY2FwLCBuZXcgUmFuZ2UoanNvbi5zdGFydEhlaWdodCA/ICgwLCBmdHNfMS5zb21lKShqc29uLnN0YXJ0SGVpZ2h0KSA6ICgwLCBmdHNfMS5ub25lKSgpLCBqc29uLmVuZEhlaWdodCA/ICgwLCBmdHNfMS5zb21lKShqc29uLmVuZEhlaWdodCkgOiAoMCwgZnRzXzEubm9uZSkoKSksIG5ldyBSYW5nZShqc29uLnN0YXJ0T2Zmc2V0ID8gKDAsIGZ0c18xLnNvbWUpKGpzb24uc3RhcnRPZmZzZXQpIDogKDAsIGZ0c18xLm5vbmUpKCksIGpzb24uZW5kT2Zmc2V0ID8gKDAsIGZ0c18xLnNvbWUpKGpzb24uZW5kT2Zmc2V0KSA6ICgwLCBmdHNfMS5ub25lKSgpKSk7XG4gICAgICAgICAgICBjb25zdCBkaXZpc2liaWxpdHkgPSBqc29uLmRpdmlzaWJpbGl0eSA/ICgwLCBmdHNfMS5zb21lKShqc29uLmRpdmlzaWJpbGl0eSkgOiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZW1pbmUgPSBqc29uLnByZW1pbmUgPyAoMCwgZnRzXzEuc29tZSkoanNvbi5wcmVtaW5lKSA6ICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VycyA9IGpzb24ubmFtZS5pbmRleE9mKCfigKInKSA+IC0xID8gKDAsIGZ0c18xLnNvbWUpKCgwLCBzcGFjZXJzXzEuZ2V0U3BhY2Vyc1ZhbCkoanNvbi5uYW1lKSkgOiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGpzb24uc3ltYm9sID8gKDAsIGZ0c18xLnNvbWUpKGpzb24uc3ltYm9sKSA6ICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IHR5cGVvZiBqc29uLnBvaW50ZXIgPT09ICdudW1iZXInID8gKDAsIGZ0c18xLnNvbWUpKGpzb24ucG9pbnRlcikgOiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgICAgIGNvbnN0IGV0Y2hpbmcgPSBuZXcgRXRjaGluZyhkaXZpc2liaWxpdHksIHByZW1pbmUsICgwLCBmdHNfMS5zb21lKShydW5lbmFtZSksIHNwYWNlcnMsIHN5bWJvbCwgKDAsIGZ0c18xLnNvbWUpKHRlcm1zKSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bmVzdG9uZShbXSwgKDAsIGZ0c18xLnNvbWUpKGV0Y2hpbmcpLCAoMCwgZnRzXzEubm9uZSkoKSwgcG9pbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ21pbnQnKSB7XG4gICAgICAgICAgICBqc29uID0ganNvbjtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0eXBlb2YganNvbi5wb2ludGVyID09PSAnbnVtYmVyJyA/ICgwLCBmdHNfMS5zb21lKShqc29uLnBvaW50ZXIpIDogKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJ1bmVzdG9uZShbXSwgKDAsIGZ0c18xLm5vbmUpKCksICgwLCBmdHNfMS5zb21lKShuZXcgUnVuZUlkKGpzb24uYmxvY2ssIGpzb24udHhJZHgpKSwgcG9pbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCAke3R5cGV9IHN1cHBvcnQgbm93YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGRlY2lwaGVyKHJhd1R4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLmZyb21IZXgocmF3VHgpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gUnVuZXN0b25lLnBheWxvYWQodHgpO1xuICAgICAgICBpZiAocGF5bG9hZC5pc1NvbWUoKSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZWdlcnMgPSBSdW5lc3RvbmUuaW50ZWdlcnMocGF5bG9hZC52YWx1ZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBNZXNzYWdlLmZyb21faW50ZWdlcnModHgsIGludGVnZXJzLnZhbHVlKCkpO1xuICAgICAgICAgICAgY29uc3QgZXRjaGluZyA9IG1lc3NhZ2UuZ2V0RXRjaGluZygpO1xuICAgICAgICAgICAgY29uc3QgbWludCA9IG1lc3NhZ2UuZ2V0TWludCgpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IG1lc3NhZ2UuZ2V0UG9pbnRlcigpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShuZXcgUnVuZXN0b25lKG1lc3NhZ2UuZWRpY3RzLCBldGNoaW5nLCBtaW50LCBwb2ludGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgIH1cbiAgICBlbmNpcGhlcigpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy50b01lc3NhZ2UoKTtcbiAgICAgICAgY29uc3QgbXNnQnVmZiA9IG1zZy50b0J1ZmZlcigpO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBCdWZmZXIuZnJvbSgnNmE1ZCcsICdoZXgnKTsgLy8gT1BfUkVUVVJOIE9QXzEzXG4gICAgICAgIGxldCBwdXNoTnVtO1xuICAgICAgICBpZiAobXNnQnVmZi5sZW5ndGggPCAweDRjKSB7XG4gICAgICAgICAgICBwdXNoTnVtID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICAgICAgcHVzaE51bS53cml0ZVVpbnQ4KG1zZ0J1ZmYubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2dCdWZmLmxlbmd0aCA8IDB4MTAwKSB7XG4gICAgICAgICAgICBwdXNoTnVtID0gQnVmZmVyLmFsbG9jKDIpO1xuICAgICAgICAgICAgcHVzaE51bS53cml0ZVVpbnQ4KDB4NGMpO1xuICAgICAgICAgICAgcHVzaE51bS53cml0ZVVpbnQ4KG1zZ0J1ZmYubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2dCdWZmLmxlbmd0aCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHB1c2hOdW0gPSBCdWZmZXIuYWxsb2MoMyk7XG4gICAgICAgICAgICBwdXNoTnVtLndyaXRlVWludDgoMHg0ZCk7XG4gICAgICAgICAgICBwdXNoTnVtLndyaXRlVWludDE2TEUobXNnQnVmZi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZ0J1ZmYubGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHB1c2hOdW0gPSBCdWZmZXIuYWxsb2MoNSk7XG4gICAgICAgICAgICBwdXNoTnVtLndyaXRlVWludDgoMHg0ZSk7XG4gICAgICAgICAgICBwdXNoTnVtLndyaXRlVWludDMyTEUobXNnQnVmZi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicnVuZXN0b25lIHRvbyBiaWchXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtwcmVmaXgsIHB1c2hOdW0sIG1zZ0J1ZmZdKTtcbiAgICB9XG4gICAgc3RhdGljIHBheWxvYWQodHgpIHtcbiAgICAgICAgZm9yIChjb25zdCBvdXRwdXQgb2YgdHgub3V0cykge1xuICAgICAgICAgICAgLy9zY3JpcHQuZnJvbUFTTVxuICAgICAgICAgICAgY29uc3QgbHMgPSBiaXRjb2luanNfbGliXzEuc2NyaXB0LmRlY29tcGlsZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgICAgICAgIGlmIChsc1swXSAhPT0gYml0Y29pbmpzX2xpYl8xLnNjcmlwdC5PUFMuT1BfUkVUVVJOKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobHNbMV0gIT09IFJ1bmVzdG9uZS5NQUdJQ19OVU1CRVIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoQXJyYXkuZnJvbShlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgfVxuICAgIHN0YXRpYyBpbnRlZ2VycyhwYXlsb2FkKSB7XG4gICAgICAgIGxldCBpbnRlZ2VycyA9IFtdO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgcGF5bG9hZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB7IG4sIGxlbiB9ID0gKDAsIGxlYjEyOF8xLmRlY29kZUxFQjEyOCkocGF5bG9hZC5zbGljZShpKSk7XG4gICAgICAgICAgICBpbnRlZ2Vycy5wdXNoKG4pO1xuICAgICAgICAgICAgaSArPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShpbnRlZ2Vycyk7XG4gICAgfVxuICAgIHRvTWVzc2FnZSgpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZXRjaGluZyA9IHRoaXMuZXRjaGluZy52YWx1ZSgpO1xuICAgICAgICBpZiAoZXRjaGluZykge1xuICAgICAgICAgICAgbGV0IGZsYWdzID0gMTtcbiAgICAgICAgICAgIGlmIChldGNoaW5nLnRlcm1zLmlzU29tZSgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hc2sgPSAxIDw8IEZsYWcuVGVybXM7XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gbWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldGNoaW5nLnR1cmJvKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hc2sgPSAxIDw8IEZsYWcuVHVyYm87XG4gICAgICAgICAgICAgICAgZmxhZ3MgfD0gbWFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLkZsYWdzLCBbQmlnSW50KGZsYWdzKV0pO1xuICAgICAgICAgICAgY29uc3QgcnVuZSA9IGV0Y2hpbmcucnVuZS52YWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHJ1bmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KFRhZy5SdW5lLCBbQmlnSW50KHJ1bmUudmFsdWUpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXZpc2liaWxpdHkgPSBldGNoaW5nLmRpdmlzaWJpbGl0eS52YWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGRpdmlzaWJpbGl0eSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLkRpdmlzaWJpbGl0eSwgW0JpZ0ludChkaXZpc2liaWxpdHkpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzcGFjZXJzID0gZXRjaGluZy5zcGFjZXJzLnZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc3BhY2VycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLlNwYWNlcnMsIFtCaWdJbnQoc3BhY2VycyldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGV0Y2hpbmcuc3ltYm9sLnZhbHVlKCk7XG4gICAgICAgICAgICBpZiAoc3ltYm9sICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZmllbGRzLnNldChUYWcuU3ltYm9sLCBbQmlnSW50KHN5bWJvbC5jaGFyQ29kZUF0KDApKV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJlbWluZSA9IGV0Y2hpbmcucHJlbWluZS52YWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHByZW1pbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KFRhZy5QcmVtaW5lLCBbQmlnSW50KHByZW1pbmUpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXJtcyA9IGV0Y2hpbmcudGVybXMudmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0ZXJtcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLkFtb3VudCwgW0JpZ0ludCh0ZXJtcy5hbW91bnQpXSk7XG4gICAgICAgICAgICAgICAgZmllbGRzLnNldChUYWcuQ2FwLCBbQmlnSW50KHRlcm1zLmNhcCldKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHRTdGFydCA9IHRlcm1zLmhlaWdodC5zdGFydC52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KFRhZy5IZWlnaHRTdGFydCwgW0JpZ0ludChoZWlnaHRTdGFydCldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGVpZ2h0RW5kID0gdGVybXMuaGVpZ2h0LmVuZC52YWx1ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChoZWlnaHRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNldChUYWcuSGVpZ2h0RW5kLCBbQmlnSW50KGhlaWdodEVuZCldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB0ZXJtcy5vZmZzZXQuc3RhcnQudmFsdWUoKTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnNldChUYWcuT2Zmc2V0U3RhcnQsIFtCaWdJbnQob2Zmc2V0U3RhcnQpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldEVuZCA9IHRlcm1zLm9mZnNldC5lbmQudmFsdWUoKTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLk9mZnNldEVuZCwgW0JpZ0ludChvZmZzZXRFbmQpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pbnQgPSB0aGlzLm1pbnQudmFsdWUoKTtcbiAgICAgICAgaWYgKG1pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpZWxkcy5zZXQoVGFnLk1pbnQsIFtCaWdJbnQobWludC5ibG9jayksIEJpZ0ludChtaW50LmlkeCldKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5wb2ludGVyLnZhbHVlKCk7XG4gICAgICAgIGlmIChwb2ludGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWVsZHMuc2V0KFRhZy5Qb2ludGVyLCBbQmlnSW50KHBvaW50ZXIpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGZpZWxkcywgdGhpcy5lZGljdHMsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuUnVuZXN0b25lID0gUnVuZXN0b25lO1xuUnVuZXN0b25lLk1BR0lDX05VTUJFUiA9IDkzO1xuY2xhc3MgTWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IoZmllbGRzID0gbmV3IE1hcCgpLCBlZGljdHMgPSBbXSwgZmxhd3MgPSAwKSB7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgICAgICB0aGlzLmVkaWN0cyA9IGVkaWN0cztcbiAgICAgICAgdGhpcy5mbGF3cyA9IGZsYXdzO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbV9pbnRlZ2Vycyh0eCwgaW50ZWdlcnMpIHtcbiAgICAgICAgbGV0IGZpZWxkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgbGV0IGVkaWN0cyA9IFtdO1xuICAgICAgICBsZXQgZmxhd3MgPSAwO1xuICAgICAgICBsZXQgaXNCb2R5ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50ZWdlcnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IHRhZyA9IGludGVnZXJzW2ldO1xuICAgICAgICAgICAgaWYgKE51bWJlcih0YWcpID09PSBUYWcuQm9keSkge1xuICAgICAgICAgICAgICAgIGlzQm9keSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0JvZHkpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWVsZHM6XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IGludGVnZXJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxzID0gZmllbGRzLmdldChOdW1iZXIodGFnKSkgfHwgW107XG4gICAgICAgICAgICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgZmllbGRzLnNldChOdW1iZXIodGFnKSwgdmFscyk7XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRpY3RzOlxuICAgICAgICAgICAgICAgIGxldCBpZCA9IG5ldyBSdW5lSWQoMCwgMCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiAoMCwgdXRpbHNfMS5jaHVua3MpKGludGVnZXJzLnNsaWNlKGkpLCA0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoICE9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXdzIHw9IEZsYXcuVHJhaWxpbmdJbnRlZ2VycztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gaWQubmV4dChjaHVua1swXSwgY2h1bmtbMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQuaXNTb21lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYXdzIHw9IEZsYXcuRWRpY3RSdW5lSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGljdCA9IEVkaWN0LmZyb21faW50ZWdlcnModHgsIG5leHQudmFsdWUoKSwgY2h1bmtbMl0sIGNodW5rWzNdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlZGljdC5pc1NvbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmxhd3MgfD0gRmxhdy5FZGljdE91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlkID0gbmV4dC52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBlZGljdHMucHVzaChlZGljdC52YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWVzc2FnZShmaWVsZHMsIGVkaWN0cywgZmxhd3MpO1xuICAgIH1cbiAgICBhZGRGaWVsZFZhbCh0YWcsIHZhbCkge1xuICAgICAgICBjb25zdCB2YWxzID0gdGhpcy5maWVsZHMuZ2V0KE51bWJlcih0YWcpKSB8fCBbXTtcbiAgICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgICAgIHRoaXMuZmllbGRzLnNldChOdW1iZXIodGFnKSwgdmFscyk7XG4gICAgfVxuICAgIGFkZEVkaWN0KGVkaWN0KSB7XG4gICAgICAgIHRoaXMuZWRpY3RzLnB1c2goZWRpY3QpO1xuICAgIH1cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgY29uc3QgYnVmZkFyciA9IFtdO1xuICAgICAgICAvLyBTZXJpYWxpemUgZmllbGRzLlxuICAgICAgICBmb3IgKGNvbnN0IFt0YWcsIHZhbHNdIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB2YWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFnQnVmZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0YWdCdWZmLndyaXRlVUludDgodGFnKTtcbiAgICAgICAgICAgICAgICBidWZmQXJyLnB1c2godGFnQnVmZik7XG4gICAgICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCgwLCBsZWIxMjhfMS5lbmNvZGVMRUIxMjgpKHZhbCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXJpYWxpemUgZWRpY3RzLlxuICAgICAgICBpZiAodGhpcy5lZGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCcwMCcsICdoZXgnKSk7XG4gICAgICAgICAgICAvLyAxKSBTb3J0IGJ5IGJsb2NrIGhlaWdodFxuICAgICAgICAgICAgLy8gMikgU29ydCBieSB0eCBpZHhcbiAgICAgICAgICAgIHRoaXMuZWRpY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYS5pZC5ibG9jayA9PSBiLmlkLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmlkLmlkeCAtIGIuaWQuaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pZC5ibG9jayAtIGIuaWQuYmxvY2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIDMpIERlbHRhIGVuY29kZVxuICAgICAgICAgICAgbGV0IGxhc3RCbG9ja0hlaWdodCA9IDBuO1xuICAgICAgICAgICAgbGV0IGxhc3RUeElkeCA9IDBuO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkaWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaWN0ID0gdGhpcy5lZGljdHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2tIZWlnaHQgPSBCaWdJbnQoZWRpY3QuaWQuYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBsYXN0VHhJZHggPSBCaWdJbnQoZWRpY3QuaWQuaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCgwLCBsZWIxMjhfMS5lbmNvZGVMRUIxMjgpKGxhc3RCbG9ja0hlaWdodCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCgwLCBsZWIxMjhfMS5lbmNvZGVMRUIxMjgpKGxhc3RUeElkeCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJCbG9ja0hlaWdodCA9IEJpZ0ludChlZGljdC5pZC5ibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJUeElkeCA9IEJpZ0ludChlZGljdC5pZC5pZHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyckJsb2NrSGVpZ2h0ID09IGxhc3RCbG9ja0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsdGFUeElkeCA9IGN1cnJUeElkeCAtIGxhc3RUeElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUeElkeCA9IGN1cnJUeElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZBcnIucHVzaChCdWZmZXIuZnJvbSgoMCwgbGViMTI4XzEuZW5jb2RlTEVCMTI4KSgwbikpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZBcnIucHVzaChCdWZmZXIuZnJvbSgoMCwgbGViMTI4XzEuZW5jb2RlTEVCMTI4KShkZWx0YVR4SWR4KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsdGFCbG9ja0hlaWdodCA9IGN1cnJCbG9ja0hlaWdodCAtIGxhc3RCbG9ja0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja0hlaWdodCA9IGN1cnJCbG9ja0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RUeElkeCA9IGN1cnJUeElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZBcnIucHVzaChCdWZmZXIuZnJvbSgoMCwgbGViMTI4XzEuZW5jb2RlTEVCMTI4KShkZWx0YUJsb2NrSGVpZ2h0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCgwLCBsZWIxMjhfMS5lbmNvZGVMRUIxMjgpKGN1cnJUeElkeCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmQXJyLnB1c2goQnVmZmVyLmZyb20oKDAsIGxlYjEyOF8xLmVuY29kZUxFQjEyOCkoQmlnSW50KGVkaWN0LmFtb3VudCkpKSk7XG4gICAgICAgICAgICAgICAgYnVmZkFyci5wdXNoKEJ1ZmZlci5mcm9tKCgwLCBsZWIxMjhfMS5lbmNvZGVMRUIxMjgpKEJpZ0ludChlZGljdC5vdXRwdXQpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZBcnIpO1xuICAgIH1cbiAgICBnZXRGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLmZpZWxkcy5nZXQoVGFnLkZsYWdzKSk7XG4gICAgfVxuICAgIGhhc0ZsYWdzKGZsYWcpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSB0aGlzLmdldEZsYWdzKCk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSAxIDw8IGZsYWc7XG4gICAgICAgIHJldHVybiAoZmxhZ3MgJiBtYXNrKSAhPSAwO1xuICAgIH1cbiAgICBnZXRNaW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzLmhhcyhUYWcuTWludCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbYmxvY2ssIHR4XSA9IHRoaXMuZmllbGRzLmdldChUYWcuTWludCk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkobmV3IFJ1bmVJZChOdW1iZXIoYmxvY2spLCBOdW1iZXIodHgpKSk7XG4gICAgfVxuICAgIGdldEV0Y2hpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGbGFncyhGbGFnLkV0Y2hpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGl2aXNpYmlsaXR5ID0gdGhpcy5nZXREaXZpc2liaWxpdHkoKTtcbiAgICAgICAgY29uc3QgcHJlbWluZSA9IHRoaXMuZ2V0UHJlbWluZSgpO1xuICAgICAgICBjb25zdCBydW5lID0gdGhpcy5nZXRSdW5lKCk7XG4gICAgICAgIGNvbnN0IHNwYWNlcnMgPSB0aGlzLmdldFNwYWNlcnMoKTtcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gdGhpcy5nZXRTeW1ib2woKTtcbiAgICAgICAgY29uc3QgdGVybXMgPSB0aGlzLmdldFRlcm1zKCk7XG4gICAgICAgIGNvbnN0IHR1cmJvID0gdGhpcy5oYXNGbGFncyhGbGFnLlR1cmJvKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShuZXcgRXRjaGluZyhkaXZpc2liaWxpdHksIHByZW1pbmUsIHJ1bmUsIHNwYWNlcnMsIHN5bWJvbCwgdGVybXMsIHR1cmJvKSk7XG4gICAgfVxuICAgIGdldERpdmlzaWJpbGl0eSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLkRpdmlzaWJpbGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZGl2aXNpYmlsaXR5XSA9IHRoaXMuZmllbGRzLmdldChUYWcuRGl2aXNpYmlsaXR5KTtcbiAgICAgICAgaWYgKGRpdmlzaWJpbGl0eSA+IEV0Y2hpbmcuTUFYX0RJVklTSUJJTElUWSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkaXZpc2liaWxpdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIoZGl2aXNpYmlsaXR5KSk7XG4gICAgfVxuICAgIGdldFByZW1pbmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5QcmVtaW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtwcmVtaW5lXSA9IHRoaXMuZmllbGRzLmdldChUYWcuUHJlbWluZSk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoTnVtYmVyKHByZW1pbmUpKTtcbiAgICB9XG4gICAgZ2V0UnVuZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLlJ1bmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3J1bmVdID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5SdW5lKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShuZXcgUnVuZShydW5lKSk7XG4gICAgfVxuICAgIGdldFNwYWNlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5TcGFjZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5ub25lKSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtzcGFjZXJzXSA9IHRoaXMuZmllbGRzLmdldChUYWcuU3BhY2Vycyk7XG4gICAgICAgIGlmIChzcGFjZXJzID4gRXRjaGluZy5NQVhfU1BBQ0VSUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzcGFjZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoTnVtYmVyKHNwYWNlcnMpKTtcbiAgICB9XG4gICAgZ2V0SGVpZ2h0U3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5IZWlnaHRTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaGVpZ2h0U3RhcnRdID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5IZWlnaHRTdGFydCk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoTnVtYmVyKGhlaWdodFN0YXJ0KSk7XG4gICAgfVxuICAgIGdldEhlaWdodEVuZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLkhlaWdodEVuZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZnRzXzEubm9uZSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaGVpZ2h0RW5kXSA9IHRoaXMuZmllbGRzLmdldChUYWcuSGVpZ2h0RW5kKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIoaGVpZ2h0RW5kKSk7XG4gICAgfVxuICAgIGdldE9mZnNldFN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzLmhhcyhUYWcuT2Zmc2V0U3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW29mZnNldFN0YXJ0XSA9IHRoaXMuZmllbGRzLmdldChUYWcuT2Zmc2V0U3RhcnQpO1xuICAgICAgICByZXR1cm4gKDAsIGZ0c18xLnNvbWUpKE51bWJlcihvZmZzZXRTdGFydCkpO1xuICAgIH1cbiAgICBnZXRPZmZzZXRFbmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5PZmZzZXRFbmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW29mZnNldEVuZF0gPSB0aGlzLmZpZWxkcy5nZXQoVGFnLk9mZnNldEVuZCk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoTnVtYmVyKG9mZnNldEVuZCkpO1xuICAgIH1cbiAgICBnZXRDYXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5DYXApKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2NhcF0gPSB0aGlzLmZpZWxkcy5nZXQoVGFnLkNhcCk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoTnVtYmVyKGNhcCkpO1xuICAgIH1cbiAgICBnZXRBbW91bnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5BbW91bnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2Ftb3VudF0gPSB0aGlzLmZpZWxkcy5nZXQoVGFnLkFtb3VudCk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoTnVtYmVyKGFtb3VudCkpO1xuICAgIH1cbiAgICBnZXRTeW1ib2woKSB7XG4gICAgICAgIGlmICghdGhpcy5maWVsZHMuaGFzKFRhZy5TeW1ib2wpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3N5bWJvbF0gPSB0aGlzLmZpZWxkcy5nZXQoVGFnLlN5bWJvbCk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkoU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoc3ltYm9sKSkpO1xuICAgIH1cbiAgICBnZXRUZXJtcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZsYWdzKEZsYWcuVGVybXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5nZXRDYXAoKTtcbiAgICAgICAgaWYgKCFjYXAuaXNTb21lKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGNhcCBmaWVsZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbW91bnQgPSB0aGlzLmdldEFtb3VudCgpO1xuICAgICAgICBpZiAoIWFtb3VudC5pc1NvbWUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gYW1vdW50IGZpZWxkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlaWdodFN0YXJ0ID0gdGhpcy5nZXRIZWlnaHRTdGFydCgpO1xuICAgICAgICBjb25zdCBoZWlnaHRFbmQgPSB0aGlzLmdldEhlaWdodEVuZCgpO1xuICAgICAgICBjb25zdCBvZmZzZXRTdGFydCA9IHRoaXMuZ2V0T2Zmc2V0U3RhcnQoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0RW5kID0gdGhpcy5nZXRPZmZzZXRFbmQoKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbmV3IFJhbmdlKGhlaWdodFN0YXJ0LCBoZWlnaHRFbmQpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBuZXcgUmFuZ2Uob2Zmc2V0U3RhcnQsIG9mZnNldEVuZCk7XG4gICAgICAgIHJldHVybiAoMCwgZnRzXzEuc29tZSkobmV3IFRlcm1zKGFtb3VudC52YWx1ZSgpLCBjYXAudmFsdWUoKSwgaGVpZ2h0LCBvZmZzZXQpKTtcbiAgICB9XG4gICAgZ2V0UG9pbnRlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkcy5oYXMoVGFnLlBvaW50ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGZ0c18xLm5vbmUpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3BvaW50ZXJdID0gdGhpcy5maWVsZHMuZ2V0KFRhZy5Qb2ludGVyKTtcbiAgICAgICAgcmV0dXJuICgwLCBmdHNfMS5zb21lKShOdW1iZXIocG9pbnRlcikpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZSA9IE1lc3NhZ2U7XG5jbGFzcyBFdGNoSW5zY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcyA9IG5ldyBNYXAoKSwgZGF0YSA9IEJ1ZmZlci5hbGxvYygwKSkge1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgc2V0Q29udGVudChjb250ZW50VHlwZSwgZGF0YSkge1xuICAgICAgICB0aGlzLmZpZWxkcy5zZXQoMSwgQnVmZmVyLmZyb20oY29udGVudFR5cGUsICd1dGY4JykpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBzZXRSdW5lKHJ1bmUpIHtcbiAgICAgICAgY29uc3QgbiA9ICgwLCBiYXNlMjZfMS5iYXNlMjZFbmNvZGUpKCgwLCBzcGFjZXJzXzEucmVtb3ZlU3BhY2VycykocnVuZSkpO1xuICAgICAgICBsZXQgbnN0ciA9IG4udG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAobnN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgICAgICBuc3RyID0gJzAnICsgbnN0cjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEZpZWxkKEV0Y2hJbnNjcmlwdGlvbi5UYWcuUlVORSwgQnVmZmVyLmZyb20obnN0ciwgJ2hleCcpLnJldmVyc2UoKSk7XG4gICAgfVxuICAgIHNldEZpZWxkKGZpZWxkLCB2YWwpIHtcbiAgICAgICAgdGhpcy5maWVsZHMuc2V0KGZpZWxkLCB2YWwpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjaXBoZXIocmF3VHgsIGlucHV0SWR4KSB7XG4gICAgICAgIGNvbnN0IHR4ID0gYml0Y29pbmpzX2xpYl8xLlRyYW5zYWN0aW9uLmZyb21IZXgocmF3VHgpO1xuICAgICAgICBjb25zdCB3aXRuZXNzID0gdHguaW5zW2lucHV0SWR4XS53aXRuZXNzO1xuICAgICAgICBjb25zdCB0YXBzY3JpcHQgPSB3aXRuZXNzWzFdO1xuICAgICAgICBjb25zdCBscyA9IGJpdGNvaW5qc19saWJfMS5zY3JpcHQuZGVjb21waWxlKHRhcHNjcmlwdCk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZGF0YUNodW5rcyA9IFtdO1xuICAgICAgICBsZXQgaXNEYXRhID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSA1OyBpIDwgbHMubGVuZ3RoIC0gMTspIHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gbHNbaV07XG4gICAgICAgICAgICBpZiAoY2h1bmsgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpc0RhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIERhdGFcbiAgICAgICAgICAgICAgICBkYXRhQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZpZWxkc1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhZyA9IGNodW5rIC0gODA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gbHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmYgPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmYud3JpdGVVaW50OCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KHRhZywgYnVmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZHMuc2V0KHRhZywgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXRjaEluc2NyaXB0aW9uKGZpZWxkcywgQnVmZmVyLmNvbmNhdChkYXRhQ2h1bmtzKSk7XG4gICAgfVxuICAgIGVuY2lwaGVyKCkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzLnB1c2goQnVmZmVyLmZyb20oJzAwNjMwMzZmNzI2NCcsICdoZXgnKSAvLyAwIE9QX0lGIFwib3JkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMuZmllbGRzLmVudHJpZXMoKSlcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pIC8vIFNvcnRpbmcgYnkgdGFnIGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbdGFnLCB2YWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFnQnVmZiA9IEJ1ZmZlci5hbGxvYygxKTtcbiAgICAgICAgICAgICAgICB0YWdCdWZmLndyaXRlVUludDgodGFnKTtcbiAgICAgICAgICAgICAgICByZXMucHVzaChCdWZmZXIuZnJvbSgnMDEnLCAnaGV4JykpO1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRhZ0J1ZmYpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoICE9IDEgfHwgdmFsWzBdICE9IDB4MDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goKDAsIHV0aWxzXzEudG9QdXNoRGF0YSkodmFsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzLnB1c2goQnVmZmVyLmZyb20oJzAwJywgJ2hleCcpKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFDaHVua3MgPSAoMCwgdXRpbHNfMS5jaHVua3MpKEFycmF5LmZyb20odGhpcy5kYXRhKSwgNTIwKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgZGF0YUNodW5rcykge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKCgwLCB1dGlsc18xLnRvUHVzaERhdGEpKEJ1ZmZlci5mcm9tKGNodW5rKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzLnB1c2goQnVmZmVyLmZyb20oJzAwNjMnLCAnaGV4JykgLy8gMCBPUF9JRlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bmUgPSB0aGlzLmZpZWxkcy5nZXQoRXRjaEluc2NyaXB0aW9uLlRhZy5SVU5FKTtcbiAgICAgICAgICAgIGlmICghcnVuZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVuZSBmb3VuZCFgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKCgwLCB1dGlsc18xLnRvUHVzaERhdGEpKHJ1bmUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChCdWZmZXIuZnJvbSgnNjgnLCAnaGV4JykpOyAvLyBPUF9FTkRJRlxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChyZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXRjaEluc2NyaXB0aW9uID0gRXRjaEluc2NyaXB0aW9uO1xuRXRjaEluc2NyaXB0aW9uLlRhZyA9IHtcbiAgICBDT05URU5UX1RZUEU6IDEsXG4gICAgUE9JTlRFUjogMixcbiAgICBQQVJFTlQ6IDMsXG4gICAgTUVUQURBVEE6IDUsXG4gICAgTUVUQVBST1RPQ09MOiA3LFxuICAgIENPTlRFTlRfRU5DT0RJTkc6IDksXG4gICAgREVMRUdBVEU6IDExLFxuICAgIFJVTkU6IDEzXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/runestones.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/spacers.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/spacers.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeSpacers = exports.getSpacersVal = exports.applySpacers = void 0;\nfunction applySpacers(str, spacers) {\n    let res = '';\n    for (let i = 0; i < str.length; i++) {\n        res += str.charAt(i);\n        if (spacers > 0) {\n            // Get the least significant bit\n            let bit = spacers & 1;\n            if (bit === 1) {\n                res += '•';\n            }\n            // Right shift the number to process the next bit\n            spacers >>= 1;\n        }\n    }\n    return res;\n}\nexports.applySpacers = applySpacers;\nfunction getSpacersVal(str) {\n    let res = 0;\n    let spacersCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        const char = str.charAt(i);\n        if (char === '•') {\n            res += 1 << (i - 1 - spacersCnt);\n            spacersCnt++;\n        }\n    }\n    return res;\n}\nexports.getSpacersVal = getSpacersVal;\nfunction removeSpacers(rune) {\n    return rune.replace(/[•]+/g, \"\");\n}\nexports.removeSpacers = removeSpacers;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWxpYkAxLjAuNy9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L3NwYWNlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9ydW5lbGliQDEuMC43L25vZGVfbW9kdWxlcy9ydW5lbGliL2Rpc3Qvc3BhY2Vycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVtb3ZlU3BhY2VycyA9IGV4cG9ydHMuZ2V0U3BhY2Vyc1ZhbCA9IGV4cG9ydHMuYXBwbHlTcGFjZXJzID0gdm9pZCAwO1xuZnVuY3Rpb24gYXBwbHlTcGFjZXJzKHN0ciwgc3BhY2Vycykge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXMgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKHNwYWNlcnMgPiAwKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdFxuICAgICAgICAgICAgbGV0IGJpdCA9IHNwYWNlcnMgJiAxO1xuICAgICAgICAgICAgaWYgKGJpdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlcyArPSAn4oCiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJpZ2h0IHNoaWZ0IHRoZSBudW1iZXIgdG8gcHJvY2VzcyB0aGUgbmV4dCBiaXRcbiAgICAgICAgICAgIHNwYWNlcnMgPj49IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuYXBwbHlTcGFjZXJzID0gYXBwbHlTcGFjZXJzO1xuZnVuY3Rpb24gZ2V0U3BhY2Vyc1ZhbChzdHIpIHtcbiAgICBsZXQgcmVzID0gMDtcbiAgICBsZXQgc3BhY2Vyc0NudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaGFyID09PSAn4oCiJykge1xuICAgICAgICAgICAgcmVzICs9IDEgPDwgKGkgLSAxIC0gc3BhY2Vyc0NudCk7XG4gICAgICAgICAgICBzcGFjZXJzQ250Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZ2V0U3BhY2Vyc1ZhbCA9IGdldFNwYWNlcnNWYWw7XG5mdW5jdGlvbiByZW1vdmVTcGFjZXJzKHJ1bmUpIHtcbiAgICByZXR1cm4gcnVuZS5yZXBsYWNlKC9b4oCiXSsvZywgXCJcIik7XG59XG5leHBvcnRzLnJlbW92ZVNwYWNlcnMgPSByZW1vdmVTcGFjZXJzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/spacers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/utils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/utils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toPushData = exports.chunks = exports.toHex = exports.zero2 = void 0;\n/**\n * Prepends a '0' to an odd character length word to ensure it has an even number of characters.\n * @param {string} word - The input word.\n * @returns {string} - The word with a leading '0' if it's an odd character length; otherwise, the original word.\n */\nconst zero2 = (word) => {\n    if (word.length % 2 === 1) {\n        return '0' + word;\n    }\n    else {\n        return word;\n    }\n};\nexports.zero2 = zero2;\n/**\n * Converts an array of numbers to a hexadecimal string representation.\n * @param {number[]} msg - The input array of numbers.\n * @returns {string} - The hexadecimal string representation of the input array.\n */\nconst toHex = (msg) => {\n    let res = '';\n    for (let i = 0; i < msg.length; i++) {\n        res += (0, exports.zero2)(msg[i].toString(16));\n    }\n    return res;\n};\nexports.toHex = toHex;\nfunction chunks(bin, chunkSize) {\n    const chunks = [];\n    let offset = 0;\n    while (offset < bin.length) {\n        // Use Buffer.slice to create a chunk. This method does not copy the memory;\n        // it creates a new Buffer that references the original memory.\n        const chunk = bin.slice(offset, offset + chunkSize);\n        chunks.push(chunk);\n        offset += chunkSize;\n    }\n    return chunks;\n}\nexports.chunks = chunks;\nfunction toPushData(data) {\n    const res = [];\n    const dLen = data.length;\n    if (dLen < 0x4c) {\n        const dLenBuff = Buffer.alloc(1);\n        dLenBuff.writeUInt8(dLen);\n        res.push(dLenBuff);\n    }\n    else if (dLen <= 0xff) {\n        // OP_PUSHDATA1\n        res.push(Buffer.from('4c', 'hex'));\n        const dLenBuff = Buffer.alloc(1);\n        dLenBuff.writeUInt8(dLen);\n        res.push(dLenBuff);\n    }\n    else if (dLen <= 0xffff) {\n        // OP_PUSHDATA2\n        res.push(Buffer.from('4d', 'hex'));\n        const dLenBuff = Buffer.alloc(2);\n        dLenBuff.writeUint16LE(dLen);\n        res.push(dLenBuff);\n    }\n    else {\n        // OP_PUSHDATA4\n        res.push(Buffer.from('4e', 'hex'));\n        const dLenBuff = Buffer.alloc(4);\n        dLenBuff.writeUint32LE(dLen);\n        res.push(dLenBuff);\n    }\n    res.push(data);\n    return Buffer.concat(res);\n}\nexports.toPushData = toPushData;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcnVuZWxpYkAxLjAuNy9ub2RlX21vZHVsZXMvcnVuZWxpYi9kaXN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsYUFBYTtBQUNuRTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUSwrREFBK0Q7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9idGMvbWlkbC14LWJpdGNvaW4tc3VtbWl0LWhhY2thdGhvbi0yMDI1L3V0eG8tcHNidC1kZW1vL25vZGVfbW9kdWxlcy8ucG5wbS9ydW5lbGliQDEuMC43L25vZGVfbW9kdWxlcy9ydW5lbGliL2Rpc3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvUHVzaERhdGEgPSBleHBvcnRzLmNodW5rcyA9IGV4cG9ydHMudG9IZXggPSBleHBvcnRzLnplcm8yID0gdm9pZCAwO1xuLyoqXG4gKiBQcmVwZW5kcyBhICcwJyB0byBhbiBvZGQgY2hhcmFjdGVyIGxlbmd0aCB3b3JkIHRvIGVuc3VyZSBpdCBoYXMgYW4gZXZlbiBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JkIC0gVGhlIGlucHV0IHdvcmQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSB3b3JkIHdpdGggYSBsZWFkaW5nICcwJyBpZiBpdCdzIGFuIG9kZCBjaGFyYWN0ZXIgbGVuZ3RoOyBvdGhlcndpc2UsIHRoZSBvcmlnaW5hbCB3b3JkLlxuICovXG5jb25zdCB6ZXJvMiA9ICh3b3JkKSA9PiB7XG4gICAgaWYgKHdvcmQubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB3b3JkO1xuICAgIH1cbn07XG5leHBvcnRzLnplcm8yID0gemVybzI7XG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIG51bWJlcnMgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcGFyYW0ge251bWJlcltdfSBtc2cgLSBUaGUgaW5wdXQgYXJyYXkgb2YgbnVtYmVycy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQgYXJyYXkuXG4gKi9cbmNvbnN0IHRvSGV4ID0gKG1zZykgPT4ge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXMgKz0gKDAsIGV4cG9ydHMuemVybzIpKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmZ1bmN0aW9uIGNodW5rcyhiaW4sIGNodW5rU2l6ZSkge1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChvZmZzZXQgPCBiaW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIFVzZSBCdWZmZXIuc2xpY2UgdG8gY3JlYXRlIGEgY2h1bmsuIFRoaXMgbWV0aG9kIGRvZXMgbm90IGNvcHkgdGhlIG1lbW9yeTtcbiAgICAgICAgLy8gaXQgY3JlYXRlcyBhIG5ldyBCdWZmZXIgdGhhdCByZWZlcmVuY2VzIHRoZSBvcmlnaW5hbCBtZW1vcnkuXG4gICAgICAgIGNvbnN0IGNodW5rID0gYmluLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgY2h1bmtTaXplKTtcbiAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmtzO1xufVxuZXhwb3J0cy5jaHVua3MgPSBjaHVua3M7XG5mdW5jdGlvbiB0b1B1c2hEYXRhKGRhdGEpIHtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKGRMZW4gPCAweDRjKSB7XG4gICAgICAgIGNvbnN0IGRMZW5CdWZmID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICBkTGVuQnVmZi53cml0ZVVJbnQ4KGRMZW4pO1xuICAgICAgICByZXMucHVzaChkTGVuQnVmZik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRMZW4gPD0gMHhmZikge1xuICAgICAgICAvLyBPUF9QVVNIREFUQTFcbiAgICAgICAgcmVzLnB1c2goQnVmZmVyLmZyb20oJzRjJywgJ2hleCcpKTtcbiAgICAgICAgY29uc3QgZExlbkJ1ZmYgPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgICAgIGRMZW5CdWZmLndyaXRlVUludDgoZExlbik7XG4gICAgICAgIHJlcy5wdXNoKGRMZW5CdWZmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZExlbiA8PSAweGZmZmYpIHtcbiAgICAgICAgLy8gT1BfUFVTSERBVEEyXG4gICAgICAgIHJlcy5wdXNoKEJ1ZmZlci5mcm9tKCc0ZCcsICdoZXgnKSk7XG4gICAgICAgIGNvbnN0IGRMZW5CdWZmID0gQnVmZmVyLmFsbG9jKDIpO1xuICAgICAgICBkTGVuQnVmZi53cml0ZVVpbnQxNkxFKGRMZW4pO1xuICAgICAgICByZXMucHVzaChkTGVuQnVmZik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPUF9QVVNIREFUQTRcbiAgICAgICAgcmVzLnB1c2goQnVmZmVyLmZyb20oJzRlJywgJ2hleCcpKTtcbiAgICAgICAgY29uc3QgZExlbkJ1ZmYgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgICAgIGRMZW5CdWZmLndyaXRlVWludDMyTEUoZExlbik7XG4gICAgICAgIHJlcy5wdXNoKGRMZW5CdWZmKTtcbiAgICB9XG4gICAgcmVzLnB1c2goZGF0YSk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmVzKTtcbn1cbmV4cG9ydHMudG9QdXNoRGF0YSA9IHRvUHVzaERhdGE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/runelib@1.0.7/node_modules/runelib/dist/utils.js\n");

/***/ })

};
;